var tipuesearch = {"pages":[{"text":"Carrier Cross Sections Installation Dependencies Install all of the required dependencies (commands given for Unix environment): sudo apt-get update\nsudo apt install gfortran\nsudo apt install libmpich-dev\nsudo apt install libopenmpi-dev\nsudo apt-get install python-pip python-dev build-essential\nsudo pip install ford\nsudo apt-get install graphviz\nsudo wget https://github.com/QEF/q-e/archive/qe-5.3.tar.gz\nsudo apt-get install git Set up Quantum Espresso Change to whatever directory you saved the QE tar file in on the CLI Decompress the tar file using tar -xvzf q-e-qe-5.3.tar.gz Change into the q-e-qe-5.3 directory and run ./configure Confirm that the last line of output is configure: success Run make pw pp ph to build the PW, PP, and PHonon packages Compile Source Clone the repository using git clone https://github.com/laurarnichols/carrierCrossSections.git Change into the carrierCrossSections directory Open the Makefile and edit the path to Quantum Espresso to match your system Note: Make sure that your path does not have a / at the end or there will be an error * You should now be able to make the target you want (e.g., to compile everything, use make all_QE-5.3.0 )\n* For a list of some possible targets, read through the Makefile or type make Documentation This documentation is generated by FORD . Note This documentation is in progress. Please report any issues you find. How to Run I don't know how to run yet, so this section contains notes to try to figure that out. Here is a flow chart describing \nhow the programs connect as far as I know. TME stands for transition matrix element LSF stands for line shape function Sigma is likely the cross section calculation Mj is likely calculating equation 46 (for linear phonon TMEs) If cross section (sigma) is goal (zeroth order): TME and LSF --> Sigma ? QE --> TME ? Input and Output QE: Input: scf.in Output: scf.out output directory (e.g. tmp ) Export: Input: output directory Output: export directory TME: Input: export directory Output: VfisVsE LSF: Input: phonons_disp.dat --> where does this come from? Output: lsfVsEwithUpTo<%i>phonons Sigma Input: VfisVsE lsfVsEwithUpTo<%i>phonons","tags":"home","loc":"index.html","title":" Carrier Cross Sections "},{"text":"Contents Programs pw_export_for_TME Modules io_base_export Source Code Export_QE-5.3.0_v3.f90 Source Code ! ! Copyright (C) 2003-2009 Andrea Ferretti and Quantum ESPRESSO group ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !=----------------------------------------------------------------------------=! MODULE io_base_export !=----------------------------------------------------------------------------=! ! do i = 1, nk             !                                                   ! !   WAVEFUNCTIONS( i )     !  write_restart_wfc         read_restart_wfc       ! ! end do                   !                                                   ! USE io_global , ONLY : stdout USE kinds USE parameters , ONLY : nsx IMPLICIT NONE SAVE INTEGER , PARAMETER :: file_version = 202 INTEGER :: restart_module_verbosity = 0 !=----------------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------------=! ! !=----------------------------------------------------------------------------=! ! ..  This subroutine write wavefunctions to the disk ! .. Where: ! iuni    = Restart file I/O fortran unit ! SUBROUTINE write_restart_wfc ( iuni , exportDir , & ik , nk , kunit , ispin , nspin , scal , wf0 , t0 , wfm , tm , ngw , gamma_only , nbnd , igl , ngwl ) ! USE mp_wave USE mp , ONLY : mp_sum , mp_get , mp_max USE mp_pools , ONLY : me_pool , my_pool_id , & nproc_pool , intra_pool_comm , root_pool USE mp_world , ONLY : mpime , nproc , root , world_comm USE io_global , ONLY : ionode , ionode_id USE iotk_module ! IMPLICIT NONE ! INTEGER , INTENT ( in ) :: iuni character ( len = 256 ), intent ( in ) :: exportDir INTEGER , INTENT ( in ) :: ik , nk , kunit , ispin , nspin COMPLEX ( DP ), INTENT ( in ) :: wf0 (:,:) COMPLEX ( DP ), INTENT ( in ) :: wfm (:,:) INTEGER , INTENT ( in ) :: ngw ! LOGICAL , INTENT ( in ) :: gamma_only INTEGER , INTENT ( in ) :: nbnd INTEGER , INTENT ( in ) :: ngwl INTEGER , INTENT ( in ) :: igl (:) REAL ( DP ), INTENT ( in ) :: scal LOGICAL , INTENT ( in ) :: t0 , tm INTEGER :: i , j , ierr , idum = 0 INTEGER :: nkl , nkr , nkbl , iks , ike , nkt , ikt , igwx , ig INTEGER :: npool , ipmask ( nproc ), ipsour COMPLEX ( DP ), ALLOCATABLE :: wtmp (:) INTEGER , ALLOCATABLE :: igltot (:) CHARACTER ( len = 20 ) :: section_name = 'wfc' LOGICAL :: twrite = . true . INTEGER :: ierr_iotk CHARACTER ( len = iotk_attlenx ) :: attr ! ! ... Subroutine Body ! ! set working variables for k point index (ikt) and k points number (nkt) ikt = ik nkt = nk !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkt / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkt - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ipmask = 0 ipsour = ionode_id !  find out the index of the processor which collect the data in the pool of ik IF ( npool > 1 ) THEN IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN IF ( me_pool == root_pool ) ipmask ( mpime + 1 ) = 1 ENDIF CALL mp_sum ( ipmask , world_comm ) DO i = 1 , nproc IF ( ipmask ( i ) == 1 ) ipsour = ( i - 1 ) ENDDO ENDIF igwx = 0 ierr = 0 IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN IF ( ngwl > size ( igl ) ) THEN ierr = 1 ELSE igwx = maxval ( igl ( 1 : ngwl ) ) ENDIF ENDIF ! get the maximum index within the pool ! CALL mp_max ( igwx , intra_pool_comm ) ! now notify all procs if an error has been found ! CALL mp_max ( ierr , world_comm ) IF ( ierr > 0 ) & CALL errore ( ' write_restart_wfc ' , ' wrong size ngl ' , ierr ) IF ( ipsour /= ionode_id ) THEN CALL mp_get ( igwx , igwx , mpime , ionode_id , ipsour , 1 , world_comm ) ENDIF ALLOCATE ( wtmp ( max ( igwx , 1 ) ) ) wtmp = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) DO j = 1 , nbnd IF ( t0 ) THEN IF ( npool > 1 ) THEN IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN CALL mergewf ( wf0 (:, j ), wtmp , ngwl , igl , me_pool , & nproc_pool , root_pool , intra_pool_comm ) ENDIF IF ( ipsour /= ionode_id ) THEN CALL mp_get ( wtmp , wtmp , mpime , ionode_id , ipsour , j , world_comm ) ENDIF ELSE CALL mergewf ( wf0 (:, j ), wtmp , ngwl , igl , mpime , nproc , & ionode_id , world_comm ) ENDIF IF ( ionode ) THEN do ig = 1 , igwx write ( iuni , '(2ES24.15E3)' ) wtmp ( ig ) enddo ! !              do j = 1, nbnd !                do i = 1, igwx ! ngk_g(ik) !                  write(74,'(2ES24.15E3)') wf0(i,j) ! wf0 is the local array for evc(i,j) !                enddo !              enddo ! ENDIF ELSE ENDIF ENDDO !        DO j = 1, nbnd !          IF( tm ) THEN !            IF( npool > 1 ) THEN !              IF( ( ikt >= iks ) .and. ( ikt <= ike ) ) THEN !                CALL mergewf(wfm(:,j), wtmp, ngwl, igl, me_pool, & !                             nproc_pool, root_pool, intra_pool_comm) !              ENDIF !              IF( ipsour /= ionode_id ) THEN !                CALL mp_get( wtmp, wtmp, mpime, ionode_id, ipsour, j, world_comm ) !              ENDIF !            ELSE !              CALL mergewf(wfm(:,j), wtmp, ngwl, igl, mpime, nproc, ionode_id, world_comm ) !            ENDIF !            IF( ionode ) THEN !              CALL iotk_write_dat(iuni,\"Wfcm\"//iotk_index(j),wtmp(1:igwx)) !            ENDIF !          ELSE !          ENDIF !        ENDDO IF ( ionode ) then close ( iuni ) !CALL iotk_write_end  (iuni,\"Kpoint\"//iotk_index(ik)) endif DEALLOCATE ( wtmp ) RETURN END SUBROUTINE END MODULE !=----------------------------------------------------------------------------=! !----------------------------------------------------------------------- PROGRAM pw_export_for_TME !----------------------------------------------------------------------- ! ! writes PWSCF data for postprocessing purposes in XML format using IOTK lib ! Wave-functions are collected and written using IO_BASE module. ! ! input:  namelist \"&inputpp\", with variables !   prefix       prefix of input files saved by program pwscf !   outdir       temporary directory where files resides !   exportDir    output directory. A directory !                \"exportDir\" is created and !                output files are put there. All the data !                are accessible through the \"\"exportDir\"/input\" file. ! USE wrappers , ONLY : f_mkdir_safe USE pwcom USE io_global , ONLY : ionode , ionode_id USE io_files , ONLY : prefix , tmp_dir , outdir USE ions_base , ONLY : ntype => nsp USE iotk_module USE mp_global , ONLY : mp_startup USE mp_pools , ONLY : kunit USE mp_world , ONLY : world_comm USE mp , ONLY : mp_bcast USE environment , ONLY : environment_start ! IMPLICIT NONE ! CHARACTER ( LEN = 256 ), EXTERNAL :: trimcheck ! INTEGER :: ik , i , kunittmp , ios ! real ( kind = dp ), parameter :: ryToHartree = 0.5_dp ! CHARACTER ( len = 256 ) :: pp_file , exportDir LOGICAL :: writeWFC ! NAMELIST / inputpp / prefix , outdir , exportDir , writeWFC ! ! initialise environment ! #ifdef __MPI CALL mp_startup ( ) #endif CALL environment_start ( 'PW_EXPORT' ) ! !   set default values for variables in namelist ! prefix = '' CALL get_environment_variable ( 'ESPRESSO_TMPDIR' , outdir ) IF ( trim ( outdir ) == ' ' ) outdir = './' exportDir = './Export' ! writeWFC = . true . ! gdb : by default the wavefunctions are needed, !       this gives the user the ability not to write the wavefunctions ! !    Reading input file ! IF ( ionode ) THEN ! CALL input_from_file ( ) ! READ ( 5 , inputpp , IOSTAT = ios ) ! IF ( ios /= 0 ) CALL errore ( 'pw_export' , 'reading inputpp namelist' , abs ( ios ) ) ! ios = f_mkdir_safe ( trim ( exportDir ) ) ! pp_file = trim ( exportDir ) // \"/input\" ! ! ENDIF ! ! ... Broadcasting variables ! tmp_dir = trimcheck ( outdir ) CALL mp_bcast ( outdir , ionode_id , world_comm ) CALL mp_bcast ( tmp_dir , ionode_id , world_comm ) CALL mp_bcast ( prefix , ionode_id , world_comm ) ! !   Now allocate space for pwscf variables, read and check them. ! CALL read_file CALL openfil_pp ! #if defined __MPI kunittmp = kunit #else kunittmp = 1 #endif CALL write_export ( pp_file , exportDir , kunittmp ) CALL stop_pp ! CONTAINS ! !----------------------------------------------------------------------- SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export END PROGRAM pw_export_for_TME","tags":"","loc":"sourcefile/export_qe-5.3.0_v3.f90.html","title":"Export_QE-5.3.0_v3.f90 – Carrier Cross Sections"},{"text":"Contents Programs transitionMatrixElements Source Code TME_Main_v9.f90 Source Code program transitionMatrixElements !! @todo Finish documentation for main program @endtodo !! !! <h2>Walkthrough</h2> !! use mpi use TMEModule !! * Use pre-built mpi library and declarations module that !! is defined in TME_Module_v28.f90 ! implicit none ! real ( kind = dp ) :: t1 , t2 !! * Declare start and end times ! call MPI_INIT ( ierr ) !! * Initialize MPI environment call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) !! * Determine the rank or ID of the calling process call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) !! * Determine the size of the MPI pool (i.e., the number of processes) ! allocate ( nPWsI ( 0 : numprocs - 1 ), nPWsF ( 0 : numprocs - 1 ) ) ! if ( myid == root ) then !! * If this is the root process !!    * Call [[TMEModule(module):initializeCalculation(subroutine)]] !!      to start timer and set default values !!    * Call [[TMEModule(module):readInput(subroutine)]] to read program input and !!      QE Export output !!    * Call [[TMEModule(module):readPWsSet(subroutine)]] to read g vectors from `mgrid` file !!    * Initialize all values in `Ufi` matrix to complex double zero !!    * Figure out how many g vectors/plane waves to give each process !!    * Initialize the number of initial and final plane waves to zero for each process !!    * For each process, calculate the initial (before this process) and final (after this process) !!      number of plane waves ! call initializeCalculation ( solidDefect , perfectCrystal , elementsPath , VFisOutput , ki , kf , eBin , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , calculateVFis , t0 ) ! call readInput ( perfectCrystal , solidDefect , elementsPath , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput ) ! call readPWsSet () ! !> @todo Figure out if need to allocate space for arrays so soon @endtodo allocate ( counts ( 0 : numprocs - 1 ) ) !, displmnt(0:numprocs-1) ) allocate ( Ufi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , perfectCrystal % nKpts ) ) allocate ( paw_SDKKPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( perfectCrystal % paw_Wfc ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( solidDefect % paw_Wfc ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_fi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( eigvI ( iBandIinit : iBandIfinal ), eigvF ( iBandFinit : iBandFfinal ) ) ! Ufi (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! call distributePWsToProcs ( solidDefect % numOfGvecs , numprocs ) !! @todo Figure out if SD and PC `numOfGvecs` should be the same @endtodo ! nPWsI (:) = 0 nPWsF (:) = 0 ! do i = 0 , numprocs - 1 nPWsI ( i ) = 1 + sum ( counts (: i - 1 )) nPWsF ( i ) = sum ( counts (: i )) enddo ! endif ! !-------------------------------------------------------------------------------------------------------- !> Broadcast variables from root process to all other processes, allocating space as needed ! call MPI_BCAST ( iBandIinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandIfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % nKpts , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % nProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nBands , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nSpins , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % numOfPWs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % numOfGvecs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nPWsI , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nPWsF , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( JMAX , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( gvecs ( 3 , solidDefect % numOfGvecs ) ) call MPI_BCAST ( gvecs , size ( gvecs ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( perfectCrystal % atoms ( perfectCrystal % numOfTypes ) ) ! do i = 1 , perfectCrystal % numOfTypes ! call MPI_BCAST ( perfectCrystal % atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% numProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% iRAugMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( perfectCrystal % atoms ( i )% projAngMom ( perfectCrystal % atoms ( i )% numProjs ) ) allocate ( perfectCrystal % atoms ( i )% r ( perfectCrystal % atoms ( i )% nMax ) ) allocate ( perfectCrystal % atoms ( i )% rab ( perfectCrystal % atoms ( i )% nMax ) ) allocate ( perfectCrystal % atoms ( i )% F ( perfectCrystal % atoms ( i )% iRAugMax , perfectCrystal % atoms ( i )% numProjs ) ) allocate ( perfectCrystal % atoms ( i )% F1 ( perfectCrystal % atoms ( i )% iRAugMax , perfectCrystal % atoms ( i )% numProjs , & perfectCrystal % atoms ( i )% numProjs )) allocate ( perfectCrystal % atoms ( i )% bes_J_qr ( 0 : JMAX , perfectCrystal % atoms ( i )% iRAugMax ) ) endif ! call MPI_BCAST ( perfectCrystal % atoms ( i )% projAngMom , size ( perfectCrystal % atoms ( i )% projAngMom ), & MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% r , size ( perfectCrystal % atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% rab , size ( perfectCrystal % atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% F , size ( perfectCrystal % atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% F1 , size ( perfectCrystal % atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% bes_J_qr , size ( perfectCrystal % atoms ( i )% bes_J_qr ), & MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( perfectCrystal % nIons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( perfectCrystal % posIon ( 3 , perfectCrystal % nIons ), perfectCrystal % atomTypeIndex ( perfectCrystal % nIons ) ) call MPI_BCAST ( perfectCrystal % atomTypeIndex , size ( perfectCrystal % atomTypeIndex ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % posIon , size ( perfectCrystal % posIon ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( solidDefect % numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( solidDefect % atoms ( solidDefect % numOfTypes ) ) ! do i = 1 , solidDefect % numOfTypes ! call MPI_BCAST ( solidDefect % atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% numProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% iRAugMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( solidDefect % atoms ( i )% projAngMom ( solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% r ( solidDefect % atoms ( i )% nMax ) ) allocate ( solidDefect % atoms ( i )% rab ( solidDefect % atoms ( i )% nMax ) ) allocate ( solidDefect % atoms ( i )% F ( solidDefect % atoms ( i )% iRAugMax , solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% F1 ( solidDefect % atoms ( i )% iRAugMax , & solidDefect % atoms ( i )% numProjs , solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% bes_J_qr ( 0 : JMAX , solidDefect % atoms ( i )% iRAugMax ) ) endif ! call MPI_BCAST ( solidDefect % atoms ( i )% projAngMom , size ( solidDefect % atoms ( i )% projAngMom ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% r , size ( solidDefect % atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% rab , size ( solidDefect % atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% F , size ( solidDefect % atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% F1 , size ( solidDefect % atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% bes_J_qr , size ( solidDefect % atoms ( i )% bes_J_qr ), MPI_DOUBLE_PRECISION , & root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( solidDefect % nIons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( solidDefect % posIon ( 3 , solidDefect % nIons ), solidDefect % atomTypeIndex ( solidDefect % nIons ) ) call MPI_BCAST ( solidDefect % atomTypeIndex , size ( solidDefect % atomTypeIndex ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % posIon , size ( solidDefect % posIon ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! allocate ( paw_id ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) ! !-------------------------------------------------------------------------------------------------------- ! do ik = 1 , perfectCrystal % nKpts ! if ( myid == root ) then ! tmes_file_exists = . false . call checkIfCalculated ( ik , tmes_file_exists ) ! endif ! call MPI_BCAST ( tmes_file_exists , 1 , MPI_LOGICAL , root , MPI_COMM_WORLD , ierr ) ! if ( . not . tmes_file_exists ) then ! allocate ( perfectCrystal % cProj ( perfectCrystal % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) allocate ( solidDefect % cProj ( solidDefect % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) ! if ( myid == root ) then ! write ( iostd , '(\" Starting Ufi(:,:) calculation for k-point\", i4, \" of\", i4)' ) ik , perfectCrystal % nKpts flush ( iostd ) ! write ( iostd , * ) write ( iostd , '(\"    Plane waves part begun.\")' ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> begun.\")' ) call cpu_time ( t1 ) allocate ( perfectCrystal % wfc ( solidDefect % numOfPWs , iBandIinit : iBandIfinal ), & solidDefect % wfc ( solidDefect % numOfPWs , iBandFinit : iBandFfinal ) ) ! call calculatePWsOverlap ( ik ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! write ( iostd , '(\"    Plane waves part done in\", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) write ( iostd , '(\"    PAW part begun.\")' ) ! call cpu_time ( t1 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> begun.\")' ) flush ( iostd ) ! call readProjections ( ik , perfectCrystal ) ! allocate ( perfectCrystal % cCrossProj ( perfectCrystal % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) call projectBeta ( ik , perfectCrystal , solidDefect ) ! deallocate ( solidDefect % wfc ) ! call pawCorrectionWfc ( perfectCrystal ) ! deallocate ( perfectCrystal % cCrossProj ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 call cpu_time ( t1 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> begun.\")' ) flush ( iostd ) ! call readProjections ( ik , solidDefect ) ! allocate ( solidDefect % cCrossProj ( solidDefect % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) call projectBeta ( ik , solidDefect , perfectCrystal ) ! deallocate ( perfectCrystal % wfc ) ! call pawCorrectionWfc ( solidDefect ) deallocate ( solidDefect % cCrossProj ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! call cpu_time ( t1 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6ES14.5E3)') ibi, ibf, solidDefect%paw_Wfc(ibf,ibi), perfectCrystal%paw_Wfc(ibf,ibi), paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! !call pawCorrection() !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) + paw_fi(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf,ibi,ik), paw, Ufi(ibf,ibi,ik) + paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! endif ! call MPI_BCAST ( perfectCrystal % cProj , size ( perfectCrystal % cProj ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % cProj , size ( solidDefect % cProj ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) ! allocate ( perfectCrystal % pawK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid )) ) ! call pawCorrectionK ( perfectCrystal ) ! if ( myid == root ) then call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 ! call cpu_time ( t1 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> begun.\")' ) flush ( iostd ) ! endif ! allocate ( solidDefect % pawK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid ) ) ) ! call pawCorrectionK ( solidDefect ) ! if ( myid == root ) then ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> done in\", f10.2, \" secs.\")' ) t2 - t1 ! call cpu_time ( t1 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) ! endif ! paw_id (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal paw_id ( ibf , ibi ) = sum ( solidDefect % pawK ( ibf , ibi ,:) * perfectCrystal % pawK ( ibf , ibi ,:)) enddo ! enddo ! if ( myid == root ) paw_SDKKPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! CALL MPI_REDUCE ( paw_id , paw_SDKKPC , size ( paw_id ), MPI_DOUBLE_COMPLEX , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call cpu_time ( t2 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! Ufi (:,:, ik ) = Ufi (:,:, ik ) + solidDefect % paw_Wfc (:,:) + perfectCrystal % paw_Wfc (:,:) + & paw_SDKKPC (:,:) * 1 6.0_dp * pi * pi / solidDefect % omega !! @todo Figure out if should be solid defect volume or pristine @endtodo !! @todo Are pristine and solid defect volume the same? @endtodo ! call writeResults ( ik ) ! !write(iostd,*)'--------------------------------------------------------------------------------------------' ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = iBandFinit, iBandFfinal !    !paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) + paw_SDKKPC(ibf,ibi)*16.0_dp*pi*pi/solidDefect%omega !    !write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf, ibi, ik), paw, Ufi(ibf, ibi, ik) + paw !    !Ufi(ibf, ibi, ik) = Ufi(ibf, ibi, ik) + paw !    write(iostd,'(\" Ufi \", 2i4, 2ES24.15E3)') ibi, ibf, Ufi(ibf, ibi, ik) !  enddo !  ! !  flush(iostd) !  ! !enddo ! !write(iostd,*)'--------------------------------------------------------------------------------------------' !flush(iostd) ! endif ! deallocate ( perfectCrystal % cProj , perfectCrystal % pawK ) deallocate ( solidDefect % cProj , solidDefect % pawK ) ! else ! if ( myid == root ) call readUfis ( ik ) ! endif ! enddo ! if ( allocated ( paw_id ) ) deallocate ( paw_id ) if ( myid == root ) then if ( allocated ( perfectCrystal % paw_Wfc ) ) deallocate ( perfectCrystal % paw_Wfc ) if ( allocated ( solidDefect % paw_Wfc ) ) deallocate ( solidDefect % paw_Wfc ) endif ! ! Calculating Vfi ! if ( myid == root ) then ! if ( calculateVfis ) call calculateVfiElements () ! ! Finalize Calculation ! call finalizeCalculation () ! endif ! call MPI_FINALIZE ( ierr ) ! end program transitionMatrixElements","tags":"","loc":"sourcefile/tme_main_v9.f90.html","title":"TME_Main_v9.f90 – Carrier Cross Sections"},{"text":"Contents Modules TMEModule Source Code TME_Module_v28.f90 Source Code module TMEModule ! !! Declare all global variables !! and house all subroutines !! implicit none ! ! Declare integer parameters integer , parameter :: dp = selected_real_kind ( 15 , 307 ) !! Used to set real variables to double precision integer , parameter :: iostd = 16 !! Unit number for output file integer , parameter :: root = 0 !! ID of the root process ! ! Declare real parameters real ( kind = dp ), parameter :: evToHartree = 0.03674932538878_dp !! Conversion factor from eV to Hartree real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp !! Conversion factor from Hartree to eV real ( kind = dp ), parameter :: pi = 3.141592653589793_dp !! Pi real ( kind = dp ), parameter :: sq4pi = 3.544907701811032_dp !! \\sqrt{4\\pi} ! ! Declare complex parameter complex ( kind = dp ), parameter :: ii = cmplx ( 0.0_dp , 1.0_dp , kind = dp ) !! Complex i ! ! Declare character parameter character ( len = 6 ), parameter :: output = 'output' !! Name of the output file; !! used in [[TMEModule(module):readInput(subroutine)]] !! @todo Change I/O from file to console so that usage matches that of QE @endtodo ! ! ! Declare scalar integers integer :: gx integer :: gy integer :: gz integer :: i integer :: iBandFfinal integer :: iBandFinit integer :: iBandIfinal integer :: iBandIinit integer :: ibf integer :: ibi integer :: id integer :: ierr !! Error code returned from MPI integer :: ig integer :: ik integer :: ind2 integer :: ios !! Status returned from I/O commands integer :: iPn integer :: iTypes integer :: j integer :: JMAX !! 2*L_{\\text{max}} + 1 integer :: kf integer :: ki integer :: maxL !! Maximum angular momentum of projector from any atom type integer :: myid !! ID for each MPI process integer :: n integer :: n1 integer :: n2 integer :: n3 integer :: n4 integer :: nF integer :: nGf integer :: nGi integer :: nGvsF integer :: nGvsI integer :: nI integer :: np integer :: nPP integer :: npw integer :: npwMf integer :: npwMi integer :: npwNf integer :: npwNi integer :: nSquareProcs integer :: numOfPWs integer :: numOfUsedGvecsPP integer :: numprocs !! Number of processes in the MPI pool ! ! Declare scalar reals real ( kind = dp ) :: eBin real ( kind = dp ) t0 !! Start time for program real ( kind = dp ) tf !! End time for program real ( kind = dp ) :: threej ! ! Declare scalar complex numbers complex ( kind = dp ) :: paw complex ( kind = dp ) :: paw2 complex ( kind = dp ) :: pseudo1 complex ( kind = dp ) :: pseudo2 ! ! Define scalar logicals logical :: calculateVfis logical :: coulomb logical :: gamma_only logical :: master logical :: tmes_file_exists ! ! Declare scalar characters character ( len = 300 ) :: elementsPath character ( len = 320 ) :: mkdir !! Command for creating the elements path directory character ( len = 300 ) :: textDum !! Dummy variable to hold unneeded lines from input file character ( len = 200 ) :: VfisOutput !! Output file for ?? ! ! ! Declare matrix/vector integers integer , allocatable :: counts (:) !integer, allocatable :: displmnt(:) integer , allocatable :: igvs (:,:,:) integer , allocatable :: iqs (:) integer , allocatable :: nFs (:,:) integer , allocatable :: ngs (:,:) integer , allocatable :: nIs (:,:) integer , allocatable :: nPWsI (:) integer , allocatable :: nPWsF (:) integer , allocatable :: pwGvecs (:,:) integer , allocatable :: pwGs (:,:) ! ! Declare matrix/vector reals real ( kind = dp ), allocatable :: absVfi2 (:,:) real ( kind = dp ), allocatable :: DE (:,:) real ( kind = dp ), allocatable :: eigvF (:) real ( kind = dp ), allocatable :: eigvI (:) real ( kind = dp ), allocatable :: gvecs (:,:) ! ! Declare matrix/vector complex numbers complex ( kind = dp ), allocatable :: paw_id (:,:) complex ( kind = dp ), allocatable :: paw_fi (:,:) complex ( kind = dp ), allocatable :: pawPsiPC (:,:) complex ( kind = dp ), allocatable :: pawSDPhi (:,:) complex ( kind = dp ), allocatable :: paw_SDKKPC (:,:) complex ( kind = dp ), allocatable :: Ufi (:,:,:) ! ! ! type :: atom !! Define a new type to represent an atom in the structure. !! Each different type of atom in the structure will be another !! variable with the type `atom`. !! @todo Consider changing `atom` type to `element` since it holds more than one atom @endtodo ! ! Define scalar integers integer :: iRAugMax !! Maximum radius of beta projector (outer radius to integrate); !! for PAW augmentation charge may extend a bit further; I think this !! is the max index for the augmentation sphere, so I'm changing the !! name; last name was `iRc` integer :: numOfAtoms !! Number of atoms of a specific type in the structure integer :: numProjs !! Number of projectors integer :: lmMax !! Number of channels integer :: nMax !! Number of radial mesh points ! ! Define scalar character character ( len = 2 ) :: symbol !! Element name for the given atom type ! ! Define matrix/vector integer integer , allocatable :: projAngMom (:) !! Angular momentum of each projector ! ! Define matrix/vector reals real ( kind = dp ), allocatable :: bes_J_qr (:,:) real ( kind = dp ), allocatable :: F (:,:) real ( kind = dp ), allocatable :: F1 (:,:,:) real ( kind = dp ), allocatable :: F2 (:,:,:) real ( kind = dp ), allocatable :: r (:) !! Radial mesh real ( kind = dp ), allocatable :: rab (:) !! Derivative of radial mesh real ( kind = dp ), allocatable :: wae (:,:) !! All electron wavefunction real ( kind = dp ), allocatable :: wps (:,:) !! Psuedowavefunction ! end type atom ! ! type :: crystal integer :: nKpts !! Number of k points integer :: numOfPWs !! Total number of plane waves integer :: nIons !! Total number of atoms in system integer :: numOfTypes !! Number of different types of atoms integer :: nProjs !! Number of projectors integer :: numOfGvecs !! Number of G vectors !integer :: fftxMax, fftxMin, fftyMax, fftyMin, fftzMax, fftzMin !! FFT grid was read from `input` file but not used, so removed integer :: nBands !! Number of bands integer :: nSpins !! Number of spins integer , allocatable :: npws (:) !! Number of plane waves per k point integer , allocatable :: atomTypeIndex (:) !! Index of the given atom type !integer, allocatable :: groundState(:) ! Was read from `input` file but not used, so removed ! real ( kind = dp ) :: omega !! Cell volume !real(kind = dp) :: at(3,3) ! Was read from `input` file but not used, so removed real ( kind = dp ) :: bg ( 3 , 3 ) real ( kind = dp ), allocatable :: wk (:) real ( kind = dp ), allocatable :: xk (:, :) real ( kind = dp ), allocatable :: posIon (:,:) ! complex ( kind = dp ), allocatable :: wfc (:,:) complex ( kind = dp ), allocatable :: beta (:,:) complex ( kind = dp ), allocatable :: cProj (:,:,:) complex ( kind = dp ), allocatable :: cCrossProj (:,:,:) complex ( kind = dp ), allocatable :: paw_Wfc (:,:) complex ( kind = dp ), allocatable :: pawK (:,:,:) ! character ( len = 2 ) crystalType !! 'PC' for pristine crystal and 'SD' for solid defect character ( len = 200 ) :: exportDir !! Export directory from [[pw_export_for_tme(program)]] ! TYPE ( atom ), allocatable :: atoms (:) ! !    integer :: Jmax, maxL, iTypes, nn, nm !    integer :: i, j, n1, n2, n3, n4, n, id !    ! !    ! !    real(kind = dp), allocatable :: eigvI(:), eigvF(:) !    real(kind = dp), allocatable :: DE(:,:), absVfi2(:,:) !    ! !    complex(kind = dp), allocatable :: Ufi(:,:,:) !    ! !    integer, allocatable :: igvs(:,:,:), pwGvecs(:,:), iqs(:) !    integer, allocatable :: pwGs(:,:), nIs(:,:), nFs(:,:), ngs(:,:) ! end type crystal ! TYPE ( crystal ) :: perfectCrystal !! Structure that holds all of the information on the perfect crystal ! TYPE ( crystal ) :: solidDefect !! Structure that holds all of the information on the solid defect ! type :: vec ! integer :: ind integer , allocatable :: igN (:) integer , allocatable :: igM (:) end type vec ! ! Define vectors of vecs TYPE ( vec ), allocatable :: vecs (:) TYPE ( vec ), allocatable :: newVecs (:) ! ! !===================================================================================================== contains ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine initializeCalculation ( solidDefect , pristineCrystal , elementsPath , VFisOutput , ki , kf , eBin , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , calculateVFis , t0 ) !! Initialize the calculation by starting timer, !! setting start values for variables to be read from !! `.in` file, removing any existing output in the output directory, !! and opening a clean output file !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( out ) :: ki , kf , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! real ( kind = dp ), intent ( out ) :: eBin , t0 ! character ( len = 200 ), intent ( out ) :: VfisOutput character ( len = 300 ), intent ( out ) :: elementsPath ! logical , intent ( out ) :: calculateVfis logical :: fileExists !! Whether or not the output file already exists TYPE ( crystal ), intent ( inout ) :: solidDefect , pristineCrystal ! solidDefect % exportDir = '' perfectCrystal % exportDir = '' elementsPath = '' VfisOutput = '' ! ki = - 1 kf = - 1 ! eBin = - 1.0_dp ! iBandIinit = - 1 iBandIfinal = - 1 iBandFinit = - 1 iBandFfinal = - 1 ! calculateVfis = . false . ! perfectCrystal % crystalType = 'PC' solidDefect % crystalType = 'SD' ! call cpu_time ( t0 ) !! * Start a timer ! inquire ( file = output , exist = fileExists ) !! * Check if file output exists, if ( fileExists ) then !! and delete it if it does open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! return ! end subroutine initializeCalculation ! ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine readInput ( perfectCrystal , solidDefect , elementsPath , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput ) !! Delete any previous output, initialize input variables, !! start a timer, and read in the input files !! implicit none ! integer , intent ( inout ) :: ki , kf , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! character ( len = 300 ), intent ( inout ) :: elementsPath character ( len = 200 ), intent ( inout ) :: VfisOutput character ( len = 200 ) :: exportDirSD character ( len = 200 ) :: exportDirPC ! logical , intent ( inout ) :: calculateVfis ! TYPE ( crystal ), intent ( inout ) :: perfectCrystal !! Holds all of the information on the perfect crystal TYPE ( crystal ), intent ( inout ) :: solidDefect !! Holds all of the information on the defective crystal ! NAMELIST / TME_Input / exportDirSD , exportDirPC , elementsPath , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput , eBin !! Used to group the variables read in from the .in file ! ! READ ( 5 , TME_Input , iostat = ios ) !! * Read input from command line (or input file if use `< TME_Input.md`) solidDefect % exportDir = exportDirSD perfectCrystal % exportDir = exportDirPC ! call checkInitialization () !! * Check that all required variables were input and have values that make sense ! call readQEExport ( perfectCrystal ) !! * Read perfect crystal inputs call readQEExport ( solidDefect ) !! * Read solid defect inputs ! numOfPWs = max ( perfectCrystal % numOfPWs , solidDefect % numOfPWs ) !! * Calculate the number of plane waves as the maximum of the number of PC and SD plane waves ! return ! end subroutine readInput ! ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine checkInitialization () !! Check to see if variables from .in file still !! have the values set in [[TMEModule(module):initializeCalculation(subroutine)]] !! or if they have values that aren't allowed !! !! <h2>Walkthrough</h2> !! !! @todo Change `checkInitialization()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! logical :: fileExists !! Whether or not the exported directory from [[pw_export_for_TME(program)]] !! exists logical :: abortExecution ! abortExecution = . false . !! * Set the default value of abort execution so that the program !! will only abort if there is an issue with the inputs ! write ( iostd , '(\" Inputs : \")' ) !! * Write out a header to the output file ! if ( wasRead ( LEN ( trim ( solidDefect % exportDir )) - 1 , 'exportDirSD' , 'exportDirSD = ''./Export/''' , abortExecution ) ) then !! * If the SD export directory variable was read !!    * Check if the SD export directory exists !!    * If the SD export directory doesn't exist !!       * Output an error message and set `abortExecution` to true !!    * Output the given SD export directory ! inquire ( file = trim ( solidDefect % exportDir ), exist = fileExists ) ! if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" exportDirSD :\", a, \" does not exist !\")' ) trim ( solidDefect % exportDir ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"exportDirSD = ''\", a, \"''\")' ) trim ( solidDefect % exportDir ) ! endif ! ! if ( wasRead ( LEN ( trim ( perfectCrystal % exportDir )) - 1 , 'exportDirPC' , 'exportDirPC = ''./Export/''' , abortExecution ) ) then !! * If the PC export directory variable was read !!    * Check if the PC export directory exists !!    * If the PC export directory doesn't exist !!       * Output an error message and set `abortExecution` to true !!    * Output the given PC export directory ! inquire ( file = trim ( perfectCrystal % exportDir ), exist = fileExists ) ! if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" exportDirPC :\", a, \" does not exist !\")' ) trim ( perfectCrystal % exportDir ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"exportDirPC = ''\", a, \"''\")' ) trim ( perfectCrystal % exportDir ) ! endif ! if ( . not . wasRead ( LEN ( elementsPath ) - 1 , 'elementsPath' , 'elementsPath = ''./''' ) ) then !! * If the elements path was not read, set the default value to `./` ! write ( iostd , '(\" The current directory will be used as elementsPath.\")' ) elementsPath = './' ! endif ! inquire ( file = trim ( elementsPath ), exist = fileExists ) !! * Check if the elements path folder exists already ! if ( . not . fileExists ) then !! * If the elements path folder doesn't already exist !!    * Write the `mkdir` command to a string !!    * Execute the command to create the directory ! write ( mkDir , '(\"mkdir -p \", a)' ) trim ( elementsPath ) ! call system ( mkDir ) ! endif ! write ( iostd , '(\"elementsPath = ''\", a, \"''\")' ) trim ( elementsPath ) !! * Output the elements path ! if ( wasRead ( iBandIinit , 'iBandIinit' , 'iBandIinit = 10' , abortExecution ) ) then !! * If `iBandIinit` was read, output its value ! write ( iostd , '(\"iBandIinit = \", i4)' ) iBandIinit ! endif ! if ( wasRead ( iBandIfinal , 'iBandIfinal' , 'iBandIfinal = 20' , abortExecution ) ) then !! * If `iBandIfinal` was read, output its value ! write ( iostd , '(\"iBandIfinal = \", i4)' ) iBandIfinal ! endif ! if ( wasRead ( iBandFinit , 'iBandFinit' , 'iBandFinit = 9' , abortExecution ) ) then !! * If `iBandFinit` was read, output its value ! write ( iostd , '(\"iBandFinit = \", i4)' ) iBandFinit ! endif ! if ( wasRead ( iBandFfinal , 'iBandFfinal' , 'iBandFfinal = 9' , abortExecution ) ) then !! * If `iBandFfinal` was read, output its value ! write ( iostd , '(\"iBandFfinal = \", i4)' ) iBandFfinal ! endif ! !> * If `calculateVfis` is true and `iBandFinit` and `iBandFfinal` are not equal !>    * Output an error message and set `abortExecution` to true if ( ( calculateVfis ) . and . ( iBandFinit /= iBandFfinal ) ) then ! write ( iostd , * ) write ( iostd , '(\" Vfis can be calculated only if the final state is one and only one!\")' ) write ( iostd , '(\" ''iBandFInit'' = \", i10)' ) iBandFinit write ( iostd , '(\" ''iBandFfinal'' = \", i10)' ) iBandFfinal write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"calculateVfis = \", l )' ) calculateVfis !! * Output the value of `calculateVfis` ! !> * If the `VfisOutput` file name is blank !>    * Output a warning message and set the default value to `VfisVsE` if ( trim ( VfisOutput ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"VfisOutput\"\" is not defined!\")' ) write ( iostd , '(\" usage : VfisOutput = ''VfisVsE''\")' ) write ( iostd , '(\" The default value ''VfisVsE'' will be used.\")' ) VfisOutput = 'VfisVsE' ! endif ! write ( iostd , '(\"VfisOutput = ''\", a, \"''\")' ) trim ( VfisOutput ) !! * Output the value of `VfisOutput` !> @todo Remove everything with `ki` and `kf` because never used @endtodo ! !if( .not. wasRead(ki, 'ki', 'ki = 1') ) then !  !! * If `ki` wasn't read, set the default value to 1 !  ! !  write(iostd, '(\" ki = 1 will be used.\")') !  ki = 1 !  ! !endif ! !if( .not. wasRead(kf, 'kf', 'kf = 1') ) then !  !! * If `kf` wasn't read, set the default value to the total !  !!   number of k points (actually done in [[TMEModeul(module):readQEInput(subroutine)]] !  !!   where the total number of k points is read !  ! !  write(iostd, '(\" kf = total number of k-points will be used.\")') !  ! !endif ! !if ( ki /= kf ) then !  write(iostd, *) !  write(iostd, '(\" Initial k-point index ''ki'', should be equal to the Final k-point index ''kf'' !\")') !  write(iostd, '(\" Calculation of transition matrix elements with momentum transfer is not implemented!\")') !  write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  abortExecution = .true. !endif ! if ( . not . wasRead ( INT ( eBin ), 'eBin' , 'eBin = 0.01' ) ) then !! * If the value of `eBin` was not read !!    * Output a warning message and set the default value to 0.01 eV ! write ( iostd , '(\" A default value of 0.01 eV will be used !\")' ) eBin = 0.01_dp ! eV ! endif ! write ( iostd , '(\"eBin = \", f8.4, \" (eV)\")' ) eBin !! * Output the value of eBin ! eBin = eBin * evToHartree !! * Convert `eBin` from eV to Hartree ! if ( abortExecution ) then !! * If `abortExecution` was ever set to true !!    * Output an error message and stop the program write ( iostd , '(\" Program stops!\")' ) stop endif ! flush ( iostd ) !! * Make the output file available for other processes ! return ! end subroutine checkInitialization ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine readQEExport ( system ) !! Read input files in the Export directory created by !! [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! ! implicit none ! !integer, intent(in) :: id ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect` ! integer :: i , ik , iType , ni !! Loop index integer :: iRAugMax !! Local value of `iRAugMax` for each atom so don't have to keep accessing in loop integer :: l !! Angular momentum of each projector read from input file integer :: ind !! Index of each projector read from input file integer :: iDum !! Dummy variable to hold trash from input file ! real ( kind = dp ) :: t1 !! Local start time real ( kind = dp ) :: t2 !! Local end time real ( kind = dp ) :: ef ! character ( len = 300 ) :: textDum !! Dummy variable to hold trash from input file character ( len = 300 ) :: input !! The input file path ! logical :: fileExists !! Whether or not the `input` file exists in the given !! Export directory ! call cpu_time ( t1 ) !! * Start a local timer ! !> * Output header to output file based on the input crystal type !> @note !> The program will end if a crystal type other than `PC` or `SD` is used. !> @endnote write ( iostd , * ) if ( system % crystalType == 'PC' ) then ! write ( iostd , '(\" Reading perfect crystal inputs.\")' ) ! else if ( system % crystalType == 'SD' ) then ! write ( iostd , '(\" Reading solid defect inputs.\")' ) ! else ! write ( iostd , '(\"Unknown crystal type\", a, \".\")' ) system % crystalType write ( iostd , '(\"Please only use PC for pristine crystal or SD for solid defect.\")' ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! write ( iostd , * ) ! input = trim ( trim ( system % exportDir ) // '/input' ) !! * Set the path for the input file from the PC export directory ! inquire ( file = trim ( input ), exist = fileExists ) !! * Check if the input file from the PC export directory exists ! !> * If the input file doesn't exist !>    * Output an error message and end the program if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" File : \", a, \" , does not exist!\")' ) trim ( input ) write ( iostd , '(\" Please make sure that folder : \", a, \" has been created successfully !\")' ) trim ( system % exportDir ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! !............................................................................................... !> * Open and read the [input](../page/inputOutput/exportedInput.html) file ! open ( 50 , file = trim ( input ), status = 'old' ) ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(ES24.15E3)' ) system % omega ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % nKpts !if ( kf < 0 ) kf = system%nKpts ! read ( 50 , '(a)' ) textDum ! allocate ( system % npws ( system % nKpts ), system % wk ( system % nKpts ), system % xk ( 3 , system % nKpts ) ) ! !allocate( system%groundState(system%nKpts) ) ! Don't allocate space for groundState because it is never used ! do ik = 1 , system % nKpts ! !read(50, '(3i10,4ES24.15E3)') iDum, system%groundState(ik), system%npws(ik), system%wk(ik), system%xk(1:3,ik) ! Don't read in groundState because it is never used read ( 50 , '(3i10,4ES24.15E3)' ) iDum , iDum , system % npws ( ik ), system % wk ( ik ), system % xk ( 1 : 3 , ik ) ! enddo ! read ( 50 , '(a)' ) textDum ! read ( 50 , * ) system % numOfGvecs ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % numOfPWs ! read ( 50 , '(a)' ) textDum ! !read(50, '(6i10)') fftxMin, fftxMax, fftyMin, fftyMax, fftzMin, fftzMax ! Don't read in FFT grid because it is never used read ( 50 , * ) ! read ( 50 , '(a)' ) textDum ! !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,1) !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,2) !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,3) ! Don't read in `at` because it is never used read ( 50 , * ) read ( 50 , * ) read ( 50 , * ) ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 1 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 2 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 3 ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % nIons ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % numOfTypes ! allocate ( system % posIon ( 3 , system % nIons ), system % atomTypeIndex ( system % nIons ) ) ! read ( 50 , '(a)' ) textDum ! do ni = 1 , system % nIons ! read ( 50 , '(i10, 3ES24.15E3)' ) system % atomTypeIndex ( ni ), system % posIon ( 1 : 3 , ni ) ! enddo ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(i10)' ) system % nBands ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(i10)' ) system % nSpins ! allocate ( system % atoms ( system % numOfTypes ) ) ! system % nProjs = 0 ! do iType = 1 , system % numOfTypes ! read ( 50 , '(a)' ) textDum read ( 50 , * ) system % atoms ( iType )% symbol ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% numOfAtoms ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% numProjs ! number of projectors ! allocate ( system % atoms ( iType )% projAngMom ( system % atoms ( iType )% numProjs ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , system % atoms ( iType )% numProjs ! read ( 50 , '(2i10)' ) l , ind system % atoms ( iType )% projAngMom ( ind ) = l ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% lmMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(2i10)' ) system % atoms ( iType )% nMax , system % atoms ( iType )% iRAugMax ! allocate ( system % atoms ( iType )% r ( system % atoms ( iType )% nMax ), system % atoms ( iType )% rab ( system % atoms ( iType )% nMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , system % atoms ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) system % atoms ( iType )% r ( i ), system % atoms ( iType )% rab ( i ) ! enddo ! allocate ( system % atoms ( iType )% wae ( system % atoms ( iType )% nMax , system % atoms ( iType )% numProjs ) ) allocate ( system % atoms ( iType )% wps ( system % atoms ( iType )% nMax , system % atoms ( iType )% numProjs ) ) ! read ( 50 , '(a)' ) textDum do j = 1 , system % atoms ( iType )% numProjs do i = 1 , system % atoms ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) system % atoms ( iType )% wae ( i , j ), system % atoms ( iType )% wps ( i , j ) ! write(iostd, '(2i5, ES24.15E3)') j, i, abs(system%atoms(iType)%wae(i, j)-system%atoms(iType)%wps(i, j)) ! enddo enddo ! allocate ( system % atoms ( iType )% F ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs ) ) !, system%atoms(iType)%numProjs) ) allocate ( system % atoms ( iType )% F1 ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs , system % atoms ( iType )% numProjs ) ) allocate ( system % atoms ( iType )% F2 ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs , system % atoms ( iType )% numProjs ) ) ! system % atoms ( iType )% F = 0.0_dp system % atoms ( iType )% F1 = 0.0_dp system % atoms ( iType )% F2 = 0.0_dp ! !> * Calculate `F`, `F1`, and `F2` using the all-electron and psuedowvefunctions !> @todo Look more into how AE and PS wavefunctions are combined to further understand this @endtodo !> @todo Move this behavior to another subroutine for clarity @endtodo do j = 1 , system % atoms ( iType )% numProjs ! iRAugMax = system % atoms ( iType )% iRAugMax ! system % atoms ( iType )% F ( 1 : iRAugMax , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% r ( 1 : iRAugMax ) * system % atoms ( iType )% rab ( 1 : iRAugMax ) ! do i = 1 , system % atoms ( iType )% numProjs !> @todo Figure out if differences in PC and SD `F1` calculations are intentional @endtodo !> @todo Figure out if should be `(wae_i wae_j - wps_i wps_j)r_{ab}` @endtodo !> @todo Figure out if first term in each should be conjugated for inner product form @endtodo !> @todo Figure out if `rab` plays role of dr within augmentation sphere @endtodo if ( system % crystalType == 'PC' ) then ! system % atoms ( iType )% F1 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) ! else if ( system % crystalType == 'SD' ) then ! system % atoms ( iType )% F1 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) ! endif ! system % atoms ( iType )% F2 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) + & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) enddo enddo ! system % nProjs = system % nProjs + system % atoms ( iType )% numOfAtoms * system % atoms ( iType )% lmMax ! deallocate ( system % atoms ( iType )% wae , system % atoms ( iType )% wps ) !deallocate ( system%groundState ) ! Don't use because groundState is never used ! enddo ! !............................................................................................... ! close ( 50 ) !! * Close the input file ! !> * Go through the `projAngMom` values for each projector for each atom !> and find the max to store in `JMAX` !> @todo Figure out if intentional to only use `JMAX` from SD input @endtodo JMAX = 0 do iType = 1 , system % numOfTypes ! do i = 1 , system % atoms ( iType )% numProjs ! if ( system % atoms ( iType )% projAngMom ( i ) > JMAX ) JMAX = system % atoms ( iType )% projAngMom ( i ) ! enddo ! enddo ! maxL = JMAX JMAX = 2 * JMAX + 1 ! do iType = 1 , system % numOfTypes ! allocate ( system % atoms ( iType )% bes_J_qr ( 0 : JMAX , system % atoms ( iType )% iRAugMax ) ) system % atoms ( iType )% bes_J_qr (:,:) = 0.0_dp ! enddo ! !> * End the local timer and write out the total time to read the inputs !> to the output file call cpu_time ( t2 ) write ( iostd , '(\" Reading input files done in:                \", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) flush ( iostd ) ! return ! end subroutine readQEExport ! ! subroutine readPWsSet () !! Read the g vectors in Miller indices from `mgrid` file and convert !! using reciprocal lattice vectors !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer :: ig , iDum , iGx , iGy , iGz ! open ( 72 , file = trim ( solidDefect % exportDir ) // \"/mgrid\" ) !! * Open the `mgrid` file from Export directory from [[pw_export_for_tme(program)]] ! !> * Ignore the first two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( gvecs ( 3 , solidDefect % numOfGvecs ) ) !! * Allocate space for the g vectors ! gvecs (:,:) = 0.0_dp !! * Initialize all of the g vectors to zero ! do ig = 1 , solidDefect % numOfGvecs !! * For each g vector !!    * Read in the g vector in terms of Miller indices !!    * Calculate the g vector using the reciprocal lattice vectors from input file read ( 72 , '(4i10)' ) iDum , iGx , iGy , iGz gvecs ( 1 , ig ) = dble ( iGx ) * solidDefect % bg ( 1 , 1 ) + dble ( iGy ) * solidDefect % bg ( 1 , 2 ) + dble ( iGz ) * solidDefect % bg ( 1 , 3 ) gvecs ( 2 , ig ) = dble ( iGx ) * solidDefect % bg ( 2 , 1 ) + dble ( iGy ) * solidDefect % bg ( 2 , 2 ) + dble ( iGz ) * solidDefect % bg ( 2 , 3 ) gvecs ( 3 , ig ) = dble ( iGx ) * solidDefect % bg ( 3 , 1 ) + dble ( iGy ) * solidDefect % bg ( 3 , 2 ) + dble ( iGz ) * solidDefect % bg ( 3 , 3 ) enddo ! close ( 72 ) !! Close the `mgrid` file ! return ! end subroutine readPWsSet ! ! subroutine distributePWsToProcs ( nOfPWs , nOfBlocks ) !! Determine how many g vectors each process should get !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: nOfPWs !! Number of g vectors integer , intent ( in ) :: nOfBlocks !! Number of processes integer :: iStep !! Number of g vectors per number of processes integer :: iModu !! Number of remaining g vectors after giving !! each process the same number of g vectors ! iStep = int ( nOfPWs / nOfBlocks ) !! * Determine the base number of g vectors to give !!   to each process iModu = mod ( nOfPWs , nOfBlocks ) !! * Determine the number of g vectors left over after that ! do i = 0 , nOfBlocks - 1 !! * For each process, give the base amount and an extra !!   if there were any still left over counts ( i ) = iStep ! if ( iModu > 0 ) then ! counts ( i ) = counts ( i ) + 1 ! iModu = iModu - 1 ! endif ! enddo ! !displmnt(0) = 0 !do i = 1, nOfBlocks-1 !  displmnt(i) = displmnt(i-1) + counts(i) !enddo ! return ! end subroutine distributePWsToProcs ! ! subroutine checkIfCalculated ( ik , tmes_file_exists ) !! Determine if the output file for a given k point already exists !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index logical , intent ( out ) :: tmes_file_exists !! Whether or not the output file exists ! character ( len = 300 ) :: Uelements !! Output file name character ( len = 300 ) :: intString !! String version of integer input `ik` ! call int2str ( ik , intString ) write ( Uelements , '(\"/TMEs_kptI_\",a,\"_kptF_\",a)' ) trim ( intString ), trim ( intString ) !! * Determine what the file name should be based on the k point index ! inquire ( file = trim ( elementsPath ) // trim ( Uelements ), exist = tmes_file_exists ) !! * Check if that file already exists ! return ! end subroutine checkIfCalculated ! ! subroutine calculatePWsOverlap ( ik ) !! @todo Document `calculatePWsOverlap()` @endtodo !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ibi , ibf !! Loop index ! call readWfc ( ik , perfectCrystal ) !! * Read the perfect crystal wavefunction ([[TMEModule(module):readWfc(subroutine)]]) ! call readWfc ( ik , solidDefect ) !! * Read the solid defect wavefunction ([[TMEModule(module):readWfc(subroutine)]]) ! Ufi (:,:, ik ) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize `Ufi` for the given k point to complex double zero ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal !! * For each initial band, calculate \\sum \\phi_f&#94;*\\psi_i (overlap??) with each final band !! Ufi ( ibf , ibi , ik ) = sum ( conjg ( solidDefect % wfc (:, ibf )) * perfectCrystal % wfc (:, ibi )) !! @todo Figure out what `Ufi` is supposed to be @endtodo !! @note !! `Ufi` may be representing the overlap (\\langle\\tilde{\\Psi}|\\tilde{\\Phi}\\rangle). !! But if that is the case, why is \\Phi the one that has the complex conjugate? And why !! is there no integral? !! @endnote !! !if ( ibi == ibf ) write(iostd,'(2i4,3ES24.15E3)') ibf, ibi, Ufi(ibf, ibi, ik), abs(Ufi(ibf, ibi, ik))**2 flush ( iostd ) ! enddo ! enddo ! return ! end subroutine calculatePWsOverlap ! ! subroutine readWfc ( ik , system ) !! Open the `grid.ki` file from [[pw_export_for_tme(program)]] !! to get the indices for the wavefunction to be stored in, then !! open the `wfc.ki` file and read in the wavefunction for the !! proper bands and store in the proper indices in the system's `wfc` !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ib , ig !! Loop index integer :: iDumV ( 3 ) !! Dummy vector to ignore g vectors from `grid.ki` integer , allocatable :: pwGind (:) !! Indices for the wavefunction of a given k point ! complex ( kind = dp ) :: wfc !! Wavefunction ! character ( len = 300 ) :: iks !! String version of the k point index ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , iks ) !! * Convert the k point index to a string ! open ( 72 , file = trim ( system % exportDir ) // \"/grid.\" // trim ( iks )) !! * Open the `grid.ki` file from [[pw_export_for_tme(program)]] ! !> * Ignore the first two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGind ( system % npws ( ik )) ) !! * Allocate space for `pwGind` ! do ig = 1 , system % npws ( ik ) !! * For each plane wave for a given k point, !!   read in the indices for the plane waves that !!   are held in `wfc.ki` ! read ( 72 , '(4i10)' ) pwGind ( ig ), iDumV ( 1 : 3 ) ! enddo ! close ( 72 ) !! * Close the `grid.ki` file ! open ( 72 , file = trim ( system % exportDir ) // \"/wfc.\" // trim ( iks )) !! * Open the `wfc.ki` file from [[pw_export_for_tme(program)]] ! !> Ignore the first two lines because they are comments read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandIinit - 1 do ig = 1 , system % npws ( ik ) !! * For each band before `iBandInit`, ignore all of the !!   plane waves for the given k point read ( 72 , * ) ! enddo enddo ! system % wfc (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize the wavefunction to complex double zero ! do ib = iBandIinit , iBandIfinal do ig = 1 , system % npws ( ik ) !! * For bands between `iBandIinit` and `iBandIfinal`, !!   read in all of the plane waves for the given k point !!   and store them in the proper index of the system's `wfc` ! read ( 72 , '(2ES24.15E3)' ) wfc system % wfc ( pwGind ( ig ), ib ) = wfc ! enddo enddo ! close ( 72 ) !! * Close the `wfc.ki` file ! deallocate ( pwGind ) !! * Deallocate space for `pwGind` ! return ! end subroutine readWfc ! ! subroutine readProjections ( ik , system ) !! Read in the projection \\langle\\beta|\\Psi\\rangle for each band !! !! <H2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: i , j !! Loop index ! character ( len = 300 ) :: iks !! String version of k point index TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , iks ) !! * Convert the k point index to a string ! system % cProj (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize `cProj` to all complex double zero ! open ( 72 , file = trim ( system % exportDir ) // \"/projections.\" // trim ( iks )) !! * Open the `projections.iks` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) !! * Ignore the first line as it is a comment ! !write(6,'(\"Solid defect nBands: \", i3)') solidDefect%nBands !write(6,'(\"Solid defect nSpins: \", i3)') solidDefect%nSpins !write(6,'(\"Perfect crystal nBands: \", i3)') perfectCrystal%nBands !write(6,'(\"Perfect crystal nSpins: \", i3)') perfectCrystal%nSpins !! @todo Get actual perfect crystal and solid defect output to test @endtodo !! @todo Figure out if loop should be over `solidDefect` or `perfectCrystal` @endtodo !! @todo Look into `nSpins` to figure out if it is needed @endtodo do j = 1 , solidDefect % nBands ! number of bands do i = 1 , system % nProjs ! number of projections !! * For each band, read in the projections \\langle\\beta|\\Psi\\rangle ! read ( 72 , '(2ES24.15E3)' ) system % cProj ( i , j , 1 ) ! enddo enddo ! close ( 72 ) ! return ! end subroutine readProjections ! ! subroutine projectBeta ( ik , betaSystem , projectedSystem ) !! @todo Figure out what this subroutine really does !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ig , i , j !! Loop index integer :: iDumV ( 3 ), iDum !! Dummy variable to ignore input from file integer , allocatable :: pwGind (:) !! Indices for the wavefunction of a given k point ! character ( len = 300 ) :: iks !! String version of the k point index ! TYPE ( crystal ), intent ( inout ) :: betaSystem !! Holds the structure for the system you are getting \\beta from !! (either `perfectCrystal` or `solidDefect`) TYPE ( crystal ), intent ( inout ) :: projectedSystem !! Holds the structure for the system you are projecting !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , iks ) !! * Convert the k point index to a string ! ! Reading PC projectors ! open ( 72 , file = trim ( betaSystem % exportDir ) // \"/grid.\" // trim ( iks )) !! * Open the `grid.ki` file from [[pw_export_for_tme(program)]] ! !> * Ignore the next two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGind ( betaSystem % npws ( ik )) ) !! * Allocate space for `pwGind` ! do ig = 1 , betaSystem % npws ( ik ) !! * Read in the index for each plane wave ! read ( 72 , '(4i10)' ) pwGind ( ig ), iDumV ( 1 : 3 ) ! enddo ! close ( 72 ) !! * Close the `grid.ki` file ! ! allocate ( betaSystem % beta ( numOfPWs , betaSystem % nProjs ) ) !! * Allocate space for |\\beta\\rangle ! betaSystem % beta (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values of |\\beta\\rangle to complex double zero ! open ( 73 , file = trim ( betaSystem % exportDir ) // \"/projectors.\" // trim ( iks )) !! * Open the `projectors.ki` file from [[pw_export_for_tme(program)]] ! read ( 73 , * ) !! * Ignore the first line because it is a comment read ( 73 , * ) !! * Ignore the second line because it is the number of projectors that !!   was already calculated in [[TMEModule(module):readQEExport(subroutine)]] !!   and the number of plane waves for a given k point that was read in in the !!   same subroutine ! do j = 1 , betaSystem % nProjs do i = 1 , betaSystem % npws ( ik ) !! * Read in each |\\beta\\rangle and store in the proper index of `beta` !!   for the system ! read ( 73 , '(2ES24.15E3)' ) betaSystem % beta ( pwGind ( i ), j ) ! enddo enddo ! close ( 73 ) ! deallocate ( pwGind ) !! * Deallocate space for `pwGind` ! if ( betaSystem % crystalType == \"PC\" ) then !! * If the system that you are getting |\\beta\\rangle from !!   is the perfect crystal, then calculate !!   \\langle\\beta|\\Phi\\rangle between `iBandFinit` !!   and `iBandFfinal` ! do j = iBandFinit , iBandFfinal do i = 1 , betaSystem % nProjs ! betaSystem % cCrossProj ( i , j , 1 ) = sum ( conjg ( betaSystem % beta (:, i )) * projectedSystem % wfc (:, j )) ! enddo enddo ! else if ( betaSystem % crystalType == \"SD\" ) then !! * If the system that you are getting |\\beta\\rangle from !!   is the solid defect, then calculate !!   \\langle\\beta|\\Psi\\rangle between `iBandIinit` !!   and `iBandIfinal` ! do j = iBandIinit , iBandIfinal do i = 1 , betaSystem % nProjs betaSystem % cCrossProj ( i , j , 1 ) = sum ( conjg ( betaSystem % beta (:, i )) * projectedSystem % wfc (:, j )) enddo enddo ! endif ! deallocate ( betaSystem % beta ) !! * Deallocate space for |\\beta\\rangle ! return ! end subroutine projectBeta ! ! subroutine pawCorrectionWfc ( system ) !! Calculates the augmentation part of the transition matrix element !! @todo Figure out what this subroutine really does @endtodo !! !! <h2>Walkthrough</h2> !! implicit none integer :: iIon !! Loop index over atoms integer :: iProj , jProj !! Loop index of projectors integer :: ibi , ibf !! Loop index over bands integer :: m , mPrime !! Loop index for magnetic quantum number for a given projector integer :: ispin integer :: LMBASE integer :: LM , LMP !! Index for cProj integer :: l , lPrime !! Angular momentum quantum number for a given projector integer :: iAtomType !! Atom type index for a given ion in the system ! real ( kind = dp ) :: atomicOverlap ! complex ( kind = dp ) :: cProjIe , cProjFe ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! ispin = 1 !! * Set the value of `ispin` to 1 !! @note !! `ispin` never has a value other than one, so I'm not sure !!  what its purpose is !! @endnote ! system % paw_Wfc (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values in `paw_Wfc` to complex double zero ! LMBASE = 0 !! * Initialize the base offset for `cProj`'s first index to zero ! do iIon = 1 , system % nIons !! * For each atom in the system !!    * Get the index for the atom type !!    * Loop over the projectors twice, each time finding the !!      angular momentum quantum number (l and l&#94;{\\prime}) !!      and magnetic quantum number (m and m&#94;{\\prime}) !!    * If l = l&#94;{\\prime} and m = m&#94;{\\prime}, loop over the bands to !!      calculate `paw_Wfc` !! !! @todo Figure out the significance of l = l&#94;{\\prime} and m = m&#94;{\\prime} @endtodo ! iAtomType = system % atomTypeIndex ( iIon ) ! LM = 0 ! do iProj = 1 , system % atoms ( iAtomType )% numProjs ! l = system % atoms ( iAtomType )% projAngMom ( iProj ) ! do m = - l , l ! LM = LM + 1 !1st index for CPROJ ! LMP = 0 ! do jProj = 1 , system % atoms ( iAtomType )% numProjs ! lPrime = system % atoms ( iAtomType )% projAngMom ( jProj ) ! do mPrime = - lPrime , lPrime ! LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp ! if ( ( l == lPrime ). and .( m == mPrime ) ) then ! atomicOverlap = sum ( system % atoms ( iAtomType )% F1 (:, iProj , jProj )) ! do ibi = iBandIinit , iBandIfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! cProjIe = system % cProj ( LMP + LMBASE , ibi , ISPIN ) ! else if ( system % crystalType == 'SD' ) then ! cProjIe = system % cCrossProj ( LMP + LMBASE , ibi , ISPIN ) ! endif ! do ibf = iBandFinit , iBandFfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! cProjFe = conjg ( system % cCrossProj ( LM + LMBASE , ibf , ISPIN )) ! else if ( system % crystalType == 'SD' ) then ! cProjFe = conjg ( system % cProj ( LM + LMBASE , ibf , ISPIN )) ! endif ! system % paw_Wfc ( ibf , ibi ) = system % paw_Wfc ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe ! enddo ! enddo ! endif ! enddo ! enddo ! enddo ! enddo ! LMBASE = LMBASE + system % atoms ( iAtomType )% lmMax ! enddo ! return ! end subroutine pawCorrectionWfc ! ! subroutine pawCorrectionK ( system ) !! @todo Figure out what this subroutine really does @endtodo !! !! <h2>Walkthrough</h2> ! implicit none ! !integer, intent(in) :: ik ! integer :: ibi , ibf !! Loop index over bands integer :: iPW !! Loop index over plane waves for a given process integer :: iProj !! Loop index over projectors integer :: iR !! Loop index over radial mesh (up to augmentation sphere) integer :: iAtomType !! Loop index over atom types integer :: iIon !! Loop index over ions in system integer :: l !! Angular momentum quantum number integer :: m !! Magnetic quantum number integer :: ispin integer :: LMBASE integer :: LM integer :: ind ! real ( kind = dp ) :: qDotR !! \\mathbf{G}\\cdot\\mathbf{r} real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time real ( kind = dp ) :: v_in ( 3 ) !! Unit vector in the direction of \\mathbf{G} real ( kind = dp ) :: JL ( 0 : JMAX ) !! Spherical bessel functions for a point up to `JMAX` real ( kind = dp ) :: q real ( kind = dp ) :: FI ! complex ( kind = dp ) :: Y ( ( JMAX + 1 ) ** 2 ) !! All spherical harmonics up to some max momentum complex ( kind = dp ) :: ATOMIC_CENTER !! e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} complex ( kind = dp ) :: VifQ_aug ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! ispin = 1 !! * Set the value of `ispin` to 1 !! @note !! `ispin` never has a value other than one, so I'm not sure !!  what its purpose is !! @endnote ! call cpu_time ( t1 ) !! * Start a timer ! system % pawK (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values in `pawK` to complex double zero ! do iPW = nPWsI ( myid ), nPWsF ( myid ) !! * Loop through the plane waves for a given process ! if ( myid == root ) then if ( ( iPW == nPWsI ( myid ) + 1000 ) . or . ( mod ( iPW , 25000 ) == 0 ) . or . ( iPW == nPWsF ( myid )) ) then !! * If this is the root process, output a status update every 1000 plane waves !!   and every multiple of 25000, giving an estimate of the time remaining at each step !!   @todo Figure out if this output slows things down significantly @endtodo !!   @todo Figure out if formula gives accurate representation of time left @endtodo ! call cpu_time ( t2 ) ! write ( iostd , '(\"        Done \", i10, \" of\", i10, \" k-vecs. ETR : \", f10.2, \" secs.\")' ) & iPW , nPWsF ( myid ) - nPWsI ( myid ) + 1 , ( t2 - t1 ) * ( nPWsF ( myid ) - nPWsI ( myid ) + 1 - iPW ) / iPW ! flush ( iostd ) ! !call cpu_time(t1) ! endif endif ! q = sqrt ( sum ( gvecs (:, iPW ) * gvecs (:, iPW ))) !! * Calculate `q` as \\sqrt{\\mathbf{G}\\cdot\\mathbf{G}} !!   to get length of \\mathbf{G} ! !> * Define a unit vector in the direction of \\mathbf{G}, !>   but only divide by the length if it is bigger than !>   1\\times10&#94;{-6} to avoid dividing by very small numbers v_in (:) = gvecs (:, iPW ) if ( abs ( q ) > 1.0e-6_dp ) v_in = v_in / q ! Y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize the spherical harmonics to complex double zero call ylm ( v_in , JMAX , Y ) !! * Calculate spherical harmonics with argument `v_in` up to !!   Y_{J_{\\text{max}}}&#94;{\\pm J_{\\text{max}}} ! LMBASE = 0 !! * Initialize the base offset for `cProj`'s first index to zero ! do iAtomType = 1 , system % numOfTypes ! do iR = 1 , system % atoms ( iAtomType )% iRAugMax !! * For each atom type, loop through the r points !!   in the augmentation sphere and calculate the !!   spherical Bessel functions from 0 to `JMAX` !!   at each point ! JL = 0.0_dp ! call bessel_j ( q * solidDefect % atoms ( iAtomType )% r ( iR ), JMAX , JL ) ! returns the spherical bessel at qr point !! @todo Figure out if this should be `system` @endtodo !! @todo Figure out significance of \"qr\" point @endtodo ! system % atoms ( iAtomType )% bes_J_qr (:, iR ) = JL (:) !! @todo Test if can just directly store in each atom type's `bes_J_qr` @endtodo ! enddo ! enddo ! do iIon = 1 , system % nIons !! * For each atom in the system !!    * Calculate \\mathbf{G}\\cdot\\mathbf{r} !!    * Calculate e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} !!    * Get the index for the atom type !!    * Loop over the projectors, finding l, m for each !!    * For each possible m !!       * Calculate \\text{FI} = j_l\\cdot F where j_l is !!         the Bessel function and F is for a given projector !!       * Calculate \\text{VifQ_aug} = e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} !!         Y_l&#94;m(\\mathbf{G}/|\\mathbf{G}|)(-i)&#94;l\\text{FI} !!       * Loop over the bands, summing `VifQ_aug*cProj` to get `pawK` ! qDotR = sum ( gvecs (:, iPW ) * system % posIon (:, iIon )) !! @todo Figure out if this should be `gDotR` @endtodo ! !> @todo Figure out why this is called `ATOMIC_CENTER` @endtodo !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! ATOMIC_CENTER = exp ( - ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! else if ( system % crystalType == 'SD' ) then ! ATOMIC_CENTER = exp ( ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! endif ! iAtomType = system % atomTypeIndex ( iIon ) ! LM = 0 ! do iProj = 1 , system % atoms ( iAtomType )% numProjs ! l = system % atoms ( iAtomType )% projAngMom ( iProj ) ! do m = - l , l ! LM = LM + 1 !1st index for CPROJ ! FI = 0.0_dp ! FI = sum ( system % atoms ( iAtomType )% bes_J_qr ( l ,:) * system % atoms ( iAtomType )% F (:, iProj )) ! radial part integration F contains rab ! ind = l * ( l + 1 ) + m + 1 ! index for spherical harmonics ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! VifQ_aug = ATOMIC_CENTER * Y ( ind ) * ( - II ) ** l * FI ! else if ( system % crystalType == 'SD' ) then ! VifQ_aug = ATOMIC_CENTER * conjg ( Y ( ind )) * ( II ) ** l * FI ! endif ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! system % pawK ( ibf , ibi , iPW ) = system % pawK ( ibf , ibi , iPW ) + & VifQ_aug * system % cProj ( LM + LMBASE , ibi , ISPIN ) ! else if ( system % crystalType == 'SD' ) then ! system % pawK ( ibf , ibi , iPW ) = system % pawK ( ibf , ibi , iPW ) + & VifQ_aug * conjg ( system % cProj ( LM + LMBASE , ibi , ISPIN )) ! endif ! enddo ! enddo ! ENDDO ENDDO LMBASE = LMBASE + system % atoms ( iAtomType )% lmMax ENDDO ! enddo ! !system%pawK(:,:,:) = system%pawK(:,:,:)*4.0_dp*pi/sqrt(solidDefect%omega) ! return ! end subroutine pawCorrectionK ! ! subroutine ylm ( v_in , lmax , y ) !! Returns the [spherical harmonics](http://mathworld.wolfram.com/SphericalHarmonic.html) !! for a given argument vector up to the maximum value of l given !! !! <h2>Description</h2> !!   <h3>Purpose</h3> !!        The spherical harmonics (Condon and Shortley convention) !!          Y_0&#94;0,Y_1&#94;{-1},Y_1&#94;0,Y_1&#94;1,Y_2&#94;{-2} ... Y_{l_{\\text{max}}}&#94;{\\pm l_{\\text{max}}} !!        for vector \\mathbf{V} (given in Cartesian coordinates) !!        are calculated. In the Condon Shortley convention the !!        spherical harmonics are defined as !!         Y_l&#94;m = (-1)&#94;m \\sqrt{\\frac{1}{\\pi}} P_l&#94;m(\\cos{\\theta}) !!        e&#94;{im\\phi}  !!        where  P_l&#94;m(\\cos{\\theta}) is the normalized Associated !!        Legendre function. Thus, !!                       Y_l&#94;{-m} = (-1)&#94;m (Y_l&#94;m)&#94;*  !! !!   <h3>Usage</h3> !! !! !!        DOUBLE PRECISION V(3), Y(5*5) !!        V(1) = ... !!        V(2) = ... !!        V(3) = ... !!        CALL YLM(V,4,Y) !! !!   <h3>Argument Description</h3> !!     <ul> !!          <li> !!                  `V`      - `DOUBLE PRECISION` vector, dimension 3        (input)<br/> !!                   Must be given in Cartesian coordinates. !!                   Conversion of V to polar coordinates gives the !!                   angles \\theta and \\phi necessary for the calculation !!                   of the spherical harmonics. !!          </li> !!          <li> !!                   `LMAX`   - `INTEGER` value                               (input)<br/> !!                   upper bound of l for which spherical harmonics !!                   will be calculated<br/> !!                   constraint: `LMAX >= 0` !!          </li> !!          <li> !!                   `Y`      - `COMPLEX*16` array, dimension `(LMAX+1)**2`    (output)<br/> !!                   contains the calculated spherical harmonics<br/> !!                   `Y(1)` for l=0 (m = 0)<br/> !!                   `Y(2), ..., Y(4)` for l = 1 (m = -1, 0, 1)<br/> !!                   ...<br/> !!                   `Y(LMAX*LMAX+1), ..., Y((LMAX+1)*(LMAX+1))` for l = l_{\\text{max}} !!                            (m = -l,...,l)<br/> !!                   constraint: Dimension of `Y` \\geq (l_{\\text{max}} + 1)&#94;2 (not checked) !!          </li> !!        </ul> !! !!   <h3>Used Subroutines (Directly Called)</h3> !!           none !! !!   <h3>Indirectly Called Subroutines</h3> !!           none !! !!   <h3>Input/Output (Read/Write)</h3> !!           none !! !!   <h3>Machine Dependent Program Parts</h3> !!           Type `COMPLEX*16` is used which does not conform to the !!           FORTRAN 77 standard. !!           Also the non-standard type conversion function `DCMPLX()` !!           is used which combines two double precision values into !!           one double complex value. !! !!   <h3>Method</h3> !!           The basic algorithm used to calculate the spherical !!           harmonics for vector \\mathbf{V} is as follows: !! !! !!           Y(0,0) !!           Y(1,0) !!           Y(1,1) !!           Y(1,-1) = -Y(1,1) !!           DO L = 2, LMAX !!              Y(L,L)   = f(Y(L-1,L-1)) ... Formula 1 !!              Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 !!              DO M = L-2, 0, -1 !!                 Y(L,M) = f(Y(L-1,M),Y(L-2,M)) ... Formula 2 !!                 Y(L,-M)= (-1)**M*CONJG(Y(L,M)) !!              ENDDO !!           ENDDO !! !!   <h3>Formulas</h3> !!        Starting values: !!          Y_0&#94;0 = \\sqrt{\\dfrac{1}{4\\pi}} !!          Y_1&#94;0 = \\sqrt{\\dfrac{3}{4\\pi}}\\cos\\theta !!          Y_1&#94;1 = -\\sqrt{\\dfrac{3}{8\\pi}}\\sin\\theta e&#94;{i\\phi} !!        Formula 1: !!          Y_l&#94;l = -\\sqrt{\\dfrac{2l+1}{2l}}\\sin\\theta e&#94;{i\\phi}Y_{l-1}&#94;{l-1} !!        Formula 2: !!          Y_l&#94;m = \\sqrt{\\dfrac{(2l-1)(2l+1)}{(l-m)(l+m)}}\\cos\\theta Y_{l-1}&#94;m - !!                    \\sqrt{\\dfrac{(l-1+m)(l-1-m)(2l+1)}{(2l-3)(l-m)(l+m)}} Y_{l-2}&#94;m !!        Formula 3: (not used in the algorithm because of the division !!                    by \\sin\\theta which may be zero) !!          Y_l&#94;m = -\\sqrt{\\dfrac{4(m+1)(m+1)}{(l+m+1)(l-m)}}\\dfrac{\\cos\\theta}{\\sin\\theta}e&#94;{i\\phi}Y_1&#94;{m+1} - !!                    \\sqrt{\\dfrac{(l-m-1)(l+m+2)}{(l-m)(l+m+1)}}e&#94;{-2i\\phi}Y_l&#94;{m+2} !! ! !REVISION HISTORY: !   26. April 1994                                   Version 1.2 !   Taken 8 1 98 from SRC_lapw2 to SRC_telnes !   Updated November 2004 (Kevin Jorissen) !   cosmetics March 2005 (Kevin Jorissen) ! implicit none ! !   In/Output : ! integer , intent ( in ) :: LMAX !! Spherical harmonics are calculated for !! l = 0, 1, ..., l_{\\text{max}} real ( kind = dp ), intent ( in ) :: V_in ( 3 ) !! Vector, argument of the spherical harmonics (we calculate !! Y_l&#94;m(\\mathbf{v}/|\\mathbf{v}|)) complex ( kind = dp ), intent ( out ) :: Y ( * ) !! Array containing Y_l&#94;m(\\mathbf{v}) for several l,m ! !   Local variables : real ( kind = dp ), parameter :: pi = 3.1415926535897932384626433_dp ! INTEGER :: I2L , I4L2 , INDEX , INDEX2 , L , M , MSIGN real ( kind = dp ) :: A , B , C , AB , ABC , ABMAX , ABCMAX , V ( 3 ) real ( kind = dp ) :: D4LL1C , D2L13 real ( kind = dp ) :: COSTH , SINTH , COSPH , SINPH real ( kind = dp ) :: TEMP1 , TEMP2 , TEMP3 real ( kind = dp ) :: YLLR , YLL1R , YL1L1R , YLMR real ( kind = dp ) :: YLLI , YLL1I , YL1L1I , YLMI ! ! Y(0,0) ! do INDEX = 1 , 3 V ( INDEX ) = dble ( V_in ( INDEX )) enddo YLLR = 1.0_dp / sqrt ( 4.0_dp * PI ) YLLI = 0.0_dp Y ( 1 ) = CMPLX ( YLLR , YLLI , kind = dp ) ! ! continue only if spherical harmonics for (L .GT. 0) are desired ! IF ( LMAX . LE . 0 ) GOTO 999 ! ! calculate sin(Phi), cos(Phi), sin(Theta), cos(Theta) ! Theta, Phi ... polar angles of vector V ! ABMAX = MAX ( ABS ( V ( 1 )), ABS ( V ( 2 ))) IF ( ABMAX . GT . 0.0_dp ) THEN A = V ( 1 ) / ABMAX B = V ( 2 ) / ABMAX AB = SQRT ( A * A + B * B ) COSPH = A / AB SINPH = B / AB ELSE COSPH = 1.0_dp SINPH = 0.0_dp ENDIF ABCMAX = MAX ( ABMAX , ABS ( V ( 3 ))) IF ( ABCMAX . GT . dble ( 0 )) THEN A = V ( 1 ) / ABCMAX B = V ( 2 ) / ABCMAX C = V ( 3 ) / ABCMAX AB = A * A + B * B ABC = SQRT ( AB + C * C ) COSTH = C / ABC SINTH = SQRT ( AB ) / ABC ELSE COSTH = 1.0_dp SINTH = 0.0_dp ENDIF ! ! Y(1,0) ! Y ( 3 ) = CMPLX ( sqrt ( 3.0_dp ) * YLLR * COSTH , 0.0_dp , kind = dp ) ! ! Y(1,1) ( = -DCONJG(Y(1,-1))) ! TEMP1 = - SQRT ( 1.5_dp ) * YLLR * SINTH Y ( 4 ) = CMPLX ( TEMP1 * COSPH , TEMP1 * SINPH , kind = dp ) Y ( 2 ) = - CONJG ( Y ( 4 )) ! DO L = 2 , LMAX INDEX = L * L + 1 INDEX2 = INDEX + 2 * L MSIGN = 1 - 2 * MOD ( L , 2 ) ! ! YLL = Y(L,L) = f(Y(L-1,L-1)) ... Formula 1 ! YL1L1R = DBLE ( Y ( INDEX - 1 )) YL1L1I = DIMAG ( Y ( INDEX - 1 )) TEMP1 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L )) * SINTH YLLR = TEMP1 * ( COSPH * YL1L1R - SINPH * YL1L1I ) YLLI = TEMP1 * ( COSPH * YL1L1I + SINPH * YL1L1R ) Y ( INDEX2 ) = CMPLX ( YLLR , YLLI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! ! YLL1 = Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 ! (the coefficient for Y(L-2,L-1) in Formula 2 is zero) ! TEMP2 = SQRT ( DBLE ( 2 * L + 1 )) * COSTH YLL1R = TEMP2 * YL1L1R YLL1I = TEMP2 * YL1L1I Y ( INDEX2 ) = CMPLX ( YLL1R , YLL1I , kind = dp ) Y ( INDEX ) = - cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = -dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! I4L2 = INDEX2 - 4 * L + 2 I2L = INDEX2 - 2 * L D4LL1C = COSTH * SQRT ( DBLE ( 4 * L * L - 1 )) D2L13 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L - 3 )) ! DO M = L - 2 , 0 , - 1 ! ! YLM = Y(L,M) = f(Y(L-2,M),Y(L-1,M)) ... Formula 2 ! TEMP1 = 1.0_dp / SQRT ( DBLE (( L + M ) * ( L - M ))) TEMP2 = D4LL1C * TEMP1 TEMP3 = D2L13 * SQRT ( DBLE (( L + M - 1 ) * ( L - M - 1 ))) * TEMP1 YLMR = TEMP2 * DBLE ( Y ( I2L )) + TEMP3 * DBLE ( Y ( I4L2 )) YLMI = TEMP2 * DIMAG ( Y ( I2L )) + TEMP3 * DIMAG ( Y ( I4L2 )) Y ( INDEX2 ) = CMPLX ( YLMR , YLMI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) ! MSIGN = - MSIGN INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 I4L2 = I4L2 - 1 I2L = I2L - 1 ENDDO ENDDO ! 999 RETURN END subroutine ylm ! ! subroutine bessel_j ( x , lmax , jl ) !! Generates the !! [spherical bessel function of the first kind](http://mathworld.wolfram.com/SphericalBesselFunctionoftheFirstKind.html) !! for the given argument x and all possible indices from 0 to `lmax` !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: lmax integer :: l ! real ( kind = dp ), intent ( in ) :: x real ( kind = dp ), intent ( out ) :: jl ( 0 : lmax ) ! if ( x <= 0.0_dp ) then !! * If x is less than zero, return 0 for all !!   indices but 0 which is 1 ! jl = 0.0_dp jl ( 0 ) = 1.0_dp ! return ! end if ! !> * Explicitly calculate the first 2 functions so can use !>   recursive definition for later terms jl ( 0 ) = sin ( x ) / x if ( lmax <= 0 ) return jl ( 1 ) = ( jl ( 0 ) - cos ( x )) / x if ( lmax == 1 ) return ! do l = 2 , lmax !! * Define the rest of the functions as !!   j_l = (2l-1)j_{l-1}/x - j_{l-2} ! jl ( l ) = dble ( 2 * l - 1 ) * jl ( l - 1 ) / x - jl ( l - 2 ) ! enddo ! return ! end subroutine bessel_j ! ! subroutine writeResults ( ik ) !! @todo Document `writeResults()` @endto !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index ! integer :: ibi , ibf !! Loop index over bands integer :: totalNumberOfElements real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time ! character ( len = 300 ) :: text character ( len = 300 ) :: Uelements ! call cpu_time ( t1 ) !! * Start a timer ! call readEigenvalues ( ik ) ! write ( iostd , '(\" Writing Ufi(:,:).\")' ) ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) ! write ( 17 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(a51, ES24.15E3)'' \", ES24.15E3)' ) solidDefect % omega ! text = \"# Total number of <f|U|i> elements, Initial States (bandI, bandF), Final States (bandI, bandF)\" write ( 17 , '(a, \" Format : ''(5i10)''\")' ) trim ( text ) ! totalNumberOfElements = ( iBandIfinal - iBandIinit + 1 ) * ( iBandFfinal - iBandFinit + 1 ) write ( 17 , '(5i10)' ) totalNumberOfElements , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! write ( 17 , '(\"# Final Band, Initial Band, Delta energy, Complex <f|U|i>, |<f|U|i>|&#94;2 Format : ''(2i10,4ES24.15E3)''\")' ) ! do ibf = iBandFinit , iBandFfinal do ibi = iBandIinit , iBandIfinal ! write ( 17 , 1001 ) ibf , ibi , eigvI ( ibi ) - eigvF ( ibf ), Ufi ( ibf , ibi , ik ), abs ( Ufi ( ibf , ibi , ik )) ** 2 ! enddo enddo ! close ( 17 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Writing Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! return ! end subroutine writeResults ! ! subroutine readUfis ( ik ) !! @todo Document `readUfis()` @endtodo ! implicit none ! integer , intent ( in ) :: ik ! integer :: ibi , ibf , totalNumberOfElements , iDum , i real ( kind = dp ) :: rDum , t1 , t2 complex ( kind = dp ) :: cUfi ! character ( len = 300 ) :: Uelements ! call cpu_time ( t1 ) write ( iostd , '(\" Reading Ufi(:,:) of k-point: \", i4)' ) ik ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) ! read ( 17 , * ) read ( 17 , * ) read ( 17 , '(5i10)' ) totalNumberOfElements , iDum , iDum , iDum , iDum read ( 17 , * ) ! do i = 1 , totalNumberOfElements ! read ( 17 , 1001 ) ibf , ibi , rDum , cUfi , rDum Ufi ( ibf , ibi , ik ) = cUfi ! enddo ! close ( 17 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Reading Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! return ! end subroutine readUfis ! ! subroutine calculateVfiElements () !! @todo Document `calculateVFiElements()` @endtodo ! implicit none ! integer :: ik , ib , nOfEnergies , iE ! real ( kind = dp ) :: eMin , eMax , E , av , sd , x , EiMinusEf , A , DHifMin ! real ( kind = dp ), allocatable :: sumWk (:), sAbsVfiOfE2 (:), absVfiOfE2 (:) integer , allocatable :: nKsInEbin (:) ! character ( len = 300 ) :: text ! allocate ( DE ( iBandIinit : iBandIfinal , perfectCrystal % nKpts ), absVfi2 ( iBandIinit : iBandIfinal , perfectCrystal % nKpts ) ) ! DE (:,:) = 0.0_dp absVfi2 (:,:) = 0.0_dp ! do ik = 1 , perfectCrystal % nKpts ! eigvI (:) = 0.0_dp eigvF (:) = 0.0_dp ! call readEigenvalues ( ik ) ! do ib = iBandIinit , iBandIfinal ! EiMinusEf = eigvI ( ib ) - eigvF ( iBandFinit ) absVfi2 ( ib , ik ) = EiMinusEf ** 2 * ( abs ( Ufi ( iBandFinit , ib , ik )) ** 2 - abs ( Ufi ( iBandFinit , ib , ik )) ** 4 ) ! DE ( ib , ik ) = sqrt ( EiMinusEf ** 2 - 4.0_dp * absVfi2 ( ib , ik )) ! enddo ! enddo ! eMin = minval ( DE (:,:) ) eMax = maxval ( DE (:,:) ) ! nOfEnergies = int (( eMax - eMin ) / eBin ) + 1 ! allocate ( absVfiOfE2 ( 0 : nOfEnergies ), nKsInEbin ( 0 : nOfEnergies ), sumWk ( 0 : nOfEnergies ) ) ! absVfiOfE2 (:) = 0.0_dp nKsInEbin (:) = 0 sumWk (:) = 0.0_dp ! do ik = 1 , perfectCrystal % nKpts ! do ib = iBandIinit , iBandIfinal ! if ( abs ( eMin - DE ( ib , ik )) < 1.0e-3_dp ) DHifMin = absVfi2 ( ib , ik ) iE = int (( DE ( ib , ik ) - eMin ) / eBin ) if ( absVfi2 ( ib , ik ) > 0.0_dp ) then absVfiOfE2 ( iE ) = absVfiOfE2 ( iE ) + perfectCrystal % wk ( ik ) * absVfi2 ( ib , ik ) sumWk ( iE ) = sumWk ( iE ) + perfectCrystal % wk ( ik ) nKsInEbin ( iE ) = nKsInEbin ( iE ) + 1 else write ( iostd , * ) 'lalala' , absVfi2 ( ib , ik ) endif ! enddo ! enddo ! allocate ( sAbsVfiOfE2 ( 0 : nOfEnergies ) ) ! sAbsVfiOfE2 = 0.0_dp ! open ( 11 , file = trim ( VfisOutput ) // 'ofKpt' , status = 'unknown' ) ! write ( 11 , '(\"# |<f|V|i>|&#94;2 versus energy for all the k-points.\")' ) write ( text , '(\"# Energy (eV) shifted by half eBin, |<f|V|i>|&#94;2 (Hartree)&#94;2,\")' ) write ( 11 , '(a, \" k-point index. Format : ''(2ES24.15E3,i10)''\")' ) trim ( text ) ! do ik = 1 , perfectCrystal % nKpts ! do ib = iBandIinit , iBandIfinal ! iE = int (( DE ( ib , ik ) - eMin ) / eBin ) av = absVfiOfE2 ( iE ) / sumWk ( iE ) x = absVfi2 ( ib , ik ) write ( 11 , '(2ES24.15E3,i10)' ) ( eMin + ( iE + 0.5_dp ) * eBin ) * HartreeToEv , x , ik write ( 12 , '(2ES24.15E3,i10)' ) DE ( ib , ik ) * HartreeToEv , absVfi2 ( ib , ik ), ik !write(11, '(2ES24.15E3,i10)') (eMin + iE*eBin + eBin/2.0_dp), x, ik sAbsVfiOfE2 ( iE ) = sAbsVfiOfE2 ( iE ) + perfectCrystal % wk ( ik ) * ( x - av ) ** 2 / sumWk ( iE ) ! enddo ! enddo ! close ( 11 ) ! open ( 63 , file = trim ( VfisOutput ), status = 'unknown' ) ! write ( 63 , '(\"# Averaged |<f|V|i>|&#94;2 over K-points versus energy.\")' ) write ( 63 , '(\"#                 Cell volume : \", ES24.15E3, \" (a.u.)&#94;3,   Format : ''(ES24.15E3)''\")' ) solidDefect % omega write ( 63 , '(\"#   Minimun transition energy : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eMin write ( 63 , '(\"# |DHif|&#94;2 at minimum Tr. En. : \", ES24.15E3, \" (Hartree&#94;2),Format : ''(ES24.15E3)''\")' ) DHifMin write ( 63 , '(\"#                  Energy bin : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eBin write ( text , '(\"# Energy (Hartree), averaged |<f|V|i>|&#94;2 over K-points (Hartree)&#94;2,\")' ) write ( 63 , '(a, \" standard deviation (Hartree)&#94;2. Format : ''(3ES24.15E3)''\")' ) trim ( text ) ! do iE = 0 , nOfEnergies E = iE * eBin av = 0.0_dp sd = 0.0_dp if ( nKsInEbin ( iE ) > 0 ) then av = absVfiOfE2 ( iE ) / sumWk ( iE ) sd = sqrt ( sAbsVfiOfE2 ( iE )) endif write ( 63 , '(3ES24.15E3)' ) eMin + E , av , sd enddo ! close ( 63 ) ! return ! end subroutine calculateVfiElements ! ! subroutine readEigenvalues ( ik ) !! Read in the eigenvalues output from [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ib !! Loop index over bands ! character ( len = 300 ) :: iks !! String version of k point index ! call int2str ( ik , iks ) !! * Convert k point index to string ! open ( 72 , file = trim ( perfectCrystal % exportDir ) // \"/eigenvalues.\" // trim ( iks )) !! * Open the perfectCrystal `eigenvalues.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) read ( 72 , * ) !! * Ignore the first two lines as they are comments ! do ib = 1 , iBandIinit - 1 !! * Ignore eigenvalues for bands that are before `iBandIinit` ! read ( 72 , * ) ! enddo ! do ib = iBandIinit , iBandIfinal !! * Read in the eigenvalues from `iBandIinit` to `iBandIfinal` ! read ( 72 , '(ES24.15E3)' ) eigvI ( ib ) ! enddo ! close ( 72 ) !! * Close the solid defect `eigenvalues.ik` file ! open ( 72 , file = trim ( solidDefect % exportDir ) // \"/eigenvalues.\" // trim ( iks )) !! * Open the solid defect `eigenvalues.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) read ( 72 , * ) !! * Ignore the first two lines as they are comments ! do ib = 1 , iBandFinit - 1 !! * Ignore eigenvalues for bands that are before `iBandFinit` ! read ( 72 , * ) ! enddo ! do ib = iBandFinit , iBandFfinal !! * Read in the eigenvalues from `iBandFinit` to `iBandFfinal` ! read ( 72 , '(ES24.15E3)' ) eigvF ( ib ) ! enddo ! close ( 72 ) !! * Close the solid defect `eigenvalues.ik` file ! return ! end subroutine readEigenvalues ! ! subroutine finalizeCalculation () !! Stop timer, write out total time taken, and close the output file ! implicit none ! write ( iostd , '(\"-----------------------------------------------------------------\")' ) ! call cpu_time ( tf ) write ( iostd , '(\" Total time needed:                         \", f10.2, \" secs.\")' ) tf - t0 ! close ( iostd ) ! return ! end subroutine finalizeCalculation ! !===================================================================================================== ! Utility functions that simplify the code and may be used multiple times ! !--------------------------------------------------------------------------------------------------------------------------------- function wasRead ( inputVal , variableName , usage , abortExecution ) !! Determine if an input variable still has the default value. !! If it does, output an error message and possibly set the program !! to abort. Not all variables would cause the program to abort, !! so this program assumes that if you pass in the logical `abortExecution` !! then the variable is required and causes the program to abort !! if missing. !! !! I could not find a clean way to allow this function to receive !! different types of variables (integer, real, character, etc.), so !! I made the argument be an integer so that each type could be sent !! in a different way. Each case is set up so that the value is tested to !! see if it is less than zero to determine if the variable still has !! its default value !! !! * For strings, the default value is `''`, so pass in !! `LEN(trim(variable))-1` as this should be less than zero if !! the string still has the default value and greater than or equal !! to zero otherwise !! * For integers the default values are less than zero, so just pass as is !! * Real variables also have a negative default value, so just pass the !! value cast from real to integer !! implicit none ! integer , intent ( in ) :: inputVal !! Value to compare with 0 to see if a variable has been read; ! character ( len =* ), intent ( in ) :: variableName !! Name of the variable used in output message character ( len =* ), intent ( in ) :: usage !! Example of how the variable can be used ! logical , optional , intent ( inout ) :: abortExecution !! Optional logical for if the program should be aborted logical :: wasRead !! Whether or not the input variable was read from the input file; !! this is the return value ! !! <h2>Walkthrough</h2> !! wasRead = . true . !! * Default return value is true ! if ( inputVal < 0 ) then !! * If the input variable still has the default value !!    * output an error message !!    * set the program to abort if that variable was sent in !!    * set the return value to false to indicate that the !!      variable wasn't read ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"\", a, \"\"\" is not defined!\")' ) variableName write ( iostd , '(\" usage : \", a)' ) usage if ( present ( abortExecution )) then ! write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! wasRead = . false . ! endif ! return ! end function wasRead ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine int2str ( integ , string ) !! Write a give integer to a string, using only as many digits as needed ! implicit none integer :: integ character ( len = 300 ) :: string ! if ( integ < 10 ) then write ( string , '(i1)' ) integ else if ( integ < 100 ) then write ( string , '(i2)' ) integ else if ( integ < 1000 ) then write ( string , '(i3)' ) integ else if ( integ < 10000 ) then write ( string , '(i4)' ) integ endif ! string = trim ( string ) ! return ! end subroutine int2str ! end module TMEModule","tags":"","loc":"sourcefile/tme_module_v28.f90.html","title":"TME_Module_v28.f90 – Carrier Cross Sections"},{"text":"Contents Programs MjME Source Code Mj_Main.f90 Source Code program MjME ! use MjModule ! implicit none ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call displaceAtoms () ! if ( readQEInput ) then call exportQEInput () else call writeNewAtomicPositions () endif ! end program MjME","tags":"","loc":"sourcefile/mj_main.f90.html","title":"Mj_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules MjModule Source Code Mj_Module_v1.f90 Source Code module MjModule ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: iostd = 16 , un = 3 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: THzToHartree = 1.0_dp / 657 9.683920729_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer :: nAtoms , nOfqPoints , nModes ! integer :: ios ! real ( kind = dp ) :: ti , tf , t1 , t2 real ( kind = dp ) :: temperature , kT ! integer , allocatable :: s2L (:) ! real ( kind = dp ), allocatable :: atomD (:,:), atomM (:), phonQ (:,:), phonF (:), genCoord (:) real ( kind = dp ), allocatable :: atomPosition (:,:), newAtomicPosition (:,:) real ( kind = dp ), allocatable :: wby2kT (:), phonD (:,:,:,:), x (:), Sj (:), coth (:), besOrderNofModeM (:,:) ! real ( kind = dp ) :: maxDisplacement ! integer :: modeI , modeF , qPoint ! character ( len = 2 ), allocatable :: elements (:) character ( len = 6 ), parameter :: output = 'status' character ( len = 256 ) :: phononsInput , equilibriumAtomicPositions , newAtomicPositions , QEInput ! logical :: file_exists , readQEInput ! namelist / MjInput / QEInput , phononsInput , temperature , equilibriumAtomicPositions , modeI , modeF , qPoint , maxDisplacement ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if file output exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , MjInput , iostat = ios ) ! call checkAndUpdateInput () ! call readPhonons () ! call readAtomicPositions () ! return ! end subroutine readInputs ! ! subroutine initialize () ! implicit none ! QEInput = '' phononsInput = '' equilibriumAtomicPositions = '' temperature = - 1.0_dp maxDisplacement = - 1.0_dp modeI = - 1 modeF = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () ! implicit none ! logical :: abortExecution = . false . ! write ( iostd , * ) ! if ( equilibriumAtomicPositions == '' ) then write ( iostd , '(\" equilibriumAtomicPositions is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Equilibrium Atomic Positions input : \", a)' ) trim ( equilibriumAtomicPositions ) endif ! if ( phononsInput == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( PhononsInput ) endif ! if ( QEInput == '' ) then write ( iostd , '(\" QEInput is not defined!\")' ) readQEInput = . false . else readQEInput = . true . write ( iostd , '(\" Quantum Espresso input : \", a)' ) trim ( QEInput ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Temperature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324d-5 * eVToHartree endif ! if ( modeI < 0 ) then write ( iostd , '(\" Variable modeI has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Initial mode : \", i5)' ) modeI endif ! if ( modeF < 0 ) then write ( iostd , '(\" Variable modeF has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Final mode : \", i5)' ) modeF endif ! if ( modeF < modeI ) then write ( iostd , '(\" Final mode is set smaller than initial one!\")' ) abortExecution = . true . endif ! if ( maxDisplacement < 0 ) then write ( iostd , '(\" Variable maxDisplacement has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum atomic displacement in each direction : \", f15.10)' ) maxDisplacement endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! return ! end subroutine checkAndUpdateInput ! ! subroutine readPhonons () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! open ( 1 , file = trim ( phononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms ! write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints flush ( iostd ) ! nModes = 3 * nAtoms - 3 ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhonons ! ! subroutine readAtomicPositions () ! implicit none ! integer :: iAtom ! open ( 1 , file = trim ( equilibriumAtomicPositions ), status = \"old\" ) ! allocate ( elements ( nAtoms ), atomPosition ( 3 , nAtoms ) ) ! atomPosition (:,:) = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) elements ( iAtom ), atomPosition ( 1 , iAtom ), atomPosition ( 2 , iAtom ), atomPosition ( 3 , iAtom ) enddo ! close ( 1 ) ! return ! end subroutine readAtomicPositions ! ! subroutine computeGeneralizedDisplacements () ! implicit none ! integer :: iq , iMode , iAtom ! allocate ( genCoord ( nModes ) ) ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) ! enddo ! enddo ! enddo ! deallocate ( atomM , atomD ) ! return ! end subroutine computeGeneralizedDisplacements ! ! subroutine computeVariables () ! implicit none ! integer :: i , j , iMode , nm , nb ! real ( kind = dp ), allocatable :: bi (:), di (:), bk (:), dk (:) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) ! x = 0.0_dp Sj = 0.0_dp coth = 0.0_dp wby2kT = 0.0_dp ! Sj (:) = 0.5_dp * phonF (:) * genCoord (:) * genCoord (:) wby2kT (:) = phonF (:) / ( 2.0_dp * kT ) coth (:) = cosh ( wby2kT (:)) / sinh ( wby2kT (:)) x (:) = Sj (:) / sinh ( wby2kT (:)) ! allocate ( s2L ( nModes ) ) s2L (:) = 0 ! do iMode = 1 , nModes s2L ( iMode ) = iMode enddo ! call arrangeLargerToSmaller () ! open ( 11 , file = 'modes' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2,  Sj/sinh(wby2kT)\")' ) ! do iMode = 1 , nModes ! write ( 11 , '(i4,1x,4E20.10E3)' ) s2L ( iMode ), phonF ( s2L ( iMode )) * 1.0e3_dp * HartreeToEv , & genCoord ( s2L ( iMode )), genCoord ( s2L ( iMode )) ** 2 , x ( s2L ( iMode )) ! enddo ! close ( 11 ) ! deallocate ( genCoord ) ! nb = modeF ! allocate ( besOrderNofModeM ( 0 : nb + 1 , nModes ) ) allocate ( bi ( 0 : nb + 1 ), di ( 0 : nb + 1 ) ) allocate ( bk ( 0 : nb + 1 ), dk ( 0 : nb + 1 ) ) ! do j = 1 , nModes ! bi (:) = 0.0_dp ! nm = nb + 1 call iknb ( nb + 1 , x ( j ), nm , bi ) ! , di, bk, dk) ! do i = 0 , nb + 1 ! besOrderNofModeM ( i , j ) = bi ( i ) ! enddo ! !write(6,*) j, x(j) !, (besOrderNofModeM(i,j), i = 0, 5) ! nb + 1) !, phonF(j) ! enddo ! return ! end subroutine computeVariables ! ! subroutine arrangeLargerToSmaller () ! implicit none ! integer :: i , iMode ! real ( kind = dp ), allocatable :: temp (:) real ( kind = dp ) :: tmpr integer :: tmpi ! allocate ( temp ( nModes ) ) ! temp (:) = 0.0_dp temp (:) = x (:) ! exp(wby2kT(:) - Sj(:)*coth(:))*besOrderNofModeM(1,:) ! x(:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! tmpi = s2L ( i ) s2L ( i ) = s2L ( i + 1 ) s2L ( i + 1 ) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! endif ! enddo ! enddo ! deallocate ( temp ) ! return ! end subroutine arrangeLargerToSmaller ! ! subroutine displaceAtoms () ! implicit none ! integer :: istat , iAtom , iMode , iRand real ( kind = dp ) :: ran , norm ! allocate ( newAtomicPosition ( 3 , nAtoms ) ) ! open ( unit = 12 , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! write ( iostd , * ) ! do iMode = modeI , modeF ! write ( iostd , '(\" Calculating new atomic positions for mode :\", i10)' ) s2L ( iMode ) ! do iAtom = 1 , nAtoms ! norm = sqrt ( sum ( phonD (:, iAtom , s2L ( iMode ), qPoint ) ** 2 )) ! read ( 12 ) iRand ran = mod ( abs ( iRand ), 10000000 ) / 1.0e7_dp ! newAtomicPosition (:, iAtom ) = atomPosition (:, iAtom ) + maxDisplacement * ran * phonD (:, iAtom , s2L ( iMode ), qPoint ) / norm ! enddo ! enddo ! close ( 12 ) ! end subroutine displaceAtoms ! ! subroutine writeNewAtomicPositions () ! implicit none ! integer :: iAtom , iMode ! do iMode = modeI , modeF ! write ( iostd , '(\" Writing new atomic positions for mode :\", i10)' ) s2L ( iMode ) ! if ( s2L ( iMode ) < 10 ) then write ( newAtomicPositions , '(\"newPositionsForMode\", i1)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 100 ) then write ( newAtomicPositions , '(\"newPositionsForMode\", i2)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 1000 ) then write ( newAtomicPositions , '(\"newPositionsForMode\", i3)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 10000 ) then write ( newAtomicPositions , '(\"newPositionsForMode\", i4)' ) s2L ( iMode ) else newAtomicPositions = 'newPositions' endif ! open ( 21 , file = trim ( newAtomicPositions ), status = 'unknown' ) ! do iAtom = 1 , nAtoms ! !write(6, '(i4, f15.12, 3f15.5, \" | \", 3f15.5)') iAtom, maxDisplacement*ran, & !          atomPosition(:,iAtom), atomPosition(:,iAtom) + maxDisplacement*ran*phonD(:,iAtom,s2L(iMode),qPoint)/norm write ( 21 , * ) elements ( iAtom ), newAtomicPosition (:, iAtom ) enddo ! close ( 21 ) ! enddo ! end subroutine writeNewAtomicPositions ! ! subroutine exportQEInput () ! integer :: iAtom , iMode character ( len = 256 ) :: line , fn , modeFolder , mkDir ! do iMode = modeI , modeF ! if ( s2L ( iMode ) < 10 ) then write ( modeFolder , '(\"mode_\", i1)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 100 ) then write ( modeFolder , '(\"mode_\", i2)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 1000 ) then write ( modeFolder , '(\"mode_\", i3)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 10000 ) then write ( modeFolder , '(\"mode_\", i4)' ) s2L ( iMode ) endif ! inquire ( file = trim ( modeFolder ), exist = file_exists ) if ( . not . file_exists ) then write ( mkDir , '(\"mkdir -p \", a)' ) trim ( modeFolder ) call system ( mkDir ) endif ! fn = trim ( QEInput ) fn = fn ( INDEX ( QEInput , '/' , BACK = . TRUE .): INDEX ( QEInput , '.in' ) - 1 ) ! write ( iostd , '(\" Writing new QE input file for mode :\", i10)' ) s2L ( iMode ) ! if ( s2L ( iMode ) < 10 ) then write ( fn , '(a, \"_mode\", i1, \".in\")' ) trim ( fn ), s2L ( iMode ) else if ( s2L ( iMode ) < 100 ) then write ( fn , '(a, \"_mode\", i2, \".in\")' ) trim ( fn ), s2L ( iMode ) else if ( s2L ( iMode ) < 1000 ) then write ( fn , '(a, \"_mode\", i3, \".in\")' ) trim ( fn ), s2L ( iMode ) else if ( s2L ( iMode ) < 10000 ) then write ( fn , '(a, \"_mode\", i4, \".in\")' ) trim ( fn ), s2L ( iMode ) endif ! fn = trim ( modeFolder ) // \"/\" // trim ( fn ) ! open ( 2 , file = trim ( fn ), status = \"unknown\" ) ! open ( 1 , file = trim ( QEInput ), status = \"old\" ) ! do read ( 1 , '(a)' , END = 100 ) line write ( 2 , '(a)' ) trim ( line ) if ( INDEX ( line , 'ATOMIC_POSITIONS' ) /= 0 ) then do iAtom = 1 , nAtoms read ( 1 , '(a)' ) line write ( 2 , * ) elements ( iAtom ), newAtomicPosition (:, iAtom ) enddo endif enddo 100 continue ! close ( 1 ) close ( 2 ) ! enddo ! end subroutine exportQEInput !  subroutine readMjs() !    ! !    implicit none !    ! !    integer :: i, iE0, iE, dummyI, nEMjs !    real(kind = dp) :: dummyD, E, MjsOfE, MjOfE0 !    character :: dummyC !    ! !    open(1, file=trim(MjsInput), status=\"old\") !    ! !    read(1, *) dummyC, nEMjs !    ! !    allocate ( Mjs(-nEnergies:nEnergies) ) !    ! !    Mjs = 1.0_dp !    ! !!    read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, MjsOfE0, dummyD !!    ! !!    E = E*eVToHartree !!    iE = int(E/deltaE) + 1 !!    ! !!    do i = 1, nEMjs - 1 !!      ! !!      iE0 = iE !!      read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, MjsOfE, dummyD !!      E = E*eVToHartree !!      iE = int(E/deltaE) + 1 !!      Mjs(iE0:iE) = MjsOfE0 !!      MjsOfE0 = MjsOfE !!      ! !!    enddo !!    ! !!    close(1) !!    ! !!    !do iE = -nEnergies, nEnergies !!    !  write(44,*) real(iE, dp)*deltaE*HartreeToEv, Mjs(iE) !!    !enddo !!    ! !    return !    ! !  end subroutine readMjs ! ! subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !c*********************************************************************72 !c !cc IKNB compute Bessel function In(x) and Kn(x). !c !c  Discussion: !c !c    Compute modified Bessel functions In(x) and Kn(x), !c    and their derivatives. !c !c  Licensing: !c !c    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !c    they give permission to incorporate this routine into a user program !c    provided that the copyright is acknowledged. !c !c  Modified: !c !c    17 July 2012 !c !c  Author: !c !c    Shanjie Zhang, Jianming Jin !c !c  Reference: !c !c    Shanjie Zhang, Jianming Jin, !c    Computation of Special Functions, !c    Wiley, 1996, !c    ISBN: 0-471-11963-6, !c    LC: QA351.C45. !c !c  Parameters: !c !c    Input, integer N, the order of In(x) and Kn(x). !c !c    Input, double precision X, the argument. !c !c    Output, integer NM, the highest order computed. !c !c    Output, double precision BI(0:N), DI(0:N), BK(0:N), DK(0:N), !c    the values of In(x), In'(x), Kn(x), Kn'(x). !c implicit none integer , intent ( in ) :: n !      double precision :: a0 double precision :: bi ( 0 : n ) !      double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: f0 double precision :: f1 !      double precision :: g !      double precision :: g0 !      double precision :: g1 integer :: k !      integer :: k0 !      integer :: l integer :: m , ik !      integer :: msta1 !      integer :: msta2 integer :: nm double precision :: pi !      double precision :: r double precision :: s0 double precision :: sk0 !      double precision :: vt double precision :: x , ifact pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n if ( x . le . 1.0D-15 ) then do k = 0 , n ifact = 1.0_dp do ik = 2 , k ifact = ifact * ik enddo bi ( k ) = ( 0.5_dp * x ) ** k / ifact end do return end if if ( n . eq . 0 ) then nm = 1 end if m = msta1 ( x , 200 ) if ( m . lt . nm ) then nm = m else m = msta2 ( x , nm , 15 ) end if bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 if ( k . le . nm ) then bi ( k ) = f end if if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then sk0 = sk0 + 4.0D+00 * f / k end if bs = bs + 2.0D+00 * f f0 = f1 f1 = f end do s0 = exp ( x ) / ( bs - f ) do k = 0 , nm bi ( k ) = s0 * bi ( k ) end do return end SUBROUTINE iknb ! ! SUBROUTINE iknb2 ( n , x , nm , bi , di , bk , dk ) ! !    ============================================================ !    Purpose: Compute modified Bessel functions In(x) and Kn(x), !             and their derivatives !    Input:   x --- Argument of In(x) and Kn(x) ( 0 ó x ó 700 ) !             n --- Order of In(x) and Kn(x) !    Output:  BI(n) --- In(x) !             DI(n) --- In'(x) !             BK(n) --- Kn(x) !             DK(n) --- Kn'(x) !             NM --- Highest order computed !    Routines called: !             MSTA1 and MSTA2 for computing the starting point !             for backward recurrence !    =========================================================== ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( OUT ) :: nm REAL ( dp ), INTENT ( OUT ) :: bi ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: di ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: bk ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: dk ( 0 : n ) ! REAL ( dp ), PARAMETER :: pi = 3.141592653589793_dp , el = 0.5772156649015329_dp REAL ( dp ) :: a0 , bkl , bs , f , f0 , f1 , g , g0 , g1 , r , s0 , sk0 , vt INTEGER :: k , k0 , l , m ! nm = n IF ( x <= 1.0D-50 ) THEN DO k = 0 , n bi ( k ) = 0.0D0 di ( k ) = 0.0D0 bk ( k ) = 1.0D+300 dk ( k ) = - 1.0D+300 END DO bi ( 0 ) = 1.0D0 di ( 1 ) = 0.5D0 RETURN END IF IF ( n == 0 ) nm = 1 m = msta1 ( x , 200 ) IF ( m < nm ) THEN nm = m ELSE m = msta2 ( x , nm , 15 ) END IF !write(6,*)'mmmmmmmmm', m bs = 0.0D0 sk0 = 0.0D0 f0 = 0.0D0 f1 = 1.0D-100 DO k = m , 0 , - 1 f = 2 * ( k + 1 ) / x * f1 + f0 IF ( k <= nm ) bi ( k ) = f IF ( k /= 0 . AND . k == 2 * INT ( k / 2 )) sk0 = sk0 + 4.0D0 * f / k bs = bs + 2.0D0 * f f0 = f1 f1 = f END DO !s0 = EXP(x) / (bs-f) !write(6,*) f, f1 s0 = EXP ( x ) / ( bs - f1 ) bi ( 0 : nm ) = s0 * bi ( 0 : nm ) IF ( x <= 8.0D0 ) THEN bk ( 0 ) = - ( LOG ( 0.5D0 * x ) + el ) * bi ( 0 ) + s0 * sk0 bk ( 1 ) = ( 1.0D0 / x - bi ( 1 ) * bk ( 0 )) / bi ( 0 ) ELSE a0 = SQRT ( pi / ( 2.0D0 * x )) * EXP ( - x ) k0 = 16 IF ( x >= 2 5.0 ) k0 = 10 IF ( x >= 8 0.0 ) k0 = 8 IF ( x >= 20 0.0 ) k0 = 6 DO l = 0 , 1 bkl = 1.0D0 vt = 4 * l r = 1.0D0 DO k = 1 , k0 r = 0.125D0 * r * ( vt - ( 2 * k - 1 ) ** 2 ) / ( k * x ) bkl = bkl + r END DO bk ( l ) = a0 * bkl END DO END IF g0 = bk ( 0 ) g1 = bk ( 1 ) DO k = 2 , nm g = 2 * ( k - 1 ) / x * g1 + g0 bk ( k ) = g g0 = g1 g1 = g END DO di ( 0 ) = bi ( 1 ) dk ( 0 ) = - bk ( 1 ) DO k = 1 , nm di ( k ) = bi ( k - 1 ) - k / x * bi ( k ) dk ( k ) = - bk ( k - 1 ) - k / x * bk ( k ) END DO RETURN ! END SUBROUTINE iknb2 ! ! FUNCTION msta1 ( x , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that the magnitude of !                Jn(x) at that point is about 10&#94;(-MP) !       Input :  x     --- Argument of Jn(x) !                MP    --- Value of magnitude !       Output:  MSTA1 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , f , f0 , f1 INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) n0 = INT ( 1.1 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - mp IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn ! RETURN ! END FUNCTION msta1 ! ! FUNCTION msta2 ( x , n , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that all Jn(x) has MP !                significant digits !       Input :  x  --- Argument of Jn(x) !                n  --- Order of Jn(x) !                MP --- Significant digit !       Output:  MSTA2 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) hmp = 0.5_dp * mp ejn = envj ( n , a0 ) IF ( ejn <= hmp ) THEN obj = mp n0 = INT ( 1.1 * a0 ) ELSE obj = hmp + ejn n0 = n END IF !!!!!!!! if ( n0 < 1 ) n0 = 1 !!!!!!!! f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj ! DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - obj IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn + 10 ! RETURN ! END FUNCTION msta2 ! ! FUNCTION envj ( n , x ) RESULT ( fn_val ) ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val ! fn_val = 0.5_dp * LOG10 ( 6.28_dp * n ) - n * LOG10 ( 1.36_dp * x / n ) ! RETURN ! END FUNCTION envj ! ! end module MjModule","tags":"","loc":"sourcefile/mj_module_v1.f90.html","title":"Mj_Module_v1.f90 – Carrier Cross Sections"},{"text":"Contents Programs lineShapeFunction Source Code LSF_zeroth_Main.f90 Source Code program lineShapeFunction ! ! Pull in modules use mpi use lsf ! implicit none ! ! Define an integer for ???? integer :: lll , iPhonon ! character ( len = 2 ) :: charI ! ! Initialize mpi and set up processes call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! ! If root process if ( myid == root ) then ! ! Start a timer call cpu_time ( ti ) ! ! Read input, check all variables needed and initialize the calculation. call readInputs () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call initializeLSF () ! endif ! ! Broadcast calculation parameters to all processes call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! ! For all processes that aren't the root if ( myid /= root ) then ! Allocate space for arrays allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !allocate( Vfis(-nEnergies:nEnergies) ) endif ! ! Broadcast arrays to all processes call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) !call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! ! Allocate space for arrays allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( 3 <= maximumNumberOfPhonons ) then ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! end if ! do iPhonon = minimumNumberOfPhonons , MIN0 ( maximumNumberOfPhonons , 4 ) if ( ( ( iPhonon == 1 . or . iPhonon == 2 ) . and . myid == root ) . or . iPhonon > 2 ) then if ( iPhonon > 2 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! endif ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then call cpu_time ( t1 ) ! call lsfMbyOneBand ( iPhonon ) ! if ( iPhonon > 1 ) then ! call lsfMbyTwoBands ( iPhonon ) ! else if ( iPhonon > 2 ) then ! call parallelIsFsBy3 () ! endif ! endif ! if ( iPhonon > 2 ) then ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( iPhonon ) ! endif ! if ( iPhonon > 3 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfDeterministicFourPhononsByFourBands () ! endif ! if ( iPhonon > 2 ) then ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! endif if ( myid == root ) then ! call cpu_time ( t2 ) ! write ( iostd , '(i2, \" modes, time needed :,\" , f10.2, \" secs.\")' ) iPhonon , t2 - t1 flush ( iostd ) ! if ( iPhonon > 2 ) then ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! else ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByBands , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! endif ! write ( iostd , * ) 'DE' , iPhonon , de flush ( iostd ) ! charI = '' write ( charI , \"(i2.2)\" ) iPhonon ! open ( 1 , file = 'lsfVsEwithUpTo' // trim ( charI ) // 'phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , iPhonon ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! if ( iPhonon < 3 ) then ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de ! else ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de ! endif ! enddo ! close ( 1 ) ! endif ! endif ! enddo ! if ( maximumNumberOfPhonons >= 5 ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then ! if ( istat /= 0 ) then ! write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' ! else ! write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' ! endif ! flush ( iostd ) ! endif ! if ( istat /= 0 ) close ( un ) ! ! allocate ( lsfbyPhononsPerProc(-nEnergies:nEnergies) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC ! do i = numprocs - 1 , 1 , - 1 ! iModeIs ( i ) = i * iMint + 1 ! if ( iMmod > 0 ) then ! iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 ! endif ! iModeFs ( i - 1 ) = iModeIs ( i ) - 1 ! enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 ! do ni = m - 1 , m - l + 1 , - 1 ! times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 ! enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = nModes ! do iMode = 2 , l ! weight = weight * ( nModes - iMode + 1 ) / iMode ! enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m ! elseif ( m < 100 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m ! elseif ( m < 1000 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m ! else ! write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m ! endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de ! enddo ! close ( 5000 ) ! endif ! enddo ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! deallocate ( lsfVsEbyBands , iEbinsByBands , pj ) ! if ( 3 <= maximumNumberOfPhonons ) then ! deallocate ( iModeIs , iModeFs ) ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! end if ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"sourcefile/lsf_zeroth_main.f90.html","title":"LSF_zeroth_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules lsf Source Code LSF_zeroth_Module_v35.f90 Source Code module lsf ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: iostd = 16 , un = 3 integer , parameter :: root = 0 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: THzToHartree = 1.0_dp / 657 9.683920729_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer ( kind = int32 ) :: myid , numprocs , ios , istat , ierr integer :: iMode , l , m , nMC , nProcMax integer :: iMint , iMmod , i , printsteps , iE , ni , mi integer :: nAtoms , nOfqPoints , nModes , minimumNumberOfPhonons , maximumNumberOfPhonons , nEnergies ! real ( kind = dp ) :: ti , tf , t1 , t2 real ( kind = dp ) :: weight , times , de , E ! , vg real ( kind = dp ) :: temperature , maxEnergy , deltaE , kT ! , volume ! integer , allocatable :: iModeIs (:), iModeFs (:) integer , allocatable :: pj (:), pj0s (:,:), pms (:,:), s2L (:) integer , allocatable :: iEbinsByBands (:), iEbinsByPhonons (:) ! real ( kind = dp ), allocatable :: atomD (:,:), atomM (:), phonQ (:,:), phonF (:), genCoord (:) !, Vfis(:) real ( kind = dp ), allocatable :: wby2kT (:), phonD (:,:,:,:), x (:), Sj (:), coth (:), besOrderNofModeM (:,:) real ( kind = dp ), allocatable :: lsfVsEbyBands (:), lsfVsE (:), lsfVsEbyPhonons (:), lsfbyPhononsPerProc (:) ! character ( len = 6 ), parameter :: output = 'status' !  character(len = 256) :: VfisInput, PhononsInput, crossSectionOutput, fn, continueLSFfromFile character ( len = 256 ) :: phononsInputFormat , phononsInput , fn , continueLSFfromFile ! logical :: file_exists ! !  namelist /elphscat/ VfisInput, PhononsInput, temperature, maxEnergy, continueLSFfromFile, volume, & namelist / lsfInput / phononsInput , phononsInputFormat , temperature , & continueLSFfromFile , maximumNumberOfPhonons , nMC ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if file output exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , lsfInput , iostat = ios ) ! call checkAndUpdateInput () ! if ( trim ( phononsInputFormat ) == 'VASP' ) then call readPhononsVASP () else if ( trim ( phononsInputFormat ) == 'QE' ) then call readPhononsQE () else write ( iostd , '(\" Unknown phonons input format : \", (a) )' ) trim ( phononsInputFormat ) write ( iostd , '(\" Phonons input format implemened are : ''VASP'' and ''QE''\")' ) write ( iostd , '(\" Program stops!\")' ) stop endif ! !    call readVfis() ! return ! end subroutine readInputs ! ! subroutine initializeLSF () ! implicit none ! real ( kind = dp ) :: dummyD integer :: dummyI character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! allocate ( lsfVsE ( - nEnergies : nEnergies ) ) ! minimumNumberOfPhonons = 1 lsfVsE (:) = 0.0_dp ! if ( continueLSFfromFile /= '' ) then ! inquire ( file = trim ( continueLSFfromFile ), exist = file_exists ) if ( file_exists ) then ! open ( unit = 11 , file = trim ( continueLSFfromFile ), status = \"old\" ) ! read ( 11 , '(a1, i10, a9, i5, a8)' ) dummyC1 , dummyI , dummyC9 , minimumNumberOfPhonons , dummyC8 ! minimumNumberOfPhonons = minimumNumberOfPhonons + 1 write ( iostd , '(\" Minimum number of phonons : \", i5)' ) minimumNumberOfPhonons ! do iE = - nEnergies , nEnergies read ( 11 , * ) dummyD , lsfVsE ( iE ) enddo close ( 11 ) ! endif endif ! return ! end subroutine initializeLSF ! ! subroutine initialize () ! implicit none ! !    VfisInput = '' phononsInput = '' phononsInputFormat = '' temperature = - 1.0_dp minimumNumberOfPhonons = 1 maximumNumberOfPhonons = - 1 nMC = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () ! implicit none ! logical :: abortExecution = . false . ! if ( trim ( phononsInput ) == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( phononsInput ) endif ! if ( trim ( phononsInputFormat ) == '' ) then write ( iostd , '(\" PhononsInputFormat is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input format : \", a)' ) trim ( phononsInputFormat ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Tempetature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324e-5_dp * eVToHartree endif ! if ( maximumNumberOfPhonons < 0 ) then write ( iostd , '(\" Variable maximumNumberOfPhonons has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum number of phonons : \", i5)' ) maximumNumberOfPhonons endif ! if ( nMC < 0 ) then if ( maximumNumberOfPhonons > 4 ) then write ( iostd , '(\" For calculations with configurations with more than 4 phonon modes \")' ) write ( iostd , '(\" the number of Monte Carlo steps ''nMC'' must be set.\")' ) abortExecution = . true . endif else if ( maximumNumberOfPhonons > 4 ) then write ( iostd , '(\" Number of Monte Carlo steps : \", i15)' ) nMC else write ( iostd , '(\" The number of Monte Carlo steps ''nMC'' is set to : \", i15, \" but\")' ) nMC write ( iostd , '(\" will not be used since the Monte Carlo sheme is used for calculations\")' ) write ( iostd , '(\" with configurations with more that 4 phonon modes.\")' ) endif endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" * Please check the input. * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! maxEnergy = 1 0.0_dp * eVToHartree ! nEnergies = 5040 ! 2520 ! 10080 deltaE = maxEnergy / real ( nEnergies , dp ) ! write ( iostd , '(\" The resolution in energy is :\", f10.2, \" meV.\")' ) deltaE * 100 0.0_dp * HartreeToEv ! flush ( iostd ) ! return ! end subroutine checkAndUpdateInput ! ! subroutine readPhononsVASP () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! !write(6,*) trim(phononsInput) open ( 1 , file = trim ( phononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms ! nModes = 3 * nAtoms - 3 ! write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes : \", i5)' ) nModes flush ( iostd ) ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhononsVASP ! ! subroutine readPhononsQE () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! !write(6,*) trim(phononsInput) open ( 1 , file = trim ( phononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms , nModes ! write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes : \", i5)' ) nModes flush ( iostd ) ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp !The unit is in Bohr do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC read ( 1 , * ) ! do iMode = 1 , nModes ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , freqInTHz phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyC , phonD ( 1 , iAtom , iMode , iq ), dummyD , phonD ( 2 , iAtom , iMode , iq ), dummyD , phonD ( 3 , iAtom , iMode , iq ), dummyC write ( 6 , * ) phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhononsQE ! ! subroutine computeGeneralizedDisplacements () ! implicit none ! integer :: iq , iMode , iAtom ! allocate ( genCoord ( nModes ) ) ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) ! enddo ! enddo ! enddo ! open ( 11 , file = 'generalizedDisplacements' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2\")' ) ! do iMode = 1 , nModes write ( 11 , '(i4,1x,3E20.10E3)' ) iMode , phonF ( iMode ) * 1.0e3_dp * HartreeToEv , genCoord ( iMode ), genCoord ( iMode ) * genCoord ( iMode ) enddo ! close ( 11 ) ! deallocate ( atomM , phonD , atomD ) ! return ! end subroutine computeGeneralizedDisplacements ! ! subroutine computeVariables () ! implicit none ! integer :: i , j , nm , nb ! real ( kind = dp ), allocatable :: bi (:), di (:), bk (:), dk (:) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) ! x = 0.0_dp Sj = 0.0_dp coth = 0.0_dp wby2kT = 0.0_dp ! Sj (:) = 0.5_dp * phonF (:) * genCoord (:) * genCoord (:) wby2kT (:) = phonF (:) / ( 2.0_dp * kT ) coth (:) = cosh ( wby2kT (:)) / sinh ( wby2kT (:)) x (:) = Sj (:) / sinh ( wby2kT (:)) ! allocate ( s2L ( nModes ) ) s2L (:) = 0 ! do iMode = 1 , nModes s2L ( iMode ) = iMode enddo ! call arrangeLargerToSmaller () ! open ( 11 , file = 'modes' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2,  Sj/sinh(wby2kT)\")' ) ! do iMode = 1 , nModes ! write ( 11 , '(i4,1x,4E20.10E3)' ) s2L ( iMode ), phonF ( s2L ( iMode )) * 1.0e3_dp * HartreeToEv , & genCoord ( s2L ( iMode )), genCoord ( s2L ( iMode )) ** 2 , x ( s2L ( iMode )) ! enddo ! close ( 11 ) ! deallocate ( genCoord ) ! !  call arrangeLargerToSmaller() ! nb = maximumNumberOfPhonons allocate ( besOrderNofModeM ( 0 : nb + 1 , nModes ) ) allocate ( bi ( 0 : nb + 1 ), di ( 0 : nb + 1 ) ) allocate ( bk ( 0 : nb + 1 ), dk ( 0 : nb + 1 ) ) ! do j = 1 , nModes ! bi (:) = 0.0_dp ! nm = nb + 1 call iknb ( nb + 1 , x ( j ), nm , bi ) ! , di, bk, dk) ! do i = 0 , nb + 1 ! besOrderNofModeM ( i , j ) = bi ( i ) ! enddo ! write ( 6 , * ) j , x ( j ), ( besOrderNofModeM ( i , j ), i = 0 , 5 ) ! nb + 1) !, phonF(j) ! enddo ! return ! end subroutine computeVariables ! ! subroutine arrangeLargerToSmaller () ! implicit none ! integer :: i , iMode ! real ( kind = dp ), allocatable :: temp (:) real ( kind = dp ) :: tmpr integer :: tmpi ! allocate ( temp ( nModes ) ) ! temp (:) = 0.0_dp temp (:) = x (:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! if ( exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! tmpi = s2L ( i ) s2L ( i ) = s2L ( i + 1 ) s2L ( i + 1 ) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! ! !          tmp = x(i) !          x(i) = x(i+1) !          x(i+1) = tmp !          ! !          tmp = coth(i) !          coth(i) = coth(i+1) !          coth(i+1) = tmp !          ! !          tmp = wby2kT(i) !          wby2kT(i) = wby2kT(i+1) !          wby2kT(i+1) = tmp !          ! !          tmp = phonF(i) !          phonF(i) = phonF(i+1) !          phonF(i+1) = tmp !          ! endif ! enddo ! enddo ! deallocate ( temp ) ! return ! end subroutine arrangeLargerToSmaller ! ! !  subroutine readVfis() !    ! !    implicit none !    ! !    integer :: i, iE0, iE, dummyI, nEVfi !    real(kind = dp) :: dummyD, E, VfiOfE, VfiOfE0 !    character :: dummyC !    ! !    open(1, file=trim(VfisInput), status=\"old\") !    ! !    read(1, *) dummyC, nEVfi !    ! !    allocate ( Vfis(-nEnergies:nEnergies) ) !    ! !    Vfis = 0.0_dp !    ! !    read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, VfiOfE0, dummyD !    ! !    E = E*eVToHartree !    iE = int(E/deltaE) + 1 !    ! !    do i = 1, nEVfi - 1 !      ! !      iE0 = iE !      read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, VfiOfE, dummyD !      E = E*eVToHartree !      iE = int(E/deltaE) + 1 !      Vfis(iE0:iE) = VfiOfE0 !      VfiOfE0 = VfiOfE !      ! !    enddo !    ! !    close(1) !    ! !    !do iE = -nEnergies, nEnergies !    !  write(44,*) real(iE, dp)*deltaE*HartreeToEv, Vfis(iE) !    !enddo !    ! !    return !    ! !  end subroutine readVfis ! ! subroutine lsfDeterministicFourPhononsByFourBands () ! implicit none ! integer :: ic integer :: iMode1 , iMode2 , iMode3 , iMode4 integer :: pm1 , pm2 , pm3 , pm4 ! real ( kind = dp ) :: t1 , t2 ! if ( myid == root ) then write ( iostd , * ) 'Four modes' flush ( iostd ) endif ! ! Four modes ! call cpu_time ( t1 ) ! ic = 0 do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , nModes - 2 !write(iostd, '(\"myID \", i15, \" iMode1 = \", i5, \" / \", i5, \" in each proc. iMode2 =\", i5, \" / \", i5)') myid, & !           iMode1-iModeIs(myid)+1, iModeFs(myid)-iModeIs(myid)+1,iMode2 - iMode1+1 + 1, nModes - 2 - iMode1+1 + 1 do iMode3 = iMode2 + 1 , nModes - 1 do iMode4 = iMode3 + 1 , nModes ! do pm1 = - 1 , 1 , 2 do pm2 = - 1 , 1 , 2 do pm3 = - 1 , 1 , 2 do pm4 = - 1 , 1 , 2 ! pj (:) = 0 pj ( iMode1 ) = pm1 pj ( iMode2 ) = pm2 pj ( iMode3 ) = pm3 pj ( iMode4 ) = pm4 ! call lsfOfConfigurationPj () ! ic = ic + 1 ! enddo enddo enddo enddo ! enddo enddo enddo enddo ! call cpu_time ( t2 ) ! return ! end subroutine lsfDeterministicFourPhononsByFourBands ! ! subroutine lsfOfConfigurationPj () ! implicit none ! integer :: iE , j ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio ! prodFj = 1.0_dp sumOverj = 0.0_dp do j = 1 , nModes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( j )), j ) if ( pj ( j ) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj endif prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( j ) / ( abs ( pj ( j )) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( j )) + 1 , j ) / besPj sumOverj = sumOverj + ( abs ( pj ( j )) + x ( j ) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! return ! end subroutine lsfOfConfigurationPj ! ! subroutine calculatePlusMinusStates ( l ) ! implicit none ! integer , intent ( in ) :: l ! integer :: iDes , other ( 0 : l - 1 ) ! do iDes = 0 , 2 ** l - 1 ! other (:) = 0 ! call decimalToOther ( iDes , l , 2 , other ) ! pms ( iDes ,:) = other (:) ! enddo ! return ! end subroutine calculatePlusMinusStates ! ! subroutine distrubutePhononsInBands ( m , l ) ! implicit none ! integer , intent ( in ) :: m , l ! integer :: i , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 , i11 , i12 ! if ( l == 1 ) then ! pj0s ( 1 , 1 ) = m ! else if ( l == m - 1 ) then ! do i = 1 , l pj0s ( i ,:) = 1 pj0s ( i , i ) = m - ( l - 1 ) enddo ! else if ( l == m ) then ! pj0s ( 1 ,:) = 1 ! else if ( l == 2 ) then ! do i = 1 , m - 1 ! pj0s ( i , 1 ) = i pj0s ( i , 2 ) = m - i ! enddo ! else if ( l == 3 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 ! i = i + 1 ! endif ! enddo enddo enddo ! !write(6,*) 'l = 3, i = ', i - 1 ! else if ( l == 4 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 ! i = i + 1 ! endif ! enddo enddo enddo enddo !write(6,*) 'l = 4, i = ', i - 1 ! else if ( l == 5 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo ! !write(6,*) 'l = 5, i = ', i - 1 ! else if ( l == 6 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 6, i = ', i - 1 ! else if ( l == 7 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 7, i = ', i ! else if ( l == 8 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 8, i = ', i ! else if ( l == 9 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 10 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 11 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 12 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) do i12 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 + i12 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 pj0s ( i , 12 ) = i12 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo endif ! return ! end subroutine distrubutePhononsInBands ! ! subroutine lsfWithMphonons ( m , l , tTimes ) ! implicit none ! integer , intent ( in ) :: m , l , tTimes ! integer :: ii ! integer :: iMC , iM , i , pick , j , picks ( l ), iE , iDes , iRand , steps ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio , randy ! logical :: picked ! if ( myid == root ) then write ( iostd , '(i4,\" phonons by\", i3, \" bands started.\")' ) m , l flush ( iostd ) endif ! printSteps = int ( ( iModeFs ( myid ) - iModeIs ( myid ) + 1.01_dp ) / 10 ) ! do iMC = iModeIs ( myid ), iModeFs ( myid ) ! if ( mod ( iMC - iModeIs ( myid ) + 1 , printSteps ) == 0 ) then if ( myid == root ) then steps = iModeFs ( myid ) - iModeIs ( myid ) + 1 write ( iostd , '(i4,\" phonons by\", i3,\" bands.\", i12,\" over \",i12,\" MC iters per processor done.\")' ) m , l , iMC , steps flush ( iostd ) endif endif ! picks (:) = 0 ! if ( istat == 0 ) then ! do iM = 1 , l picked = . false . 10 read ( un ) iRand iRand = mod ( abs ( iRand ), nModes ) + 1 do i = 1 , iM - 1 if ( picks ( i ) == iRand ) goto 10 enddo picks ( iM ) = iRand ! enddo ! else ! do iM = 1 , l picked = . false . ! 11 CALL RANDOM_NUMBER ( randy ) ! pick = int ( nModes * randy ) + 1 do i = 1 , l if ( pick . eq . picks ( i ) ) picked = . true . enddo if ( picked ) goto 11 picks ( iM ) = pick enddo ! endif ! do ii = 1 , tTimes ! do iDes = 0 , 2 ** l - 1 ! pj (:) = 0 ! do iM = 1 , l pj ( picks ( iM )) = pj0s ( ii , iM ) * ( - 1 ) ** ( pms ( iDes , iM - 1 )) enddo ! if ( abs ( sum ( abs ( pj ( picks (:)))) - m ) > 0 ) then if ( myid == root ) then write ( iostd , * ) 'ERROR' , m , sum ( abs ( pj ( picks (:)))), pj ( picks (:)) do iM = 1 , l if ( abs ( pj ( picks ( iM ))) < 1 ) then write ( iostd , * ) 'ERROR 1' , picks ( iM ) write ( iostd , * ) 'ERROR 2' , pj ( picks ( iM )) flush ( iostd ) endif enddo endif endif ! prodFj = 1.0_dp sumOverj = 0.0_dp ! do j = 1 , nModes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( j )), j ) if ( pj ( j ) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj endif ! prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( j ) / ( abs ( pj ( j )) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( j )) + 1 , j ) / besPj ! sumOverj = sumOverj + ( abs ( pj ( j )) + x ( j ) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) ! iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! enddo ! enddo ! enddo ! if ( myid == root ) then write ( iostd , '(\"---------------------------------------------\")' ) write ( iostd , '(i4,\" phonons by\", i3, \" bands done.\")' ) m , l flush ( iostd ) endif ! return ! end subroutine lsfWithMphonons ! ! subroutine decimalToOther ( iDec , n , iBase , other ) ! implicit none ! integer , intent ( in ) :: n , iBase integer :: iDec , m integer :: other ( 0 : n - 1 ), j ! m = iDec do j = n - 1 , 1 , - 1 other ( j ) = int ( m / ( iBase ** j )) m = mod ( iDec , iBase ** j ) enddo other ( 0 ) = mod ( m , iBase ) ! return ! end subroutine decimalToOther ! ! subroutine calculateDE ( maxM , iEbins , de ) ! implicit none ! integer , intent ( in ) :: maxM , iEbins ( - nEnergies : nEnergies ) real ( dp ), intent ( out ) :: de ! integer :: iE , j , ic , ib , iEmMax , nSteps , jMax , iEstep ! integer , allocatable :: tmpB (:), iEsteps (:) ! logical :: empty ! allocate ( tmpB ( nEnergies ) ) ! ic = 1 do j = 1 , nEnergies if ( mod ( nEnergies , j ) == 0 ) then tmpB ( ic ) = int (( dble ( nEnergies ) + 1.e-8_dp ) / j ) ic = ic + 1 endif enddo ! nSteps = ic - 1 allocate ( iEsteps ( nSteps ) ) iEsteps (:) = tmpB ( nSteps : 1 : - 1 ) deallocate ( tmpB ) ! iEmMax = int ( maxM * maxval ( phonF (:)) / deltaE ) + 1 ! j = 1 do while ( ( iEmMax > iEsteps ( j ) ) . and . ( j < nSteps ) ) j = j + 1 enddo ! jMax = j - 1 if ( jMax > nSteps ) jMax = nSteps ! empty = . true . j = jMax do while ( ( empty . eqv . . true . ) . and . ( j > 1 ) ) ! empty = . true . iEstep = iEsteps ( j ) do iE = 1 , iEmMax - 1 , iEstep ib = sum ( iEbins ( iE : iE + iEstep - 1 ) ) if ( ib < 1 ) then empty = . false . endif enddo j = j - 1 ! enddo ! j = j + 2 ! iEstep = iEsteps ( j ) de = deltaE * real ( iEstep , dp ) ! deallocate ( iEsteps ) ! return ! end subroutine calculateDE ! ! subroutine lsfMbyOneBand ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , pm1 ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do iMode1 = 1 , nModes ! do pm1 = - m , m , 2 * m ! pj (:) = 0 pj ( iMode1 ) = pm1 ! call lsfOfConfigurationPj () ! enddo ! enddo ! call cpu_time ( t2 ) ! write ( iostd , '(\" LSF of: \", i4, \" phonons using one band done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) ! return ! end subroutine lsfMbyOneBand ! ! subroutine lsfMbyTwoBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , iMode2 , pm1 , pm2 , l ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do l = 1 , m - 1 ! do iMode1 = 1 , nModes - 1 do iMode2 = iMode1 + 1 , nModes ! do pm1 = - l , l , 2 * l do pm2 = - ( m - l ), ( m - l ), 2 * ( m - l ) ! pj (:) = 0 pj ( iMode1 ) = pm1 pj ( iMode2 ) = pm2 ! call lsfOfConfigurationPj () ! enddo enddo ! enddo enddo ! enddo ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using two bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyTwoBands ! ! subroutine lsfMbyThreeBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! real ( dp ) :: t1 , t2 , times3 integer :: iMode1 , iMode2 , iMode3 , ni , mi , iDes , ii ! call cpu_time ( t1 ) ! times3 = 1.0_dp mi = 2 do ni = m - 1 , m - 3 + 1 , - 1 times3 = times3 * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times3 + 1.e-3_dp ), 3 ) ) pj0s (:,:) = 0 ! call distrubutePhononsInBands ( m , 3 ) ! allocate ( pms ( 0 : 2 ** 3 - 1 , 0 : 3 - 1 ) ) pms (:,:) = 0 ! call calculatePlusMinusStates ( 3 ) ! do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , nModes - 1 do iMode3 = iMode2 + 1 , nModes ! do ii = 1 , int ( times3 + 1.e-3_dp ) ! do iDes = 0 , 2 ** 3 - 1 ! pj (:) = 0 ! pj ( iMode1 ) = pj0s ( ii , 1 ) * ( - 1 ) ** ( pms ( iDes , 1 - 1 )) pj ( iMode2 ) = pj0s ( ii , 2 ) * ( - 1 ) ** ( pms ( iDes , 2 - 1 )) pj ( iMode3 ) = pj0s ( ii , 3 ) * ( - 1 ) ** ( pms ( iDes , 3 - 1 )) ! call lsfOfConfigurationPj () ! enddo ! enddo ! enddo enddo enddo ! deallocate ( pj0s , pms ) ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using three bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyThreeBands ! ! subroutine writeLSFandCrossSection () ! implicit none ! integer :: iE real ( kind = dp ) :: E !, vg ! open ( 1 , file = 'lsfVsE' , status = 'unknown' ) ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) ! !write(1,'(F16.8,2E18.6e3)') E*HartreeToEv, lsfVsE(iE), twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg write ( 1 , '(F16.8,E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ) !, twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! enddo ! close ( 1 ) ! return ! end subroutine writeLSFandCrossSection ! ! subroutine init_random_seed () ! implicit none ! integer ( kind = int32 ), allocatable :: seed (:) integer ( kind = int32 ) :: n !, i, n, dt(8), pid integer :: t ! call random_seed ( size = n ) ! allocate ( seed ( n )) ! ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. ! call system_clock ( t ) ! seed = 5347 ! !    if (t == 0) then !      call date_and_time(values=dt) !      t = (dt(1) - 1970) * 365 * 24 * 60 * 60 * 1000 & !          + dt(2) * 31 * 24 * 60 * 60 * 1000 & !          + dt(3) * 24 * 60 * 60 * 1000 & !          + dt(5) * 60 * 60 * 1000 & !          + dt(6) * 60 * 1000 + dt(7) * 1000 & !          + dt(8) !    end if !    pid = getpid() !    t = ieor(t, int(pid, kind(t))) !    do i = 1, n !      seed(i) = lcg(t) !    end do !    ! call random_seed ( put = seed ) ! end subroutine init_random_seed ! ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. ! integer function lcg ( s ) ! integer :: s ! if ( s == 0 ) then s = 104729 else !s = mod(s, 4294967296) s = mod ( s , 4294967 ) end if ! !s = mod(s * 279470273, 4294967291) s = mod ( s * 279470273 , 4294967 ) ! lcg = int ( mod ( s , huge ( 0 )), kind ( 0 )) ! end function lcg ! ! subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !c*********************************************************************72 !c !cc IKNB compute Bessel function In(x) and Kn(x). !c !c  Discussion: !c !c    Compute modified Bessel functions In(x) and Kn(x), !c    and their derivatives. !c !c  Licensing: !c !c    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !c    they give permission to incorporate this routine into a user program !c    provided that the copyright is acknowledged. !c !c  Modified: !c !c    17 July 2012 !c !c  Author: !c !c    Shanjie Zhang, Jianming Jin !c !c  Reference: !c !c    Shanjie Zhang, Jianming Jin, !c    Computation of Special Functions, !c    Wiley, 1996, !c    ISBN: 0-471-11963-6, !c    LC: QA351.C45. !c !c  Parameters: !c !c    Input, integer N, the order of In(x) and Kn(x). !c !c    Input, double precision X, the argument. !c !c    Output, integer NM, the highest order computed. !c !c    Output, double precision BI(0:N), DI(0:N), BK(0:N), DK(0:N), !c    the values of In(x), In'(x), Kn(x), Kn'(x). !c implicit none integer , intent ( in ) :: n !      double precision :: a0 double precision :: bi ( 0 : n ) !      double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: f0 double precision :: f1 !      double precision :: g !      double precision :: g0 !      double precision :: g1 integer :: k !      integer :: k0 !      integer :: l integer :: m , ik !      integer :: msta1 !      integer :: msta2 integer :: nm double precision :: pi !      double precision :: r double precision :: s0 double precision :: sk0 !      double precision :: vt double precision :: x , ifact pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n if ( x . le . 1.0D-15 ) then do k = 0 , n ifact = 1.0_dp do ik = 2 , k ifact = ifact * ik enddo bi ( k ) = ( 0.5_dp * x ) ** k / ifact end do return end if if ( n . eq . 0 ) then nm = 1 end if m = msta1 ( x , 200 ) if ( m . lt . nm ) then nm = m else m = msta2 ( x , nm , 15 ) end if bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 if ( k . le . nm ) then bi ( k ) = f end if if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then sk0 = sk0 + 4.0D+00 * f / k end if bs = bs + 2.0D+00 * f f0 = f1 f1 = f end do s0 = exp ( x ) / ( bs - f ) do k = 0 , nm bi ( k ) = s0 * bi ( k ) end do return end SUBROUTINE iknb ! ! SUBROUTINE iknb2 ( n , x , nm , bi , di , bk , dk ) ! !    ============================================================ !    Purpose: Compute modified Bessel functions In(x) and Kn(x), !             and their derivatives !    Input:   x --- Argument of In(x) and Kn(x) ( 0 ó x ó 700 ) !             n --- Order of In(x) and Kn(x) !    Output:  BI(n) --- In(x) !             DI(n) --- In'(x) !             BK(n) --- Kn(x) !             DK(n) --- Kn'(x) !             NM --- Highest order computed !    Routines called: !             MSTA1 and MSTA2 for computing the starting point !             for backward recurrence !    =========================================================== ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( OUT ) :: nm REAL ( dp ), INTENT ( OUT ) :: bi ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: di ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: bk ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: dk ( 0 : n ) ! REAL ( dp ), PARAMETER :: pi = 3.141592653589793_dp , el = 0.5772156649015329_dp REAL ( dp ) :: a0 , bkl , bs , f , f0 , f1 , g , g0 , g1 , r , s0 , sk0 , vt INTEGER :: k , k0 , l , m ! nm = n IF ( x <= 1.0D-50 ) THEN DO k = 0 , n bi ( k ) = 0.0D0 di ( k ) = 0.0D0 bk ( k ) = 1.0D+300 dk ( k ) = - 1.0D+300 END DO bi ( 0 ) = 1.0D0 di ( 1 ) = 0.5D0 RETURN END IF IF ( n == 0 ) nm = 1 m = msta1 ( x , 200 ) IF ( m < nm ) THEN nm = m ELSE m = msta2 ( x , nm , 15 ) END IF !write(6,*)'mmmmmmmmm', m bs = 0.0D0 sk0 = 0.0D0 f0 = 0.0D0 f1 = 1.0D-100 DO k = m , 0 , - 1 f = 2 * ( k + 1 ) / x * f1 + f0 IF ( k <= nm ) bi ( k ) = f IF ( k /= 0 . AND . k == 2 * INT ( k / 2 )) sk0 = sk0 + 4.0D0 * f / k bs = bs + 2.0D0 * f f0 = f1 f1 = f END DO !s0 = EXP(x) / (bs-f) !write(6,*) f, f1 s0 = EXP ( x ) / ( bs - f1 ) bi ( 0 : nm ) = s0 * bi ( 0 : nm ) IF ( x <= 8.0D0 ) THEN bk ( 0 ) = - ( LOG ( 0.5D0 * x ) + el ) * bi ( 0 ) + s0 * sk0 bk ( 1 ) = ( 1.0D0 / x - bi ( 1 ) * bk ( 0 )) / bi ( 0 ) ELSE a0 = SQRT ( pi / ( 2.0D0 * x )) * EXP ( - x ) k0 = 16 IF ( x >= 2 5.0 ) k0 = 10 IF ( x >= 8 0.0 ) k0 = 8 IF ( x >= 20 0.0 ) k0 = 6 DO l = 0 , 1 bkl = 1.0D0 vt = 4 * l r = 1.0D0 DO k = 1 , k0 r = 0.125D0 * r * ( vt - ( 2 * k - 1 ) ** 2 ) / ( k * x ) bkl = bkl + r END DO bk ( l ) = a0 * bkl END DO END IF g0 = bk ( 0 ) g1 = bk ( 1 ) DO k = 2 , nm g = 2 * ( k - 1 ) / x * g1 + g0 bk ( k ) = g g0 = g1 g1 = g END DO di ( 0 ) = bi ( 1 ) dk ( 0 ) = - bk ( 1 ) DO k = 1 , nm di ( k ) = bi ( k - 1 ) - k / x * bi ( k ) dk ( k ) = - bk ( k - 1 ) - k / x * bk ( k ) END DO RETURN ! END SUBROUTINE iknb2 ! ! FUNCTION msta1 ( x , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that the magnitude of !                Jn(x) at that point is about 10&#94;(-MP) !       Input :  x     --- Argument of Jn(x) !                MP    --- Value of magnitude !       Output:  MSTA1 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , f , f0 , f1 INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) n0 = INT ( 1.1 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - mp IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn ! RETURN ! END FUNCTION msta1 ! ! FUNCTION msta2 ( x , n , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that all Jn(x) has MP !                significant digits !       Input :  x  --- Argument of Jn(x) !                n  --- Order of Jn(x) !                MP --- Significant digit !       Output:  MSTA2 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) hmp = 0.5_dp * mp ejn = envj ( n , a0 ) IF ( ejn <= hmp ) THEN obj = mp n0 = INT ( 1.1 * a0 ) ELSE obj = hmp + ejn n0 = n END IF !!!!!!!! if ( n0 < 1 ) n0 = 1 !!!!!!!! f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj ! DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - obj IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn + 10 ! RETURN ! END FUNCTION msta2 ! ! FUNCTION envj ( n , x ) RESULT ( fn_val ) ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val ! fn_val = 0.5_dp * LOG10 ( 6.28_dp * n ) - n * LOG10 ( 1.36_dp * x / n ) ! RETURN ! END FUNCTION envj ! ! subroutine parallelIsFsBy3 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = nModes / 6.0_dp totalStates = totalStates * ( nModes - 1 ) * ( nModes - 2 ) ! !write(iostd, *) 'totalStates', totalStates if ( nModes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = nModes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) / 2.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 2.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = nModes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = nModes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = nModes - 2 ! else ! nProcMax = nModes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy3 ! ! subroutine parallelIsFsBy4 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = nModes / 2 4.0_dp totalStates = totalStates * ( nModes - 1 ) * ( nModes - 2 ) * ( nModes - 3 ) ! !write(iostd, *) 'totalStates', totalStates if ( nModes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = nModes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 6.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) * real ( iState - 4 , dp ) / 6.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = nModes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = nModes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = nModes - 2 ! else ! nProcMax = nModes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy4 ! ! end module lsf","tags":"","loc":"sourcefile/lsf_zeroth_module_v35.f90.html","title":"LSF_zeroth_Module_v35.f90 – Carrier Cross Sections"},{"text":"Contents Programs lineShapeFunction Source Code LSF_linear_Main.f90 Source Code program lineShapeFunction ! use mpi use lsf ! implicit none ! call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! if ( myid == root ) then ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call readPhonons () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call readMjs () ! call initializeLSF () ! endif ! call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( modes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !    allocate( Vfis(-nEnergies:nEnergies) ) endif ! call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( s2L , size ( s2L ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) !  call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( myid == root ) then ! !if ( maximumNumberOfPhonons > 0 ) then if ( ( minimumNumberOfPhonons < 2 ) . and . ( maximumNumberOfPhonons > 0 ) . and . ( modes > 0 ) ) then ! ! One phonon ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call lsfMbyOneBand ( 1 ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 1 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 1 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 1 , file = 'lsfVsEwithUpTo1phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 1 ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 1 ) ! endif ! if ( ( minimumNumberOfPhonons < 3 ) . and . ( maximumNumberOfPhonons > 1 ) . and . ( modes > 1 ) ) then ! ! Two phonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call cpu_time ( t1 ) ! call lsfMbyOneBand ( 2 ) call lsfMbyTwoBands ( 2 ) ! call cpu_time ( t2 ) ! write ( iostd , '(\" 2 modes, time needed :,\" , f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 2 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 2 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 2 , file = 'lsfVsEwithUpTo2phonons' , status = 'unknown' ) ! !      write(2,'(\"# \", i5, \" phonons\")') 2 write ( 2 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 2 do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 2 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 2 ) ! endif ! !   call lsfDeterministicOneAndTwoBands() ! !deallocate ( lsfVsEbyPhonons ) ! endif ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! !if ( maximumNumberOfPhonons > 2 ) then if ( ( minimumNumberOfPhonons < 4 ) . and . ( maximumNumberOfPhonons > 2 ) . and . ( modes > 2 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then ! call lsfMbyOneBand ( 3 ) call lsfMbyTwoBands ( 3 ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 3 ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 3 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 3 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo3phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 3 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 3 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! !if ( maximumNumberOfPhonons > 3 ) then if ( ( minimumNumberOfPhonons < 5 ) . and . ( maximumNumberOfPhonons > 3 ) . and . ( modes > 3 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( 4 ) call lsfMbyTwoBands ( 4 ) ! call parallelIsFsBy3 () ! !write(6,*) '3' !do i = 0, nProcMax - 1 !  write(6,*) i, iModeIs(i), iModeFs(i) !enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 4 ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !if ( myid == root ) then !  write(6,*) '4' !  do i = 0, nProcMax - 1 !    write(6,*) i, iModeIs(i), iModeFs(i) !  enddo !endif ! call lsfDeterministicFourPhononsByFourBands () ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 4 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 4 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo4phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 4 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 4 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! if ( ( maximumNumberOfPhonons > 4 ) . and . ( modes > 4 ) ) then !if ( ( minimumNumberOfPhonons < 6 ) .and. ( maximumNumberOfPhonons > 4 ) ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then if ( istat /= 0 ) then write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' else write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' endif flush ( iostd ) endif ! if ( istat /= 0 ) close ( un ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) allocate ( lsfbyPhononsPerProc ( - nEnergies : nEnergies ) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC do i = numprocs - 1 , 1 , - 1 iModeIs ( i ) = i * iMint + 1 if ( iMmod > 0 ) then iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 endif iModeFs ( i - 1 ) = iModeIs ( i ) - 1 enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 do ni = m - 1 , m - l + 1 , - 1 times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = modes ! do iMode = 2 , l weight = weight * ( modes - iMode + 1 ) / iMode enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m elseif ( m < 100 ) then write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m elseif ( m < 1000 ) then write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m else write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !        write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de enddo close ( 5000 ) ! endif ! enddo ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"sourcefile/lsf_linear_main.f90.html","title":"LSF_linear_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules lsf Source Code LSF_linear_Module_v1.f90 Source Code module lsf ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: iostd = 16 , un = 3 integer , parameter :: root = 0 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: THzToHartree = 1.0_dp / 657 9.683920729_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer ( kind = int32 ) :: myid , numprocs , ios , istat , ierr integer :: iMode , l , m , nMC , nProcMax integer :: iMint , iMmod , i , printsteps , iE , ni , mi integer :: nAtoms , nOfqPoints , nModes , minimumNumberOfPhonons , maximumNumberOfPhonons , nEnergies ! real ( kind = dp ) :: ti , tf , t1 , t2 real ( kind = dp ) :: weight , times , de , E ! , vg real ( kind = dp ) :: temperature , maxEnergy , deltaE , kT ! , volume ! integer , allocatable :: iModeIs (:), iModeFs (:) integer , allocatable :: pj (:), pj0s (:,:), pms (:,:), s2L (:) integer , allocatable :: iEbinsByBands (:), iEbinsByPhonons (:) ! real ( kind = dp ), allocatable :: atomD (:,:), atomM (:), phonQ (:,:), phonF (:), genCoord (:), Mjs (:,:) real ( kind = dp ), allocatable :: wby2kT (:), phonD (:,:,:,:), x (:), Sj (:), coth (:), besOrderNofModeM (:,:) real ( kind = dp ), allocatable :: lsfVsEbyBands (:), lsfVsE (:), lsfVsEbyPhonons (:), lsfbyPhononsPerProc (:) ! integer :: modes ! character ( len = 6 ), parameter :: output = 'status' !  character(len = 256) :: MjsInput, PhononsInput, crossSectionOutput, fn, continueLSFfromFile character ( len = 256 ) :: MjsInput , phononsInput , fn , continueLSFfromFile , equilibriumAtomicPositions ! logical :: file_exists ! !  namelist /elphscat/ MjsInput, PhononsInput, crossSectionOutput, temperature, maxEnergy, continueLSFfromFile, volume, & namelist / lsfInput / MjsInput , equilibriumAtomicPositions , phononsInput , & continueLSFfromFile , maximumNumberOfPhonons , nMC , & temperature , maxEnergy , & modes ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if file output exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , lsfInput , iostat = ios ) ! call checkAndUpdateInput () ! return ! end subroutine readInputs ! ! subroutine initializeLSF () ! implicit none ! real ( kind = dp ) :: dummyD integer :: dummyI character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! allocate ( lsfVsE ( - nEnergies : nEnergies ) ) ! minimumNumberOfPhonons = 1 lsfVsE (:) = 0.0_dp ! if ( continueLSFfromFile /= '' ) then ! inquire ( file = trim ( continueLSFfromFile ), exist = file_exists ) if ( file_exists ) then ! open ( unit = 11 , file = trim ( continueLSFfromFile ), status = \"old\" ) ! read ( 11 , '(a1, i10, a9, i5, a8)' ) dummyC1 , dummyI , dummyC9 , minimumNumberOfPhonons , dummyC8 ! minimumNumberOfPhonons = minimumNumberOfPhonons + 1 write ( iostd , '(\" Minimum number of phonons : \", i5)' ) minimumNumberOfPhonons ! do iE = - nEnergies , nEnergies read ( 11 , * ) dummyD , lsfVsE ( iE ) enddo close ( 11 ) ! endif endif ! return ! end subroutine initializeLSF ! ! subroutine initialize () ! implicit none ! MjsInput = '' phononsInput = '' !crossSectionOutput = '' temperature = - 1.0_dp deltaE = - 1.0_dp minimumNumberOfPhonons = 1 maximumNumberOfPhonons = - 1 nMC = - 1 modes = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () ! implicit none ! logical :: abortExecution = . false . ! if ( MjsInput == '' ) then write ( iostd , '(\" MjsInput is not defined!\")' ) write ( iostd , '(\" A default value will be used. MjsInput = VfisVsE\")' ) MjsInput = 'VfisVsE' else write ( iostd , '(\" Mjs elements input : \", a)' ) trim ( MjsInput ) endif ! if ( phononsInput == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( PhononsInput ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Tempetature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324d-5 * eVToHartree endif ! !    if ( deltaE < 0 ) then !      write(iostd, '(\" Variable deltaE has not been set.\")') !    else !      write(iostd, '(\" DeltaE : \", f10.5, \" eV.\")') deltaE !      deltaE = deltaE*eVToHartree !    endif ! if ( maximumNumberOfPhonons < 0 ) then write ( iostd , '(\" Variable maximumNumberOfPhonons has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum number of phonons : \", i5)' ) maximumNumberOfPhonons endif if ( nMC < 0 ) then write ( iostd , '(\" Variable nMC has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Number of Monte Carlo steps : \", i15)' ) nMC endif ! if ( modes < 0 ) then write ( iostd , '(\" Variable modes has not been set.\")' ) write ( iostd , '(\" All modes will be used.\")' ) endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! maxEnergy = 1 0.0_dp * eVToHartree ! nEnergies = 5040 ! 2520 ! 10080 deltaE = maxEnergy / real ( nEnergies , dp ) ! write ( iostd , * ) 'nEnergies' , nEnergies write ( iostd , * ) 'maxEnergy' , maxEnergy , 'deltaE' , deltaE ! flush ( iostd ) ! return ! end subroutine checkAndUpdateInput ! ! subroutine readPhonons () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! !write(6,*) trim(PhononsInput) open ( 1 , file = trim ( PhononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms ! nModes = 3 * nAtoms - 3 ! write ( iostd , '(\" Number of atoms    : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes    : \", i5)' ) nModes if ( modes < 0 ) then modes = nModes write ( iostd , '(\" Number of modes to be used : \", i5)' ) modes endif flush ( iostd ) ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhonons ! ! subroutine computeGeneralizedDisplacements () ! implicit none ! integer :: iq , iMode , iAtom ! allocate ( genCoord ( nModes ) ) ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) ! enddo ! enddo ! enddo ! !    open(11, file='generalizedDisplacements', status='unknown') !    ! !    write(11, '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2\")') !    ! !    do iMode = 1, nModes !     write(11, '(i4,1x,3E20.10E3)') iMode, phonF(iMode)*1.0e3_dp*HartreeToEv, genCoord(iMode), genCoord(iMode)*genCoord(iMode) !    enddo !    ! !    close(11) ! deallocate ( atomM , phonD , atomD ) ! return ! end subroutine computeGeneralizedDisplacements ! ! subroutine computeVariables () ! implicit none ! integer :: i , j , nm , nb ! real ( kind = dp ), allocatable :: bi (:), di (:), bk (:), dk (:) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) ! x = 0.0_dp Sj = 0.0_dp coth = 0.0_dp wby2kT = 0.0_dp ! Sj (:) = 0.5_dp * phonF (:) * genCoord (:) * genCoord (:) wby2kT (:) = phonF (:) / ( 2.0_dp * kT ) coth (:) = cosh ( wby2kT (:)) / sinh ( wby2kT (:)) x (:) = Sj (:) / sinh ( wby2kT (:)) ! allocate ( s2L ( nModes ) ) s2L (:) = 0 ! do iMode = 1 , nModes s2L ( iMode ) = iMode enddo ! call arrangeLargerToSmaller () ! open ( 11 , file = 'modes' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2,  Sj/sinh(wby2kT)\")' ) ! do iMode = 1 , nModes ! write ( 11 , '(i4,1x,4E20.10E3)' ) s2L ( iMode ), phonF ( s2L ( iMode )) * 1.0e3_dp * HartreeToEv , & genCoord ( s2L ( iMode )), genCoord ( s2L ( iMode )) ** 2 , x ( s2L ( iMode )) ! enddo ! close ( 11 ) ! deallocate ( genCoord ) ! nb = maximumNumberOfPhonons allocate ( besOrderNofModeM ( 0 : nb + 1 , nModes ) ) allocate ( bi ( 0 : nb + 1 ), di ( 0 : nb + 1 ) ) allocate ( bk ( 0 : nb + 1 ), dk ( 0 : nb + 1 ) ) ! do j = 1 , nModes ! bi (:) = 0.0_dp ! nm = nb + 1 call iknb ( nb + 1 , x ( j ), nm , bi ) ! , di, bk, dk) ! do i = 0 , nb + 1 ! besOrderNofModeM ( i , j ) = bi ( i ) ! enddo ! !write(6,*) j, x(j) !, (besOrderNofModeM(i,j), i = 0, 5) ! nb + 1) !, phonF(j) ! enddo ! return ! end subroutine computeVariables ! ! subroutine arrangeLargerToSmaller () ! implicit none ! integer :: i , iMode ! real ( kind = dp ), allocatable :: temp (:) real ( kind = dp ) :: tmpr integer :: tmpi ! allocate ( temp ( nModes ) ) ! temp (:) = 0.0_dp temp (:) = x (:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! if ( exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! !          tmpi = s2L(i) !          s2L(i) = s2L(i+1) !          s2L(i+1) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! tmpr = Sj ( i ) Sj ( i ) = Sj ( i + 1 ) Sj ( i + 1 ) = tmpr ! tmpr = x ( i ) x ( i ) = x ( i + 1 ) x ( i + 1 ) = tmpr ! tmpr = coth ( i ) coth ( i ) = coth ( i + 1 ) coth ( i + 1 ) = tmpr ! tmpr = wby2kT ( i ) wby2kT ( i ) = wby2kT ( i + 1 ) wby2kT ( i + 1 ) = tmpr ! tmpr = phonF ( i ) phonF ( i ) = phonF ( i + 1 ) phonF ( i + 1 ) = tmpr ! endif ! enddo ! enddo ! deallocate ( temp ) ! return ! end subroutine arrangeLargerToSmaller ! ! subroutine readMjs () ! implicit none ! integer :: i , iE0 , iE , numOfMjs real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , MjOfE , MjOfE0 , eBin , DHifMin , eifMin , volume character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 character ( len = 256 ) :: modeFolder ! allocate ( Mjs ( modes , - nEnergies : nEnergies ) ) ! Mjs (:,:) = 0.0_dp ! do iMode = 1 , modes ! if ( s2L ( iMode ) < 10 ) then write ( modeFolder , '(\"mode_\", i1, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 100 ) then write ( modeFolder , '(\"mode_\", i2, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 1000 ) then write ( modeFolder , '(\"mode_\", i3, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 10000 ) then write ( modeFolder , '(\"mode_\", i4, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) endif ! ! inquire ( file = trim ( modeFolder ), exist = file_exists ) if ( . not . file_exists ) then ! write ( iostd , '(\" File : \", a, \" does not exist!\")' ) trim ( modeFolder ) ! else ! write ( iostd , '(\" Reading file : \", a)' ) trim ( modeFolder ) ! open ( 1 , file = trim ( modeFolder ), status = \"old\" ) ! read ( 1 , * ) read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 read ( 1 , * ) ! read ( 1 , '(i10)' ) numOfMjs ! read ( 1 , '(3ES24.15E3)' ) Ee , MjOfE0 , dummyD1 ! Mjs ( iMode , 1 ) = MjOfE0 !energy(1) = Ee ! iE = int ( Ee / de ) + 1 ! do i = 2 , numOfMjs ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE read ( 1 , '(3ES24.15E3)' ) Ee , MjOfE , dummyD2 !          energy(i) = Ee iE = int ( Ee / de ) + 1 !Vfis(iE0:iE) = VfiOfE0 Mjs ( iMode , i ) = MjOfE !VfiOfE0 = VfiOfE ! write ( 6 , * ) iMode , Mjs ( iMode , i ) enddo ! close ( 1 ) ! endif ! enddo ! !do iE = 0, numOfVfis ! -nEnergies, nEnergies !  write(44,*) energy(iE)*HartreeToEv, Vfis(iE), lsf(iE) !enddo ! !close(44) ! return ! end subroutine readMjs ! ! subroutine lsfDeterministicFourPhononsByFourBands () ! implicit none ! integer :: ic integer :: iMode1 , iMode2 , iMode3 , iMode4 integer :: pm1 , pm2 , pm3 , pm4 ! real ( kind = dp ) :: t1 , t2 ! if ( myid == root ) then write ( iostd , * ) 'Four modes' flush ( iostd ) endif ! ! Four modes ! call cpu_time ( t1 ) ! ic = 0 do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , modes - 2 do iMode3 = iMode2 + 1 , modes - 1 do iMode4 = iMode3 + 1 , modes ! do pm1 = - 1 , 1 , 2 do pm2 = - 1 , 1 , 2 do pm3 = - 1 , 1 , 2 do pm4 = - 1 , 1 , 2 ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 pj ( s2L ( iMode2 )) = pm2 pj ( s2L ( iMode3 )) = pm3 pj ( s2L ( iMode4 )) = pm4 ! call lsfOfConfigurationPj () ! ic = ic + 1 ! enddo enddo enddo enddo ! enddo enddo enddo enddo ! call cpu_time ( t2 ) ! return ! end subroutine lsfDeterministicFourPhononsByFourBands ! ! subroutine lsfOfConfigurationPj () ! implicit none ! integer :: iE , j ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio ! prodFj = 1.0_dp sumOverj = 0.0_dp do j = 1 , modes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( s2L ( j ))), s2L ( j )) if ( pj ( s2L ( j )) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj endif prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( s2L ( j )) / ( abs ( pj ( s2L ( j ))) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( s2L ( j ))) + 1 , s2L ( j )) / besPj sumOverj = sumOverj + ( abs ( pj ( s2L ( j ))) + x ( s2L ( j )) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! return ! end subroutine lsfOfConfigurationPj ! ! subroutine calculatePlusMinusStates ( l ) ! implicit none ! integer , intent ( in ) :: l ! integer :: iDes , other ( 0 : l - 1 ) ! do iDes = 0 , 2 ** l - 1 ! other (:) = 0 ! call decimalToOther ( iDes , l , 2 , other ) ! pms ( iDes ,:) = other (:) ! enddo ! return ! end subroutine calculatePlusMinusStates ! ! subroutine distrubutePhononsInBands ( m , l ) ! implicit none ! integer , intent ( in ) :: m , l ! integer :: i , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 , i11 , i12 ! if ( l == 1 ) then ! pj0s ( 1 , 1 ) = m ! else if ( l == m - 1 ) then ! do i = 1 , l pj0s ( i ,:) = 1 pj0s ( i , i ) = m - ( l - 1 ) enddo ! else if ( l == m ) then ! pj0s ( 1 ,:) = 1 ! else if ( l == 2 ) then ! do i = 1 , m - 1 ! pj0s ( i , 1 ) = i pj0s ( i , 2 ) = m - i ! enddo ! else if ( l == 3 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 ! i = i + 1 ! endif ! enddo enddo enddo ! !write(6,*) 'l = 3, i = ', i - 1 ! else if ( l == 4 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 ! i = i + 1 ! endif ! enddo enddo enddo enddo !write(6,*) 'l = 4, i = ', i - 1 ! else if ( l == 5 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo ! !write(6,*) 'l = 5, i = ', i - 1 ! else if ( l == 6 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 6, i = ', i - 1 ! else if ( l == 7 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 7, i = ', i ! else if ( l == 8 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 8, i = ', i ! else if ( l == 9 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 10 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 11 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 12 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) do i12 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 + i12 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 pj0s ( i , 12 ) = i12 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo endif ! return ! end subroutine distrubutePhononsInBands ! ! subroutine lsfWithMphonons ( m , l , tTimes ) ! implicit none ! integer , intent ( in ) :: m , l , tTimes ! integer :: ii ! integer :: iMC , iM , i , pick , j , picks ( l ), iE , iDes , iRand , steps ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio , randy ! logical :: picked ! if ( myid == root ) then write ( iostd , '(i4,\" phonons by\", i3, \" bands started.\")' ) m , l flush ( iostd ) endif ! printSteps = int ( ( iModeFs ( myid ) - iModeIs ( myid ) + 1.01_dp ) / 10 ) ! do iMC = iModeIs ( myid ), iModeFs ( myid ) ! if ( mod ( iMC - iModeIs ( myid ) + 1 , printSteps ) == 0 ) then if ( myid == root ) then steps = iModeFs ( myid ) - iModeIs ( myid ) + 1 write ( iostd , '(i4,\" phonons by\", i3,\" bands.\", i12,\" over \",i12,\" MC iters per processor done.\")' ) m , l , iMC , steps flush ( iostd ) endif endif ! picks (:) = 0 ! if ( istat == 0 ) then ! do iM = 1 , l picked = . false . 10 read ( un ) iRand iRand = mod ( abs ( iRand ), modes ) + 1 do i = 1 , iM - 1 if ( picks ( i ) == iRand ) goto 10 enddo picks ( iM ) = iRand ! enddo ! else ! do iM = 1 , l picked = . false . ! 11 CALL RANDOM_NUMBER ( randy ) ! pick = int ( modes * randy ) + 1 do i = 1 , l if ( pick . eq . picks ( i ) ) picked = . true . enddo if ( picked ) goto 11 picks ( iM ) = pick enddo ! endif ! do ii = 1 , tTimes ! do iDes = 0 , 2 ** l - 1 ! pj (:) = 0 ! do iM = 1 , l pj ( s2L ( picks ( iM ))) = pj0s ( ii , iM ) * ( - 1 ) ** ( pms ( iDes , iM - 1 )) enddo ! if ( abs ( sum ( abs ( pj ( picks (:)))) - m ) > 0 ) then if ( myid == root ) then write ( iostd , * ) 'ERROR' , m , sum ( abs ( pj ( s2L ( picks (:))))), pj ( s2L ( picks (:))) do iM = 1 , l if ( abs ( pj ( picks ( iM ))) < 1 ) then write ( iostd , * ) 'ERROR 1' , picks ( iM ) write ( iostd , * ) 'ERROR 2' , pj ( s2L ( picks ( iM ))) flush ( iostd ) endif enddo endif endif ! prodFj = 1.0_dp sumOverj = 0.0_dp ! do j = 1 , modes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( s2L ( j ))), s2L ( j )) if ( pj ( s2L ( j )) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj endif ! prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( s2L ( j )) / ( abs ( pj ( s2L ( j ))) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( s2L ( j ))) + 1 , s2L ( j )) / besPj ! sumOverj = sumOverj + ( abs ( pj ( s2L ( j ))) + x ( s2L ( j )) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) ! iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! enddo ! enddo ! enddo ! if ( myid == root ) then write ( iostd , '(\"---------------------------------------------\")' ) write ( iostd , '(i4,\" phonons by\", i3, \" bands done.\")' ) m , l flush ( iostd ) endif ! return ! end subroutine lsfWithMphonons ! ! subroutine decimalToOther ( iDec , n , iBase , other ) ! implicit none ! integer , intent ( in ) :: n , iBase integer :: iDec , m integer :: other ( 0 : n - 1 ), j ! m = iDec do j = n - 1 , 1 , - 1 other ( j ) = int ( m / ( iBase ** j )) m = mod ( iDec , iBase ** j ) enddo other ( 0 ) = mod ( m , iBase ) ! return ! end subroutine decimalToOther ! ! subroutine calculateDE ( maxM , iEbins , de ) ! implicit none ! integer , intent ( in ) :: maxM , iEbins ( - nEnergies : nEnergies ) real ( dp ), intent ( out ) :: de ! integer :: iE , j , ic , ib , iEmMax , nSteps , jMax , iEstep ! integer , allocatable :: tmpB (:), iEsteps (:) ! logical :: empty ! allocate ( tmpB ( nEnergies ) ) ! ic = 1 do j = 1 , nEnergies if ( mod ( nEnergies , j ) == 0 ) then tmpB ( ic ) = int (( dble ( nEnergies ) + 1.e-8_dp ) / j ) ic = ic + 1 endif enddo ! nSteps = ic - 1 allocate ( iEsteps ( nSteps ) ) iEsteps (:) = tmpB ( nSteps : 1 : - 1 ) deallocate ( tmpB ) ! iEmMax = int ( maxM * maxval ( phonF (:)) / deltaE ) + 1 ! j = 1 do while ( ( iEmMax > iEsteps ( j ) ) . and . ( j < nSteps ) ) j = j + 1 enddo ! jMax = j - 1 if ( jMax > nSteps ) jMax = nSteps ! empty = . true . j = jMax do while ( ( empty . eqv . . true . ) . and . ( j > 1 ) ) ! empty = . true . iEstep = iEsteps ( j ) do iE = 1 , iEmMax - 1 , iEstep ib = sum ( iEbins ( iE : iE + iEstep - 1 ) ) if ( ib < 1 ) then empty = . false . endif enddo j = j - 1 ! enddo ! j = j + 2 ! iEstep = iEsteps ( j ) de = deltaE * real ( iEstep , dp ) ! deallocate ( iEsteps ) ! return ! end subroutine calculateDE ! ! subroutine lsfMbyOneBand ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , pm1 ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do iMode1 = 1 , modes ! do pm1 = - m , m , 2 * m ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 ! call lsfOfConfigurationPj () ! enddo ! enddo ! call cpu_time ( t2 ) ! write ( iostd , '(\" LSF of: \", i4, \" phonons using one band done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) ! return ! end subroutine lsfMbyOneBand ! ! subroutine lsfMbyTwoBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , iMode2 , pm1 , pm2 , l ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do l = 1 , m - 1 ! do iMode1 = 1 , modes - 1 do iMode2 = iMode1 + 1 , modes ! do pm1 = - l , l , 2 * l do pm2 = - ( m - l ), ( m - l ), 2 * ( m - l ) ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 pj ( s2L ( iMode2 )) = pm2 ! call lsfOfConfigurationPj () ! enddo enddo ! enddo enddo ! enddo ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using two bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyTwoBands ! ! subroutine lsfMbyThreeBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! real ( dp ) :: t1 , t2 , times3 integer :: iMode1 , iMode2 , iMode3 , ni , mi , iDes , ii ! call cpu_time ( t1 ) ! times3 = 1.0_dp mi = 2 do ni = m - 1 , m - 3 + 1 , - 1 times3 = times3 * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times3 + 1.e-3_dp ), 3 ) ) pj0s (:,:) = 0 ! call distrubutePhononsInBands ( m , 3 ) ! allocate ( pms ( 0 : 2 ** 3 - 1 , 0 : 3 - 1 ) ) pms (:,:) = 0 ! call calculatePlusMinusStates ( 3 ) ! do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , modes - 1 do iMode3 = iMode2 + 1 , modes ! do ii = 1 , int ( times3 + 1.e-3_dp ) ! do iDes = 0 , 2 ** 3 - 1 ! pj (:) = 0 ! pj ( s2L ( iMode1 )) = pj0s ( ii , 1 ) * ( - 1 ) ** ( pms ( iDes , 1 - 1 )) pj ( s2L ( iMode2 )) = pj0s ( ii , 2 ) * ( - 1 ) ** ( pms ( iDes , 2 - 1 )) pj ( s2L ( iMode3 )) = pj0s ( ii , 3 ) * ( - 1 ) ** ( pms ( iDes , 3 - 1 )) ! call lsfOfConfigurationPj () ! enddo ! enddo ! enddo enddo enddo ! deallocate ( pj0s , pms ) ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using three bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyThreeBands ! ! subroutine writeLSFandCrossSection () ! implicit none ! integer :: iE real ( kind = dp ) :: E !, vg ! open ( 1 , file = 'lsfVsE' , status = 'unknown' ) ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) ! !write(1,'(F16.8,2E18.6e3)') E*HartreeToEv, lsfVsE(iE), twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg write ( 1 , '(F16.8,E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ) !, twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! enddo ! close ( 1 ) ! return ! end subroutine writeLSFandCrossSection ! ! subroutine init_random_seed () ! implicit none ! integer ( kind = int32 ), allocatable :: seed (:) integer ( kind = int32 ) :: n !, i, n, dt(8), pid integer :: t ! call random_seed ( size = n ) ! allocate ( seed ( n )) ! ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. ! call system_clock ( t ) ! seed = 5347 ! !    if (t == 0) then !      call date_and_time(values=dt) !      t = (dt(1) - 1970) * 365 * 24 * 60 * 60 * 1000 & !          + dt(2) * 31 * 24 * 60 * 60 * 1000 & !          + dt(3) * 24 * 60 * 60 * 1000 & !          + dt(5) * 60 * 60 * 1000 & !          + dt(6) * 60 * 1000 + dt(7) * 1000 & !          + dt(8) !    end if !    pid = getpid() !    t = ieor(t, int(pid, kind(t))) !    do i = 1, n !      seed(i) = lcg(t) !    end do !    ! call random_seed ( put = seed ) ! end subroutine init_random_seed ! ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. ! integer function lcg ( s ) ! integer :: s ! if ( s == 0 ) then s = 104729 else !s = mod(s, 4294967296) s = mod ( s , 4294967 ) end if ! !s = mod(s * 279470273, 4294967291) s = mod ( s * 279470273 , 4294967 ) ! lcg = int ( mod ( s , huge ( 0 )), kind ( 0 )) ! end function lcg ! ! subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !c*********************************************************************72 !c !cc IKNB compute Bessel function In(x) and Kn(x). !c !c  Discussion: !c !c    Compute modified Bessel functions In(x) and Kn(x), !c    and their derivatives. !c !c  Licensing: !c !c    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !c    they give permission to incorporate this routine into a user program !c    provided that the copyright is acknowledged. !c !c  Modified: !c !c    17 July 2012 !c !c  Author: !c !c    Shanjie Zhang, Jianming Jin !c !c  Reference: !c !c    Shanjie Zhang, Jianming Jin, !c    Computation of Special Functions, !c    Wiley, 1996, !c    ISBN: 0-471-11963-6, !c    LC: QA351.C45. !c !c  Parameters: !c !c    Input, integer N, the order of In(x) and Kn(x). !c !c    Input, double precision X, the argument. !c !c    Output, integer NM, the highest order computed. !c !c    Output, double precision BI(0:N), DI(0:N), BK(0:N), DK(0:N), !c    the values of In(x), In'(x), Kn(x), Kn'(x). !c implicit none integer , intent ( in ) :: n !      double precision :: a0 double precision :: bi ( 0 : n ) !      double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: f0 double precision :: f1 !      double precision :: g !      double precision :: g0 !      double precision :: g1 integer :: k !      integer :: k0 !      integer :: l integer :: m , ik !      integer :: msta1 !      integer :: msta2 integer :: nm double precision :: pi !      double precision :: r double precision :: s0 double precision :: sk0 !      double precision :: vt double precision :: x , ifact pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n if ( x . le . 1.0D-15 ) then do k = 0 , n ifact = 1.0_dp do ik = 2 , k ifact = ifact * ik enddo bi ( k ) = ( 0.5_dp * x ) ** k / ifact end do return end if if ( n . eq . 0 ) then nm = 1 end if m = msta1 ( x , 200 ) if ( m . lt . nm ) then nm = m else m = msta2 ( x , nm , 15 ) end if bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 if ( k . le . nm ) then bi ( k ) = f end if if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then sk0 = sk0 + 4.0D+00 * f / k end if bs = bs + 2.0D+00 * f f0 = f1 f1 = f end do s0 = exp ( x ) / ( bs - f ) do k = 0 , nm bi ( k ) = s0 * bi ( k ) end do return end SUBROUTINE iknb ! ! SUBROUTINE iknb2 ( n , x , nm , bi , di , bk , dk ) ! !    ============================================================ !    Purpose: Compute modified Bessel functions In(x) and Kn(x), !             and their derivatives !    Input:   x --- Argument of In(x) and Kn(x) ( 0 ó x ó 700 ) !             n --- Order of In(x) and Kn(x) !    Output:  BI(n) --- In(x) !             DI(n) --- In'(x) !             BK(n) --- Kn(x) !             DK(n) --- Kn'(x) !             NM --- Highest order computed !    Routines called: !             MSTA1 and MSTA2 for computing the starting point !             for backward recurrence !    =========================================================== ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( OUT ) :: nm REAL ( dp ), INTENT ( OUT ) :: bi ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: di ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: bk ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: dk ( 0 : n ) ! REAL ( dp ), PARAMETER :: pi = 3.141592653589793_dp , el = 0.5772156649015329_dp REAL ( dp ) :: a0 , bkl , bs , f , f0 , f1 , g , g0 , g1 , r , s0 , sk0 , vt INTEGER :: k , k0 , l , m ! nm = n IF ( x <= 1.0D-50 ) THEN DO k = 0 , n bi ( k ) = 0.0D0 di ( k ) = 0.0D0 bk ( k ) = 1.0D+300 dk ( k ) = - 1.0D+300 END DO bi ( 0 ) = 1.0D0 di ( 1 ) = 0.5D0 RETURN END IF IF ( n == 0 ) nm = 1 m = msta1 ( x , 200 ) IF ( m < nm ) THEN nm = m ELSE m = msta2 ( x , nm , 15 ) END IF !write(6,*)'mmmmmmmmm', m bs = 0.0D0 sk0 = 0.0D0 f0 = 0.0D0 f1 = 1.0D-100 DO k = m , 0 , - 1 f = 2 * ( k + 1 ) / x * f1 + f0 IF ( k <= nm ) bi ( k ) = f IF ( k /= 0 . AND . k == 2 * INT ( k / 2 )) sk0 = sk0 + 4.0D0 * f / k bs = bs + 2.0D0 * f f0 = f1 f1 = f END DO !s0 = EXP(x) / (bs-f) !write(6,*) f, f1 s0 = EXP ( x ) / ( bs - f1 ) bi ( 0 : nm ) = s0 * bi ( 0 : nm ) IF ( x <= 8.0D0 ) THEN bk ( 0 ) = - ( LOG ( 0.5D0 * x ) + el ) * bi ( 0 ) + s0 * sk0 bk ( 1 ) = ( 1.0D0 / x - bi ( 1 ) * bk ( 0 )) / bi ( 0 ) ELSE a0 = SQRT ( pi / ( 2.0D0 * x )) * EXP ( - x ) k0 = 16 IF ( x >= 2 5.0 ) k0 = 10 IF ( x >= 8 0.0 ) k0 = 8 IF ( x >= 20 0.0 ) k0 = 6 DO l = 0 , 1 bkl = 1.0D0 vt = 4 * l r = 1.0D0 DO k = 1 , k0 r = 0.125D0 * r * ( vt - ( 2 * k - 1 ) ** 2 ) / ( k * x ) bkl = bkl + r END DO bk ( l ) = a0 * bkl END DO END IF g0 = bk ( 0 ) g1 = bk ( 1 ) DO k = 2 , nm g = 2 * ( k - 1 ) / x * g1 + g0 bk ( k ) = g g0 = g1 g1 = g END DO di ( 0 ) = bi ( 1 ) dk ( 0 ) = - bk ( 1 ) DO k = 1 , nm di ( k ) = bi ( k - 1 ) - k / x * bi ( k ) dk ( k ) = - bk ( k - 1 ) - k / x * bk ( k ) END DO RETURN ! END SUBROUTINE iknb2 ! ! FUNCTION msta1 ( x , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that the magnitude of !                Jn(x) at that point is about 10&#94;(-MP) !       Input :  x     --- Argument of Jn(x) !                MP    --- Value of magnitude !       Output:  MSTA1 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , f , f0 , f1 INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) n0 = INT ( 1.1 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - mp IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn ! RETURN ! END FUNCTION msta1 ! ! FUNCTION msta2 ( x , n , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that all Jn(x) has MP !                significant digits !       Input :  x  --- Argument of Jn(x) !                n  --- Order of Jn(x) !                MP --- Significant digit !       Output:  MSTA2 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) hmp = 0.5_dp * mp ejn = envj ( n , a0 ) IF ( ejn <= hmp ) THEN obj = mp n0 = INT ( 1.1 * a0 ) ELSE obj = hmp + ejn n0 = n END IF !!!!!!!! if ( n0 < 1 ) n0 = 1 !!!!!!!! f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj ! DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - obj IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn + 10 ! RETURN ! END FUNCTION msta2 ! ! FUNCTION envj ( n , x ) RESULT ( fn_val ) ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val ! fn_val = 0.5_dp * LOG10 ( 6.28_dp * n ) - n * LOG10 ( 1.36_dp * x / n ) ! RETURN ! END FUNCTION envj ! ! subroutine parallelIsFsBy3 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = modes / 6.0_dp totalStates = totalStates * ( modes - 1 ) * ( modes - 2 ) ! if ( modes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = modes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) / 2.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 2.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = modes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = modes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = modes - 2 ! else ! nProcMax = modes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! write ( 6 , * ) iModeIs (:), iModeFs (:) ! return ! end subroutine parallelIsFsBy3 ! ! subroutine parallelIsFsBy4 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = modes / 2 4.0_dp totalStates = totalStates * ( modes - 1 ) * ( modes - 2 ) * ( modes - 3 ) ! if ( modes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = modes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 6.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) * real ( iState - 4 , dp ) / 6.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = modes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = modes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = modes - 2 ! else ! nProcMax = modes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy4 ! ! end module lsf","tags":"","loc":"sourcefile/lsf_linear_module_v1.f90.html","title":"LSF_linear_Module_v1.f90 – Carrier Cross Sections"},{"text":"Contents Programs crossSection Source Code Sigma_Main.f90 Source Code program crossSection ! use sigma_module ! implicit none ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call calculateSigma () ! call writeSigma () ! end program crossSection","tags":"","loc":"sourcefile/sigma_main.f90.html","title":"Sigma_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules sigma_module Source Code Sigma_Module_v4.f90 Source Code module sigma_module ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: iostd = 16 ! real ( kind = dp ), parameter :: maxEnergy = 1 0.0_dp integer , parameter :: nOfEnergyBins = 5040 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer ( kind = int32 ) :: ios integer :: nEnergies , m , numOfVfis ! real ( kind = dp ) :: volume , de , eifMin , DHifMin ! real ( kind = dp ), allocatable :: E (:), Vfis (:), lsfVsE (:), lsfVsEbyPhonon (:), energy (:), lsf (:) real ( kind = dp ), allocatable :: sigma (:), sigmaByPhonon (:), lorentz (:), lorentzByPhonon (:) ! character ( len = 11 ), parameter :: output = 'sigmaStatus' character ( len = 256 ) :: VfisInput , LSFinput , crossSectionOutput ! logical :: file_exists ! namelist / elphscat / VfisInput , LSFinput , crossSectionOutput ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if an output file exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , elphscat , iostat = ios ) ! call checkInputAndUpdateParameters () ! call readLSF () ! call readVfis () ! return ! end subroutine readInputs ! ! subroutine initialize () ! implicit none ! VfisInput = '' LSFinput = '' crossSectionOutput = '' ! de = maxEnergy * eVToHartree / real ( nOfEnergyBins , dp ) ! return ! end subroutine initialize ! ! subroutine checkInputAndUpdateParameters () ! implicit none ! if ( VfisInput == '' ) then write ( iostd , '(\" Vfi elements input (input variable VfisInput) is not defined!\")' ) else inquire ( file = trim ( VfisInput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" Vfi elements input : \", a)' ) trim ( VfisInput ) else write ( iostd , '(\" Vfi elements input : \", a, \" does not exist!\")' ) trim ( VfisInput ) endif endif ! if ( LSFinput == '' ) then write ( iostd , '(\" LSF input (input variable LSFinput) is not defined!\")' ) else inquire ( file = trim ( LSFinput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" LSF input : \", a)' ) trim ( LSFinput ) else write ( iostd , '(\" LSF input : \", a, \" does not exist!\")' ) trim ( LSFinput ) endif endif ! if ( crossSectionOutput == '' ) then write ( iostd , '(\" crossSectionOutput is not defined! File name : crossSection, will be used.\")' ) crossSectionOutput = 'crossSection' else write ( iostd , '(\" Cross section output file name : \", a)' ) trim ( crossSectionOutput ) endif ! if ( ( VfisInput == '' ) . or . ( LSFinput == '' ) ) then ! write ( iostd , '(\" One or both of the input files is not defined! \")' ) write ( iostd , '(\" ********************************************** \")' ) write ( iostd , '(\" *               Program stops!               * \")' ) write ( iostd , '(\" *       Please check the output file.        * \")' ) write ( iostd , '(\" ********************************************** \")' ) ! stop ! endif ! flush ( iostd ) ! return ! end subroutine checkInputAndUpdateParameters ! ! subroutine readLSF () ! implicit none ! character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! real ( kind = dp ) :: ee ! integer :: iE ! open ( 1 , file = trim ( LSFinput ), status = 'old' ) ! read ( 1 , '(a1, i10, a9, i5, a8)' ) dummyC1 , nEnergies , dummyC9 , m , dummyC8 ! allocate ( E ( - nEnergies : nEnergies ), lsfVsE ( - nEnergies : nEnergies ), lsfVsEbyPhonon ( - nEnergies : nEnergies ) ) ! do iE = - nEnergies , nEnergies ! read ( 1 , '(F16.8,2E18.6e3)' ) ee , lsfVsE ( iE ), lsfVsEbyPhonon ( iE ) E ( iE ) = ee * eVToHartree ! enddo ! close ( 1 ) ! end subroutine readLSF ! ! subroutine readVfis () ! implicit none ! integer :: i , iE0 , iE real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , VfiOfE , VfiOfE0 , eBin character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 ! open ( 1 , file = trim ( VfisInput ), status = \"old\" ) ! !read(1, '(a1, i10, a9, f15.4, a16)') dummyC1, nEVfi, dummyC9, volume, dummyC16 ! read ( 1 , * ) read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 read ( 1 , * ) ! read ( 1 , '(i10)' ) numOfVfis ! allocate ( Vfis ( 0 : numOfVfis ), energy ( 0 : numOfVfis ), lsf ( 0 : numOfVfis ) ) ! Vfis (:) = 0.0_dp energy (:) = 0.0_dp lsf (:) = 0.0_dp ! read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE0 , dummyD1 ! Vfis ( 1 ) = VfiOfE0 energy ( 1 ) = Ee ! iE = int ( Ee / de ) + 1 ! do i = 2 , numOfVfis ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE , dummyD2 energy ( i ) = Ee iE = int ( Ee / de ) + 1 !Vfis(iE0:iE) = VfiOfE0 Vfis ( i ) = VfiOfE !VfiOfE0 = VfiOfE lsf ( i - 1 ) = sum ( lsfVsE ( iE0 : iE )) / ( iE - iE0 + 1 ) write ( 26 , * ) E ( iE0 ), Ee , lsf ( i ) ! sum(lsfVsE(iE0:iE))/(iE-iE0+1) ! enddo ! close ( 1 ) close ( 26 ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies write ( 44 , * ) energy ( iE ) * HartreeToEv , Vfis ( iE ), lsf ( iE ) enddo ! close ( 44 ) ! return ! end subroutine readVfis ! ! subroutine calculateSigma () ! implicit none ! integer :: iE real ( kind = dp ) :: vg , sigma0 ! allocate ( sigma ( numOfVfis ) ) ! , sigmaByPhonon(-nEnergies:nEnergies) ) !allocate( sigma(-nEnergies:nEnergies), sigmaByPhonon(-nEnergies:nEnergies) ) ! iE = int ( eifMin / de ) + 1 write ( 6 , * ) eifMin , eifMin * HartreeToEv , iE sigma0 = twoPi * abCM ** 2 * volume * DHifMin * lsfVsE ( iE ) / sqrt ( 2.0_dp * E ( iE )) ! !do iE = 1, numOfVfis ! -nEnergies, nEnergies - 1 !  if ( (E(iE) < eifMin).and.(E(iE+1) > eifMin) ) sigma0 = twoPi*abCM**2*volume*DHifMin*lsfVsE(iE)/sqrt(2.0_dp*E(iE)) !enddo ! write ( 6 , * ) eifMin * HartreeToEv , sigma0 ! sigma (:) = 0.0_dp ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies vg = 1.0_dp if ( energy ( iE ) > 0.0_dp ) vg = sqrt ( 2.0_dp * energy ( iE )) !write(6,*) iE, energy(iE), vg, Vfis(iE), lsf(iE) sigma ( iE ) = twoPi * abCM ** 2 * volume * Vfis ( iE ) * lsf ( iE ) / vg !sigma(iE)         = twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg !sigmaByPhonon(iE) = twoPi*abCM**2*volume*Vfis(iE)*lsfVsEbyPhonon(iE)/vg enddo ! return ! end subroutine calculateSigma ! ! subroutine writeSigma () ! implicit none ! integer :: iE ! open ( 2 , file = trim ( crossSectionOutput ), status = 'unknown' ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies ! write ( 2 , * ) energy ( iE ) * HartreeToEv , sigma ( iE ) !, sigmaByPhonon(iE) !write(2,*) E(iE), sigma(iE), sigmaByPhonon(iE) ! enddo ! close ( 2 ) ! return ! end subroutine writeSigma ! ! end module sigma_module","tags":"","loc":"sourcefile/sigma_module_v4.f90.html","title":"Sigma_Module_v4.f90 – Carrier Cross Sections"},{"text":"type, public :: atom Define a new type to represent an atom in the structure. \n Each different type of atom in the structure will be another\n variable with the type atom . Todo Consider changing atom type to element since it holds more than one atom Contents Variables iRAugMax numOfAtoms numProjs lmMax nMax symbol projAngMom bes_J_qr F F1 F2 r rab wae wps Source Code atom Components Type Visibility Attributes Name Initial integer, public :: iRAugMax Maximum radius of beta projector (outer radius to integrate);\n for PAW augmentation charge may extend a bit further; I think this\n is the max index for the augmentation sphere, so I'm changing the \n name; last name was iRc integer, public :: numOfAtoms Number of atoms of a specific type in the structure integer, public :: numProjs Number of projectors integer, public :: lmMax Number of channels integer, public :: nMax Number of radial mesh points character(len=2), public :: symbol Element name for the given atom type integer, public, allocatable :: projAngMom (:) Angular momentum of each projector real(kind=dp), public, allocatable :: bes_J_qr (:,:) real(kind=dp), public, allocatable :: F (:,:) real(kind=dp), public, allocatable :: F1 (:,:,:) real(kind=dp), public, allocatable :: F2 (:,:,:) real(kind=dp), public, allocatable :: r (:) Radial mesh real(kind=dp), public, allocatable :: rab (:) Derivative of radial mesh real(kind=dp), public, allocatable :: wae (:,:) All electron wavefunction real(kind=dp), public, allocatable :: wps (:,:) Psuedowavefunction Source Code type :: atom !! Define a new type to represent an atom in the structure. !! Each different type of atom in the structure will be another !! variable with the type `atom`. !! @todo Consider changing `atom` type to `element` since it holds more than one atom @endtodo ! ! Define scalar integers integer :: iRAugMax !! Maximum radius of beta projector (outer radius to integrate); !! for PAW augmentation charge may extend a bit further; I think this !! is the max index for the augmentation sphere, so I'm changing the !! name; last name was `iRc` integer :: numOfAtoms !! Number of atoms of a specific type in the structure integer :: numProjs !! Number of projectors integer :: lmMax !! Number of channels integer :: nMax !! Number of radial mesh points ! ! Define scalar character character ( len = 2 ) :: symbol !! Element name for the given atom type ! ! Define matrix/vector integer integer , allocatable :: projAngMom (:) !! Angular momentum of each projector ! ! Define matrix/vector reals real ( kind = dp ), allocatable :: bes_J_qr (:,:) real ( kind = dp ), allocatable :: F (:,:) real ( kind = dp ), allocatable :: F1 (:,:,:) real ( kind = dp ), allocatable :: F2 (:,:,:) real ( kind = dp ), allocatable :: r (:) !! Radial mesh real ( kind = dp ), allocatable :: rab (:) !! Derivative of radial mesh real ( kind = dp ), allocatable :: wae (:,:) !! All electron wavefunction real ( kind = dp ), allocatable :: wps (:,:) !! Psuedowavefunction ! end type atom","tags":"","loc":"type/atom.html","title":"atom – Carrier Cross Sections "},{"text":"type, public :: crystal Contents Variables nKpts numOfPWs nIons numOfTypes nProjs numOfGvecs nBands nSpins npws atomTypeIndex omega bg wk xk posIon wfc beta cProj cCrossProj paw_Wfc pawK crystalType exportDir atoms Source Code crystal Components Type Visibility Attributes Name Initial integer, public :: nKpts Number of k points integer, public :: numOfPWs Total number of plane waves integer, public :: nIons Total number of atoms in system integer, public :: numOfTypes Number of different types of atoms integer, public :: nProjs Number of projectors integer, public :: numOfGvecs Number of G vectors FFT grid was read from input file but not used, so removed integer, public :: nBands Number of bands integer, public :: nSpins Number of spins integer, public, allocatable :: npws (:) Number of plane waves per k point integer, public, allocatable :: atomTypeIndex (:) Index of the given atom type real(kind=dp), public :: omega Cell volume real(kind=dp), public :: bg (3,3) real(kind=dp), public, allocatable :: wk (:) real(kind=dp), public, allocatable :: xk (:,:) real(kind=dp), public, allocatable :: posIon (:,:) complex(kind=dp), public, allocatable :: wfc (:,:) complex(kind=dp), public, allocatable :: beta (:,:) complex(kind=dp), public, allocatable :: cProj (:,:,:) complex(kind=dp), public, allocatable :: cCrossProj (:,:,:) complex(kind=dp), public, allocatable :: paw_Wfc (:,:) complex(kind=dp), public, allocatable :: pawK (:,:,:) character(len=2), public :: crystalType 'PC' for pristine crystal and 'SD' for solid defect character(len=200), public :: exportDir Export directory from pw_export_for_TME type( atom ), public, allocatable :: atoms (:) Source Code type :: crystal integer :: nKpts !! Number of k points integer :: numOfPWs !! Total number of plane waves integer :: nIons !! Total number of atoms in system integer :: numOfTypes !! Number of different types of atoms integer :: nProjs !! Number of projectors integer :: numOfGvecs !! Number of G vectors !integer :: fftxMax, fftxMin, fftyMax, fftyMin, fftzMax, fftzMin !! FFT grid was read from `input` file but not used, so removed integer :: nBands !! Number of bands integer :: nSpins !! Number of spins integer , allocatable :: npws (:) !! Number of plane waves per k point integer , allocatable :: atomTypeIndex (:) !! Index of the given atom type !integer, allocatable :: groundState(:) ! Was read from `input` file but not used, so removed ! real ( kind = dp ) :: omega !! Cell volume !real(kind = dp) :: at(3,3) ! Was read from `input` file but not used, so removed real ( kind = dp ) :: bg ( 3 , 3 ) real ( kind = dp ), allocatable :: wk (:) real ( kind = dp ), allocatable :: xk (:, :) real ( kind = dp ), allocatable :: posIon (:,:) ! complex ( kind = dp ), allocatable :: wfc (:,:) complex ( kind = dp ), allocatable :: beta (:,:) complex ( kind = dp ), allocatable :: cProj (:,:,:) complex ( kind = dp ), allocatable :: cCrossProj (:,:,:) complex ( kind = dp ), allocatable :: paw_Wfc (:,:) complex ( kind = dp ), allocatable :: pawK (:,:,:) ! character ( len = 2 ) crystalType !! 'PC' for pristine crystal and 'SD' for solid defect character ( len = 200 ) :: exportDir !! Export directory from [[pw_export_for_tme(program)]] ! TYPE ( atom ), allocatable :: atoms (:) ! !    integer :: Jmax, maxL, iTypes, nn, nm !    integer :: i, j, n1, n2, n3, n4, n, id !    ! !    ! !    real(kind = dp), allocatable :: eigvI(:), eigvF(:) !    real(kind = dp), allocatable :: DE(:,:), absVfi2(:,:) !    ! !    complex(kind = dp), allocatable :: Ufi(:,:,:) !    ! !    integer, allocatable :: igvs(:,:,:), pwGvecs(:,:), iqs(:) !    integer, allocatable :: pwGs(:,:), nIs(:,:), nFs(:,:), ngs(:,:) ! end type crystal","tags":"","loc":"type/crystal.html","title":"crystal – Carrier Cross Sections "},{"text":"type, public :: vec Contents Variables ind igN igM Source Code vec Components Type Visibility Attributes Name Initial integer, public :: ind integer, public, allocatable :: igN (:) integer, public, allocatable :: igM (:) Source Code type :: vec ! integer :: ind integer , allocatable :: igN (:) integer , allocatable :: igM (:) end type vec","tags":"","loc":"type/vec.html","title":"vec – Carrier Cross Sections "},{"text":"public subroutine write_restart_wfc(iuni, exportDir, ik, nk, kunit, ispin, nspin, scal, wf0, t0, wfm, tm, ngw, gamma_only, nbnd, igl, ngwl) Uses mp_wave mp mp_pools mp_world io_global iotk_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: iuni character(len=256), intent(in) :: exportDir integer, intent(in) :: ik integer, intent(in) :: nk integer, intent(in) :: kunit integer, intent(in) :: ispin integer, intent(in) :: nspin real(kind=DP), intent(in) :: scal complex(kind=DP), intent(in) :: wf0 (:,:) logical, intent(in) :: t0 complex(kind=DP), intent(in) :: wfm (:,:) logical, intent(in) :: tm integer, intent(in) :: ngw logical, intent(in) :: gamma_only integer, intent(in) :: nbnd integer, intent(in) :: igl (:) integer, intent(in) :: ngwl Contents Variables i j ierr idum nkl nkr nkbl iks ike nkt ikt igwx ig npool ipmask ipsour wtmp igltot section_name twrite ierr_iotk attr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: ierr integer, public :: idum = 0 integer, public :: nkl integer, public :: nkr integer, public :: nkbl integer, public :: iks integer, public :: ike integer, public :: nkt integer, public :: ikt integer, public :: igwx integer, public :: ig integer, public :: npool integer, public :: ipmask (nproc) integer, public :: ipsour complex(kind=DP), public, ALLOCATABLE :: wtmp (:) integer, public, ALLOCATABLE :: igltot (:) character(len=20), public :: section_name = 'wfc' logical, public :: twrite = .true. integer, public :: ierr_iotk character(len=iotk_attlenx), public :: attr","tags":"","loc":"proc/write_restart_wfc.html","title":"write_restart_wfc – Carrier Cross Sections"},{"text":"subroutine write_export(pp_file, exportDir, kunit) Uses iotk_module kinds pwcom start_k control_flags global_version becmod uspp wavefunctions_module io_files io_files io_base_export io_global ions_base mp_pools mp mp_world upf_module pseudo_types radial_grids wvfct paw_variables paw_onecenter paw_symmetry uspp_param uspp scf Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: pp_file character(len=256), intent(in) :: exportDir integer, intent(in) :: kunit Contents Variables fmt_name fmt_version i j k ig ik ibnd na ngg ig_ ierr kisort xyz tmp npool nkbl nkl nkr npwx_g im ink inb ms ike iks npw_g ispin local_pw ngk_g itmp_g rtmp_g rtmp_gg itmp1 igwk l2g_new igk_l2g text wfc_scal twf0 twfm file_exists attr upf grid nnTyp groundState Source Code write_export Variables Type Visibility Attributes Name Initial character(len=5), public, parameter :: fmt_name = \"QEXPT\" character(len=5), public, parameter :: fmt_version = \"1.1.0\" integer, public :: i integer, public :: j integer, public :: k integer, public :: ig integer, public :: ik integer, public :: ibnd integer, public :: na integer, public :: ngg integer, public :: ig_ integer, public :: ierr integer, public, ALLOCATABLE :: kisort (:) real(kind=DP), public :: xyz (3) real(kind=DP), public :: tmp (3) integer, public :: npool integer, public :: nkbl integer, public :: nkl integer, public :: nkr integer, public :: npwx_g integer, public :: im integer, public :: ink integer, public :: inb integer, public :: ms integer, public :: ike integer, public :: iks integer, public :: npw_g integer, public :: ispin integer, public :: local_pw integer, public, ALLOCATABLE :: ngk_g (:) integer, public, ALLOCATABLE :: itmp_g (:,:) real(kind=DP), public, ALLOCATABLE :: rtmp_g (:,:) real(kind=DP), public, ALLOCATABLE :: rtmp_gg (:) integer, public, ALLOCATABLE :: itmp1 (:) integer, public, ALLOCATABLE :: igwk (:,:) integer, public, ALLOCATABLE :: l2g_new (:) integer, public, ALLOCATABLE :: igk_l2g (:,:) character(len=300), public :: text real(kind=DP), public :: wfc_scal logical, public :: twf0 logical, public :: twfm logical, public :: file_exists character(len=iotk_attlenx), public :: attr type(pseudo_upf), public :: upf type(radial_grid_type), public :: grid integer, public, allocatable :: nnTyp (:) integer, public, allocatable :: groundState (:) Source Code SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export","tags":"","loc":"proc/write_export.html","title":"write_export – Carrier Cross Sections"},{"text":"public function wasRead(inputVal, variableName, usage, abortExecution) Determine if an input variable still has the default value.\n If it does, output an error message and possibly set the program\n to abort. Not all variables would cause the program to abort,\n so this program assumes that if you pass in the logical abortExecution then the variable is required and causes the program to abort \n if missing. I could not find a clean way to allow this function to receive\n different types of variables (integer, real, character, etc.), so\n I made the argument be an integer so that each type could be sent\n in a different way. Each case is set up so that the value is tested to\n see if it is less than zero to determine if the variable still has\n its default value For strings, the default value is '' , so pass in LEN(trim(variable))-1 as this should be less than zero if\n the string still has the default value and greater than or equal \n to zero otherwise For integers the default values are less than zero, so just pass as is Real variables also have a negative default value, so just pass the\n value cast from real to integer Default return value is true If the input variable still has the default value output an error message set the program to abort if that variable was sent in set the return value to false to indicate that the \n  variable wasn't read Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputVal Value to compare with 0 to see if a variable has been read; character(len=*), intent(in) :: variableName Name of the variable used in output message character(len=*), intent(in) :: usage Example of how the variable can be used logical, intent(inout), optional :: abortExecution Optional logical for if the program should be aborted Return Value logical Whether or not the input variable was read from the input file;\n this is the return value Walkthrough Contents Source Code wasRead Source Code function wasRead ( inputVal , variableName , usage , abortExecution ) !! Determine if an input variable still has the default value. !! If it does, output an error message and possibly set the program !! to abort. Not all variables would cause the program to abort, !! so this program assumes that if you pass in the logical `abortExecution` !! then the variable is required and causes the program to abort !! if missing. !! !! I could not find a clean way to allow this function to receive !! different types of variables (integer, real, character, etc.), so !! I made the argument be an integer so that each type could be sent !! in a different way. Each case is set up so that the value is tested to !! see if it is less than zero to determine if the variable still has !! its default value !! !! * For strings, the default value is `''`, so pass in !! `LEN(trim(variable))-1` as this should be less than zero if !! the string still has the default value and greater than or equal !! to zero otherwise !! * For integers the default values are less than zero, so just pass as is !! * Real variables also have a negative default value, so just pass the !! value cast from real to integer !! implicit none ! integer , intent ( in ) :: inputVal !! Value to compare with 0 to see if a variable has been read; ! character ( len =* ), intent ( in ) :: variableName !! Name of the variable used in output message character ( len =* ), intent ( in ) :: usage !! Example of how the variable can be used ! logical , optional , intent ( inout ) :: abortExecution !! Optional logical for if the program should be aborted logical :: wasRead !! Whether or not the input variable was read from the input file; !! this is the return value ! !! <h2>Walkthrough</h2> !! wasRead = . true . !! * Default return value is true ! if ( inputVal < 0 ) then !! * If the input variable still has the default value !!    * output an error message !!    * set the program to abort if that variable was sent in !!    * set the return value to false to indicate that the !!      variable wasn't read ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"\", a, \"\"\" is not defined!\")' ) variableName write ( iostd , '(\" usage : \", a)' ) usage if ( present ( abortExecution )) then ! write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! wasRead = . false . ! endif ! return ! end function wasRead","tags":"","loc":"proc/wasread.html","title":"wasRead – Carrier Cross Sections"},{"text":"public subroutine initializeCalculation(solidDefect, pristineCrystal, elementsPath, VfisOutput, ki, kf, eBin, iBandIinit, iBandIfinal, iBandFinit, iBandFfinal, calculateVfis, t0) Initialize the calculation by starting timer,\n setting start values for variables to be read from .in file, removing any existing output in the output directory,\n and opening a clean output file Walkthrough Start a timer Check if file output exists,\n and delete it if it does Open new output file Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: solidDefect type( crystal ), intent(inout) :: pristineCrystal character(len=300), intent(out) :: elementsPath character(len=200), intent(out) :: VfisOutput integer, intent(out) :: ki integer, intent(out) :: kf real(kind=dp), intent(out) :: eBin integer, intent(out) :: iBandIinit integer, intent(out) :: iBandIfinal integer, intent(out) :: iBandFinit integer, intent(out) :: iBandFfinal logical, intent(out) :: calculateVfis real(kind=dp), intent(out) :: t0 Contents Variables fileExists Source Code initializeCalculation Variables Type Visibility Attributes Name Initial logical, public :: fileExists Whether or not the output file already exists Source Code subroutine initializeCalculation ( solidDefect , pristineCrystal , elementsPath , VFisOutput , ki , kf , eBin , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , calculateVFis , t0 ) !! Initialize the calculation by starting timer, !! setting start values for variables to be read from !! `.in` file, removing any existing output in the output directory, !! and opening a clean output file !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( out ) :: ki , kf , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! real ( kind = dp ), intent ( out ) :: eBin , t0 ! character ( len = 200 ), intent ( out ) :: VfisOutput character ( len = 300 ), intent ( out ) :: elementsPath ! logical , intent ( out ) :: calculateVfis logical :: fileExists !! Whether or not the output file already exists TYPE ( crystal ), intent ( inout ) :: solidDefect , pristineCrystal ! solidDefect % exportDir = '' perfectCrystal % exportDir = '' elementsPath = '' VfisOutput = '' ! ki = - 1 kf = - 1 ! eBin = - 1.0_dp ! iBandIinit = - 1 iBandIfinal = - 1 iBandFinit = - 1 iBandFfinal = - 1 ! calculateVfis = . false . ! perfectCrystal % crystalType = 'PC' solidDefect % crystalType = 'SD' ! call cpu_time ( t0 ) !! * Start a timer ! inquire ( file = output , exist = fileExists ) !! * Check if file output exists, if ( fileExists ) then !! and delete it if it does open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! return ! end subroutine initializeCalculation","tags":"","loc":"proc/initializecalculation.html","title":"initializeCalculation – Carrier Cross Sections"},{"text":"public subroutine readInput(perfectCrystal, solidDefect, elementsPath, iBandIinit, iBandIfinal, iBandFinit, iBandFfinal, ki, kf, calculateVfis, VfisOutput) Delete any previous output, initialize input variables,\n start a timer, and read in the input files Used to group the variables read in from the .in file Read input from command line (or input file if use < TME_Input.md ) Check that all required variables were input and have values that make sense Read perfect crystal inputs Read solid defect inputs Calculate the number of plane waves as the maximum of the number of PC and SD plane waves Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: perfectCrystal Holds all of the information on the perfect crystal type( crystal ), intent(inout) :: solidDefect Holds all of the information on the defective crystal character(len=300), intent(inout) :: elementsPath integer, intent(inout) :: iBandIinit integer, intent(inout) :: iBandIfinal integer, intent(inout) :: iBandFinit integer, intent(inout) :: iBandFfinal integer, intent(inout) :: ki integer, intent(inout) :: kf logical, intent(inout) :: calculateVfis character(len=200), intent(inout) :: VfisOutput Contents Variables exportDirSD exportDirPC Source Code readInput Variables Type Visibility Attributes Name Initial character(len=200), public :: exportDirSD character(len=200), public :: exportDirPC Source Code subroutine readInput ( perfectCrystal , solidDefect , elementsPath , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput ) !! Delete any previous output, initialize input variables, !! start a timer, and read in the input files !! implicit none ! integer , intent ( inout ) :: ki , kf , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! character ( len = 300 ), intent ( inout ) :: elementsPath character ( len = 200 ), intent ( inout ) :: VfisOutput character ( len = 200 ) :: exportDirSD character ( len = 200 ) :: exportDirPC ! logical , intent ( inout ) :: calculateVfis ! TYPE ( crystal ), intent ( inout ) :: perfectCrystal !! Holds all of the information on the perfect crystal TYPE ( crystal ), intent ( inout ) :: solidDefect !! Holds all of the information on the defective crystal ! NAMELIST / TME_Input / exportDirSD , exportDirPC , elementsPath , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput , eBin !! Used to group the variables read in from the .in file ! ! READ ( 5 , TME_Input , iostat = ios ) !! * Read input from command line (or input file if use `< TME_Input.md`) solidDefect % exportDir = exportDirSD perfectCrystal % exportDir = exportDirPC ! call checkInitialization () !! * Check that all required variables were input and have values that make sense ! call readQEExport ( perfectCrystal ) !! * Read perfect crystal inputs call readQEExport ( solidDefect ) !! * Read solid defect inputs ! numOfPWs = max ( perfectCrystal % numOfPWs , solidDefect % numOfPWs ) !! * Calculate the number of plane waves as the maximum of the number of PC and SD plane waves ! return ! end subroutine readInput","tags":"","loc":"proc/readinput.html","title":"readInput – Carrier Cross Sections"},{"text":"public subroutine checkInitialization() Check to see if variables from .in file still\n have the values set in initializeCalculation or if they have values that aren't allowed Walkthrough Todo Change checkInitialization() to have arguments to make clear that these variables are getting changed Set the default value of abort execution so that the program\n will only abort if there is an issue with the inputs Write out a header to the output file If the SD export directory variable was read Check if the SD export directory exists If the SD export directory doesn't exist Output an error message and set abortExecution to true Output the given SD export directory If the PC export directory variable was read Check if the PC export directory exists If the PC export directory doesn't exist Output an error message and set abortExecution to true Output the given PC export directory If the elements path was not read, set the default value to ./ Check if the elements path folder exists already If the elements path folder doesn't already exist Write the mkdir command to a string Execute the command to create the directory Output the elements path If iBandIinit was read, output its value If iBandIfinal was read, output its value If iBandFinit was read, output its value If iBandFfinal was read, output its value If calculateVfis is true and iBandFinit and iBandFfinal are not equal Output an error message and set abortExecution to true Output the value of calculateVfis If the VfisOutput file name is blank Output a warning message and set the default value to VfisVsE Output the value of VfisOutput Todo Remove everything with ki and kf because never used If the value of eBin was not read Output a warning message and set the default value to 0.01 eV Output the value of eBin Convert eBin from eV to Hartree If abortExecution was ever set to true Output an error message and stop the program Make the output file available for other processes Arguments None Contents Variables fileExists abortExecution Source Code checkInitialization Variables Type Visibility Attributes Name Initial logical, public :: fileExists Whether or not the exported directory from pw_export_for_TME exists logical, public :: abortExecution Source Code subroutine checkInitialization () !! Check to see if variables from .in file still !! have the values set in [[TMEModule(module):initializeCalculation(subroutine)]] !! or if they have values that aren't allowed !! !! <h2>Walkthrough</h2> !! !! @todo Change `checkInitialization()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! logical :: fileExists !! Whether or not the exported directory from [[pw_export_for_TME(program)]] !! exists logical :: abortExecution ! abortExecution = . false . !! * Set the default value of abort execution so that the program !! will only abort if there is an issue with the inputs ! write ( iostd , '(\" Inputs : \")' ) !! * Write out a header to the output file ! if ( wasRead ( LEN ( trim ( solidDefect % exportDir )) - 1 , 'exportDirSD' , 'exportDirSD = ''./Export/''' , abortExecution ) ) then !! * If the SD export directory variable was read !!    * Check if the SD export directory exists !!    * If the SD export directory doesn't exist !!       * Output an error message and set `abortExecution` to true !!    * Output the given SD export directory ! inquire ( file = trim ( solidDefect % exportDir ), exist = fileExists ) ! if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" exportDirSD :\", a, \" does not exist !\")' ) trim ( solidDefect % exportDir ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"exportDirSD = ''\", a, \"''\")' ) trim ( solidDefect % exportDir ) ! endif ! ! if ( wasRead ( LEN ( trim ( perfectCrystal % exportDir )) - 1 , 'exportDirPC' , 'exportDirPC = ''./Export/''' , abortExecution ) ) then !! * If the PC export directory variable was read !!    * Check if the PC export directory exists !!    * If the PC export directory doesn't exist !!       * Output an error message and set `abortExecution` to true !!    * Output the given PC export directory ! inquire ( file = trim ( perfectCrystal % exportDir ), exist = fileExists ) ! if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" exportDirPC :\", a, \" does not exist !\")' ) trim ( perfectCrystal % exportDir ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"exportDirPC = ''\", a, \"''\")' ) trim ( perfectCrystal % exportDir ) ! endif ! if ( . not . wasRead ( LEN ( elementsPath ) - 1 , 'elementsPath' , 'elementsPath = ''./''' ) ) then !! * If the elements path was not read, set the default value to `./` ! write ( iostd , '(\" The current directory will be used as elementsPath.\")' ) elementsPath = './' ! endif ! inquire ( file = trim ( elementsPath ), exist = fileExists ) !! * Check if the elements path folder exists already ! if ( . not . fileExists ) then !! * If the elements path folder doesn't already exist !!    * Write the `mkdir` command to a string !!    * Execute the command to create the directory ! write ( mkDir , '(\"mkdir -p \", a)' ) trim ( elementsPath ) ! call system ( mkDir ) ! endif ! write ( iostd , '(\"elementsPath = ''\", a, \"''\")' ) trim ( elementsPath ) !! * Output the elements path ! if ( wasRead ( iBandIinit , 'iBandIinit' , 'iBandIinit = 10' , abortExecution ) ) then !! * If `iBandIinit` was read, output its value ! write ( iostd , '(\"iBandIinit = \", i4)' ) iBandIinit ! endif ! if ( wasRead ( iBandIfinal , 'iBandIfinal' , 'iBandIfinal = 20' , abortExecution ) ) then !! * If `iBandIfinal` was read, output its value ! write ( iostd , '(\"iBandIfinal = \", i4)' ) iBandIfinal ! endif ! if ( wasRead ( iBandFinit , 'iBandFinit' , 'iBandFinit = 9' , abortExecution ) ) then !! * If `iBandFinit` was read, output its value ! write ( iostd , '(\"iBandFinit = \", i4)' ) iBandFinit ! endif ! if ( wasRead ( iBandFfinal , 'iBandFfinal' , 'iBandFfinal = 9' , abortExecution ) ) then !! * If `iBandFfinal` was read, output its value ! write ( iostd , '(\"iBandFfinal = \", i4)' ) iBandFfinal ! endif ! !> * If `calculateVfis` is true and `iBandFinit` and `iBandFfinal` are not equal !>    * Output an error message and set `abortExecution` to true if ( ( calculateVfis ) . and . ( iBandFinit /= iBandFfinal ) ) then ! write ( iostd , * ) write ( iostd , '(\" Vfis can be calculated only if the final state is one and only one!\")' ) write ( iostd , '(\" ''iBandFInit'' = \", i10)' ) iBandFinit write ( iostd , '(\" ''iBandFfinal'' = \", i10)' ) iBandFfinal write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"calculateVfis = \", l )' ) calculateVfis !! * Output the value of `calculateVfis` ! !> * If the `VfisOutput` file name is blank !>    * Output a warning message and set the default value to `VfisVsE` if ( trim ( VfisOutput ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"VfisOutput\"\" is not defined!\")' ) write ( iostd , '(\" usage : VfisOutput = ''VfisVsE''\")' ) write ( iostd , '(\" The default value ''VfisVsE'' will be used.\")' ) VfisOutput = 'VfisVsE' ! endif ! write ( iostd , '(\"VfisOutput = ''\", a, \"''\")' ) trim ( VfisOutput ) !! * Output the value of `VfisOutput` !> @todo Remove everything with `ki` and `kf` because never used @endtodo ! !if( .not. wasRead(ki, 'ki', 'ki = 1') ) then !  !! * If `ki` wasn't read, set the default value to 1 !  ! !  write(iostd, '(\" ki = 1 will be used.\")') !  ki = 1 !  ! !endif ! !if( .not. wasRead(kf, 'kf', 'kf = 1') ) then !  !! * If `kf` wasn't read, set the default value to the total !  !!   number of k points (actually done in [[TMEModeul(module):readQEInput(subroutine)]] !  !!   where the total number of k points is read !  ! !  write(iostd, '(\" kf = total number of k-points will be used.\")') !  ! !endif ! !if ( ki /= kf ) then !  write(iostd, *) !  write(iostd, '(\" Initial k-point index ''ki'', should be equal to the Final k-point index ''kf'' !\")') !  write(iostd, '(\" Calculation of transition matrix elements with momentum transfer is not implemented!\")') !  write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  abortExecution = .true. !endif ! if ( . not . wasRead ( INT ( eBin ), 'eBin' , 'eBin = 0.01' ) ) then !! * If the value of `eBin` was not read !!    * Output a warning message and set the default value to 0.01 eV ! write ( iostd , '(\" A default value of 0.01 eV will be used !\")' ) eBin = 0.01_dp ! eV ! endif ! write ( iostd , '(\"eBin = \", f8.4, \" (eV)\")' ) eBin !! * Output the value of eBin ! eBin = eBin * evToHartree !! * Convert `eBin` from eV to Hartree ! if ( abortExecution ) then !! * If `abortExecution` was ever set to true !!    * Output an error message and stop the program write ( iostd , '(\" Program stops!\")' ) stop endif ! flush ( iostd ) !! * Make the output file available for other processes ! return ! end subroutine checkInitialization","tags":"","loc":"proc/checkinitialization.html","title":"checkInitialization – Carrier Cross Sections"},{"text":"public subroutine readQEExport(system) Read input files in the Export directory created by pw_export_for_TME Walkthrough Start a local timer Output header to output file based on the input crystal type Note The program will end if a crystal type other than PC or SD is used. Set the path for the input file from the PC export directory Check if the input file from the PC export directory exists If the input file doesn't exist Output an error message and end the program Open and read the input file Calculate F , F1 , and F2 using the all-electron and psuedowvefunctions Todo Look more into how AE and PS wavefunctions are combined to further understand this Todo Move this behavior to another subroutine for clarity Todo Figure out if differences in PC and SD F1 calculations are intentional Todo Figure out if should be (wae_i wae_j - wps_i wps_j)r_{ab} Todo Figure out if first term in each should be conjugated for inner product form Todo Figure out if rab plays role of dr within augmentation sphere Close the input file Go through the projAngMom values for each projector for each atom\n and find the max to store in JMAX Todo Figure out if intentional to only use JMAX from SD input End the local timer and write out the total time to read the inputs\n to the output file Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect Contents Variables i ik iType ni iRAugMax l ind iDum t1 t2 ef textDum input fileExists Source Code readQEExport Variables Type Visibility Attributes Name Initial integer, public :: i Loop index integer, public :: ik Loop index integer, public :: iType Loop index integer, public :: ni Loop index integer, public :: iRAugMax Local value of iRAugMax for each atom so don't have to keep accessing in loop integer, public :: l Angular momentum of each projector read from input file integer, public :: ind Index of each projector read from input file integer, public :: iDum Dummy variable to hold trash from input file real(kind=dp), public :: t1 Local start time real(kind=dp), public :: t2 Local end time real(kind=dp), public :: ef character(len=300), public :: textDum Dummy variable to hold trash from input file character(len=300), public :: input The input file path logical, public :: fileExists Whether or not the input file exists in the given \n Export directory Source Code subroutine readQEExport ( system ) !! Read input files in the Export directory created by !! [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! ! implicit none ! !integer, intent(in) :: id ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect` ! integer :: i , ik , iType , ni !! Loop index integer :: iRAugMax !! Local value of `iRAugMax` for each atom so don't have to keep accessing in loop integer :: l !! Angular momentum of each projector read from input file integer :: ind !! Index of each projector read from input file integer :: iDum !! Dummy variable to hold trash from input file ! real ( kind = dp ) :: t1 !! Local start time real ( kind = dp ) :: t2 !! Local end time real ( kind = dp ) :: ef ! character ( len = 300 ) :: textDum !! Dummy variable to hold trash from input file character ( len = 300 ) :: input !! The input file path ! logical :: fileExists !! Whether or not the `input` file exists in the given !! Export directory ! call cpu_time ( t1 ) !! * Start a local timer ! !> * Output header to output file based on the input crystal type !> @note !> The program will end if a crystal type other than `PC` or `SD` is used. !> @endnote write ( iostd , * ) if ( system % crystalType == 'PC' ) then ! write ( iostd , '(\" Reading perfect crystal inputs.\")' ) ! else if ( system % crystalType == 'SD' ) then ! write ( iostd , '(\" Reading solid defect inputs.\")' ) ! else ! write ( iostd , '(\"Unknown crystal type\", a, \".\")' ) system % crystalType write ( iostd , '(\"Please only use PC for pristine crystal or SD for solid defect.\")' ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! write ( iostd , * ) ! input = trim ( trim ( system % exportDir ) // '/input' ) !! * Set the path for the input file from the PC export directory ! inquire ( file = trim ( input ), exist = fileExists ) !! * Check if the input file from the PC export directory exists ! !> * If the input file doesn't exist !>    * Output an error message and end the program if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" File : \", a, \" , does not exist!\")' ) trim ( input ) write ( iostd , '(\" Please make sure that folder : \", a, \" has been created successfully !\")' ) trim ( system % exportDir ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! !............................................................................................... !> * Open and read the [input](../page/inputOutput/exportedInput.html) file ! open ( 50 , file = trim ( input ), status = 'old' ) ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(ES24.15E3)' ) system % omega ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % nKpts !if ( kf < 0 ) kf = system%nKpts ! read ( 50 , '(a)' ) textDum ! allocate ( system % npws ( system % nKpts ), system % wk ( system % nKpts ), system % xk ( 3 , system % nKpts ) ) ! !allocate( system%groundState(system%nKpts) ) ! Don't allocate space for groundState because it is never used ! do ik = 1 , system % nKpts ! !read(50, '(3i10,4ES24.15E3)') iDum, system%groundState(ik), system%npws(ik), system%wk(ik), system%xk(1:3,ik) ! Don't read in groundState because it is never used read ( 50 , '(3i10,4ES24.15E3)' ) iDum , iDum , system % npws ( ik ), system % wk ( ik ), system % xk ( 1 : 3 , ik ) ! enddo ! read ( 50 , '(a)' ) textDum ! read ( 50 , * ) system % numOfGvecs ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % numOfPWs ! read ( 50 , '(a)' ) textDum ! !read(50, '(6i10)') fftxMin, fftxMax, fftyMin, fftyMax, fftzMin, fftzMax ! Don't read in FFT grid because it is never used read ( 50 , * ) ! read ( 50 , '(a)' ) textDum ! !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,1) !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,2) !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,3) ! Don't read in `at` because it is never used read ( 50 , * ) read ( 50 , * ) read ( 50 , * ) ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 1 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 2 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 3 ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % nIons ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % numOfTypes ! allocate ( system % posIon ( 3 , system % nIons ), system % atomTypeIndex ( system % nIons ) ) ! read ( 50 , '(a)' ) textDum ! do ni = 1 , system % nIons ! read ( 50 , '(i10, 3ES24.15E3)' ) system % atomTypeIndex ( ni ), system % posIon ( 1 : 3 , ni ) ! enddo ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(i10)' ) system % nBands ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(i10)' ) system % nSpins ! allocate ( system % atoms ( system % numOfTypes ) ) ! system % nProjs = 0 ! do iType = 1 , system % numOfTypes ! read ( 50 , '(a)' ) textDum read ( 50 , * ) system % atoms ( iType )% symbol ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% numOfAtoms ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% numProjs ! number of projectors ! allocate ( system % atoms ( iType )% projAngMom ( system % atoms ( iType )% numProjs ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , system % atoms ( iType )% numProjs ! read ( 50 , '(2i10)' ) l , ind system % atoms ( iType )% projAngMom ( ind ) = l ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% lmMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(2i10)' ) system % atoms ( iType )% nMax , system % atoms ( iType )% iRAugMax ! allocate ( system % atoms ( iType )% r ( system % atoms ( iType )% nMax ), system % atoms ( iType )% rab ( system % atoms ( iType )% nMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , system % atoms ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) system % atoms ( iType )% r ( i ), system % atoms ( iType )% rab ( i ) ! enddo ! allocate ( system % atoms ( iType )% wae ( system % atoms ( iType )% nMax , system % atoms ( iType )% numProjs ) ) allocate ( system % atoms ( iType )% wps ( system % atoms ( iType )% nMax , system % atoms ( iType )% numProjs ) ) ! read ( 50 , '(a)' ) textDum do j = 1 , system % atoms ( iType )% numProjs do i = 1 , system % atoms ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) system % atoms ( iType )% wae ( i , j ), system % atoms ( iType )% wps ( i , j ) ! write(iostd, '(2i5, ES24.15E3)') j, i, abs(system%atoms(iType)%wae(i, j)-system%atoms(iType)%wps(i, j)) ! enddo enddo ! allocate ( system % atoms ( iType )% F ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs ) ) !, system%atoms(iType)%numProjs) ) allocate ( system % atoms ( iType )% F1 ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs , system % atoms ( iType )% numProjs ) ) allocate ( system % atoms ( iType )% F2 ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs , system % atoms ( iType )% numProjs ) ) ! system % atoms ( iType )% F = 0.0_dp system % atoms ( iType )% F1 = 0.0_dp system % atoms ( iType )% F2 = 0.0_dp ! !> * Calculate `F`, `F1`, and `F2` using the all-electron and psuedowvefunctions !> @todo Look more into how AE and PS wavefunctions are combined to further understand this @endtodo !> @todo Move this behavior to another subroutine for clarity @endtodo do j = 1 , system % atoms ( iType )% numProjs ! iRAugMax = system % atoms ( iType )% iRAugMax ! system % atoms ( iType )% F ( 1 : iRAugMax , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% r ( 1 : iRAugMax ) * system % atoms ( iType )% rab ( 1 : iRAugMax ) ! do i = 1 , system % atoms ( iType )% numProjs !> @todo Figure out if differences in PC and SD `F1` calculations are intentional @endtodo !> @todo Figure out if should be `(wae_i wae_j - wps_i wps_j)r_{ab}` @endtodo !> @todo Figure out if first term in each should be conjugated for inner product form @endtodo !> @todo Figure out if `rab` plays role of dr within augmentation sphere @endtodo if ( system % crystalType == 'PC' ) then ! system % atoms ( iType )% F1 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) ! else if ( system % crystalType == 'SD' ) then ! system % atoms ( iType )% F1 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) ! endif ! system % atoms ( iType )% F2 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) + & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) enddo enddo ! system % nProjs = system % nProjs + system % atoms ( iType )% numOfAtoms * system % atoms ( iType )% lmMax ! deallocate ( system % atoms ( iType )% wae , system % atoms ( iType )% wps ) !deallocate ( system%groundState ) ! Don't use because groundState is never used ! enddo ! !............................................................................................... ! close ( 50 ) !! * Close the input file ! !> * Go through the `projAngMom` values for each projector for each atom !> and find the max to store in `JMAX` !> @todo Figure out if intentional to only use `JMAX` from SD input @endtodo JMAX = 0 do iType = 1 , system % numOfTypes ! do i = 1 , system % atoms ( iType )% numProjs ! if ( system % atoms ( iType )% projAngMom ( i ) > JMAX ) JMAX = system % atoms ( iType )% projAngMom ( i ) ! enddo ! enddo ! maxL = JMAX JMAX = 2 * JMAX + 1 ! do iType = 1 , system % numOfTypes ! allocate ( system % atoms ( iType )% bes_J_qr ( 0 : JMAX , system % atoms ( iType )% iRAugMax ) ) system % atoms ( iType )% bes_J_qr (:,:) = 0.0_dp ! enddo ! !> * End the local timer and write out the total time to read the inputs !> to the output file call cpu_time ( t2 ) write ( iostd , '(\" Reading input files done in:                \", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) flush ( iostd ) ! return ! end subroutine readQEExport","tags":"","loc":"proc/readqeexport.html","title":"readQEExport – Carrier Cross Sections"},{"text":"public subroutine readPWsSet() Read the g vectors in Miller indices from mgrid file and convert\n using reciprocal lattice vectors Walkthrough Open the mgrid file from Export directory from pw_export_for_TME Ignore the first two lines as they are comments Allocate space for the g vectors Initialize all of the g vectors to zero For each g vector Read in the g vector in terms of Miller indices Calculate the g vector using the reciprocal lattice vectors from input file\n Close the mgrid file Arguments None Contents Variables ig iDum iGx iGy iGz Source Code readPWsSet Variables Type Visibility Attributes Name Initial integer, public :: ig integer, public :: iDum integer, public :: iGx integer, public :: iGy integer, public :: iGz Source Code subroutine readPWsSet () !! Read the g vectors in Miller indices from `mgrid` file and convert !! using reciprocal lattice vectors !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer :: ig , iDum , iGx , iGy , iGz ! open ( 72 , file = trim ( solidDefect % exportDir ) // \"/mgrid\" ) !! * Open the `mgrid` file from Export directory from [[pw_export_for_tme(program)]] ! !> * Ignore the first two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( gvecs ( 3 , solidDefect % numOfGvecs ) ) !! * Allocate space for the g vectors ! gvecs (:,:) = 0.0_dp !! * Initialize all of the g vectors to zero ! do ig = 1 , solidDefect % numOfGvecs !! * For each g vector !!    * Read in the g vector in terms of Miller indices !!    * Calculate the g vector using the reciprocal lattice vectors from input file read ( 72 , '(4i10)' ) iDum , iGx , iGy , iGz gvecs ( 1 , ig ) = dble ( iGx ) * solidDefect % bg ( 1 , 1 ) + dble ( iGy ) * solidDefect % bg ( 1 , 2 ) + dble ( iGz ) * solidDefect % bg ( 1 , 3 ) gvecs ( 2 , ig ) = dble ( iGx ) * solidDefect % bg ( 2 , 1 ) + dble ( iGy ) * solidDefect % bg ( 2 , 2 ) + dble ( iGz ) * solidDefect % bg ( 2 , 3 ) gvecs ( 3 , ig ) = dble ( iGx ) * solidDefect % bg ( 3 , 1 ) + dble ( iGy ) * solidDefect % bg ( 3 , 2 ) + dble ( iGz ) * solidDefect % bg ( 3 , 3 ) enddo ! close ( 72 ) !! Close the `mgrid` file ! return ! end subroutine readPWsSet","tags":"","loc":"proc/readpwsset.html","title":"readPWsSet – Carrier Cross Sections"},{"text":"public subroutine distributePWsToProcs(nOfPWs, nOfBlocks) Determine how many g vectors each process should get Walkthrough Determine the base number of g vectors to give \n   to each process Determine the number of g vectors left over after that For each process, give the base amount and an extra\n   if there were any still left over Arguments Type Intent Optional Attributes Name integer, intent(in) :: nOfPWs Number of g vectors integer, intent(in) :: nOfBlocks Number of processes Contents Variables iStep iModu Source Code distributePWsToProcs Variables Type Visibility Attributes Name Initial integer, public :: iStep Number of g vectors per number of processes integer, public :: iModu Number of remaining g vectors after giving\n each process the same number of g vectors Source Code subroutine distributePWsToProcs ( nOfPWs , nOfBlocks ) !! Determine how many g vectors each process should get !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: nOfPWs !! Number of g vectors integer , intent ( in ) :: nOfBlocks !! Number of processes integer :: iStep !! Number of g vectors per number of processes integer :: iModu !! Number of remaining g vectors after giving !! each process the same number of g vectors ! iStep = int ( nOfPWs / nOfBlocks ) !! * Determine the base number of g vectors to give !!   to each process iModu = mod ( nOfPWs , nOfBlocks ) !! * Determine the number of g vectors left over after that ! do i = 0 , nOfBlocks - 1 !! * For each process, give the base amount and an extra !!   if there were any still left over counts ( i ) = iStep ! if ( iModu > 0 ) then ! counts ( i ) = counts ( i ) + 1 ! iModu = iModu - 1 ! endif ! enddo ! !displmnt(0) = 0 !do i = 1, nOfBlocks-1 !  displmnt(i) = displmnt(i-1) + counts(i) !enddo ! return ! end subroutine distributePWsToProcs","tags":"","loc":"proc/distributepwstoprocs.html","title":"distributePWsToProcs – Carrier Cross Sections"},{"text":"public subroutine checkIfCalculated(ik, tmes_file_exists) Determine if the output file for a given k point already exists Walkthrough Determine what the file name should be based on the k point index Check if that file already exists Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index logical, intent(out) :: tmes_file_exists Whether or not the output file exists Contents Variables Uelements intString Source Code checkIfCalculated Variables Type Visibility Attributes Name Initial character(len=300), public :: Uelements Output file name character(len=300), public :: intString String version of integer input ik Source Code subroutine checkIfCalculated ( ik , tmes_file_exists ) !! Determine if the output file for a given k point already exists !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index logical , intent ( out ) :: tmes_file_exists !! Whether or not the output file exists ! character ( len = 300 ) :: Uelements !! Output file name character ( len = 300 ) :: intString !! String version of integer input `ik` ! call int2str ( ik , intString ) write ( Uelements , '(\"/TMEs_kptI_\",a,\"_kptF_\",a)' ) trim ( intString ), trim ( intString ) !! * Determine what the file name should be based on the k point index ! inquire ( file = trim ( elementsPath ) // trim ( Uelements ), exist = tmes_file_exists ) !! * Check if that file already exists ! return ! end subroutine checkIfCalculated","tags":"","loc":"proc/checkifcalculated.html","title":"checkIfCalculated – Carrier Cross Sections"},{"text":"public subroutine calculatePWsOverlap(ik) Todo Document calculatePWsOverlap() Walkthrough Read the perfect crystal wavefunction ( readWfc ) Read the solid defect wavefunction ( readWfc ) Initialize Ufi for the given k point to complex double zero For each initial band, calculate \\sum \\phi_f&#94;*\\psi_i (overlap??) with each final band Todo Figure out what Ufi is supposed to be Note Ufi may be representing the overlap ( \\langle\\tilde{\\Psi}|\\tilde{\\Phi}\\rangle ). \n But if that is the case, why is \\Phi the one that has the complex conjugate? And why\n is there no integral? Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index Contents Variables ibi ibf Source Code calculatePWsOverlap Variables Type Visibility Attributes Name Initial integer, public :: ibi Loop index integer, public :: ibf Loop index Source Code subroutine calculatePWsOverlap ( ik ) !! @todo Document `calculatePWsOverlap()` @endtodo !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ibi , ibf !! Loop index ! call readWfc ( ik , perfectCrystal ) !! * Read the perfect crystal wavefunction ([[TMEModule(module):readWfc(subroutine)]]) ! call readWfc ( ik , solidDefect ) !! * Read the solid defect wavefunction ([[TMEModule(module):readWfc(subroutine)]]) ! Ufi (:,:, ik ) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize `Ufi` for the given k point to complex double zero ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal !! * For each initial band, calculate \\sum \\phi_f&#94;*\\psi_i (overlap??) with each final band !! Ufi ( ibf , ibi , ik ) = sum ( conjg ( solidDefect % wfc (:, ibf )) * perfectCrystal % wfc (:, ibi )) !! @todo Figure out what `Ufi` is supposed to be @endtodo !! @note !! `Ufi` may be representing the overlap (\\langle\\tilde{\\Psi}|\\tilde{\\Phi}\\rangle). !! But if that is the case, why is \\Phi the one that has the complex conjugate? And why !! is there no integral? !! @endnote !! !if ( ibi == ibf ) write(iostd,'(2i4,3ES24.15E3)') ibf, ibi, Ufi(ibf, ibi, ik), abs(Ufi(ibf, ibi, ik))**2 flush ( iostd ) ! enddo ! enddo ! return ! end subroutine calculatePWsOverlap","tags":"","loc":"proc/calculatepwsoverlap.html","title":"calculatePWsOverlap – Carrier Cross Sections"},{"text":"public subroutine readWfc(ik, system) Open the grid.ki file from pw_export_for_TME to get the indices for the wavefunction to be stored in, then\n open the wfc.ki file and read in the wavefunction for the \n proper bands and store in the proper indices in the system's wfc Walkthrough Convert the k point index to a string Open the grid.ki file from pw_export_for_TME Ignore the first two lines as they are comments Allocate space for pwGind For each plane wave for a given k point, \n   read in the indices for the plane waves that \n   are held in wfc.ki Close the grid.ki file Open the wfc.ki file from pw_export_for_TME Ignore the first two lines because they are comments\n * For each band before iBandInit , ignore all of the\n   plane waves for the given k point\n * Initialize the wavefunction to complex double zero For bands between iBandIinit and iBandIfinal ,\n   read in all of the plane waves for the given k point\n   and store them in the proper index of the system's wfc Close the wfc.ki file Deallocate space for pwGind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) Contents Variables ib ig iDumV pwGind wfc iks Source Code readWfc Variables Type Visibility Attributes Name Initial integer, public :: ib Loop index integer, public :: ig Loop index integer, public :: iDumV (3) Dummy vector to ignore g vectors from grid.ki integer, public, allocatable :: pwGind (:) Indices for the wavefunction of a given k point complex(kind=dp), public :: wfc Wavefunction character(len=300), public :: iks String version of the k point index Source Code subroutine readWfc ( ik , system ) !! Open the `grid.ki` file from [[pw_export_for_tme(program)]] !! to get the indices for the wavefunction to be stored in, then !! open the `wfc.ki` file and read in the wavefunction for the !! proper bands and store in the proper indices in the system's `wfc` !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ib , ig !! Loop index integer :: iDumV ( 3 ) !! Dummy vector to ignore g vectors from `grid.ki` integer , allocatable :: pwGind (:) !! Indices for the wavefunction of a given k point ! complex ( kind = dp ) :: wfc !! Wavefunction ! character ( len = 300 ) :: iks !! String version of the k point index ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , iks ) !! * Convert the k point index to a string ! open ( 72 , file = trim ( system % exportDir ) // \"/grid.\" // trim ( iks )) !! * Open the `grid.ki` file from [[pw_export_for_tme(program)]] ! !> * Ignore the first two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGind ( system % npws ( ik )) ) !! * Allocate space for `pwGind` ! do ig = 1 , system % npws ( ik ) !! * For each plane wave for a given k point, !!   read in the indices for the plane waves that !!   are held in `wfc.ki` ! read ( 72 , '(4i10)' ) pwGind ( ig ), iDumV ( 1 : 3 ) ! enddo ! close ( 72 ) !! * Close the `grid.ki` file ! open ( 72 , file = trim ( system % exportDir ) // \"/wfc.\" // trim ( iks )) !! * Open the `wfc.ki` file from [[pw_export_for_tme(program)]] ! !> Ignore the first two lines because they are comments read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandIinit - 1 do ig = 1 , system % npws ( ik ) !! * For each band before `iBandInit`, ignore all of the !!   plane waves for the given k point read ( 72 , * ) ! enddo enddo ! system % wfc (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize the wavefunction to complex double zero ! do ib = iBandIinit , iBandIfinal do ig = 1 , system % npws ( ik ) !! * For bands between `iBandIinit` and `iBandIfinal`, !!   read in all of the plane waves for the given k point !!   and store them in the proper index of the system's `wfc` ! read ( 72 , '(2ES24.15E3)' ) wfc system % wfc ( pwGind ( ig ), ib ) = wfc ! enddo enddo ! close ( 72 ) !! * Close the `wfc.ki` file ! deallocate ( pwGind ) !! * Deallocate space for `pwGind` ! return ! end subroutine readWfc","tags":"","loc":"proc/readwfc.html","title":"readWfc – Carrier Cross Sections"},{"text":"public subroutine readProjections(ik, system) Read in the projection \\langle\\beta|\\Psi\\rangle for each band Walkthrough Convert the k point index to a string Initialize cProj to all complex double zero Open the projections.iks file from pw_export_for_TME Ignore the first line as it is a comment Todo Get actual perfect crystal and solid defect output to test Todo Figure out if loop should be over solidDefect or perfectCrystal Todo Look into nSpins to figure out if it is needed * For each band, read in the projections \\langle\\beta|\\Psi\\rangle Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) Contents Variables i j iks Source Code readProjections Variables Type Visibility Attributes Name Initial integer, public :: i Loop index integer, public :: j Loop index character(len=300), public :: iks String version of k point index Source Code subroutine readProjections ( ik , system ) !! Read in the projection \\langle\\beta|\\Psi\\rangle for each band !! !! <H2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: i , j !! Loop index ! character ( len = 300 ) :: iks !! String version of k point index TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , iks ) !! * Convert the k point index to a string ! system % cProj (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize `cProj` to all complex double zero ! open ( 72 , file = trim ( system % exportDir ) // \"/projections.\" // trim ( iks )) !! * Open the `projections.iks` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) !! * Ignore the first line as it is a comment ! !write(6,'(\"Solid defect nBands: \", i3)') solidDefect%nBands !write(6,'(\"Solid defect nSpins: \", i3)') solidDefect%nSpins !write(6,'(\"Perfect crystal nBands: \", i3)') perfectCrystal%nBands !write(6,'(\"Perfect crystal nSpins: \", i3)') perfectCrystal%nSpins !! @todo Get actual perfect crystal and solid defect output to test @endtodo !! @todo Figure out if loop should be over `solidDefect` or `perfectCrystal` @endtodo !! @todo Look into `nSpins` to figure out if it is needed @endtodo do j = 1 , solidDefect % nBands ! number of bands do i = 1 , system % nProjs ! number of projections !! * For each band, read in the projections \\langle\\beta|\\Psi\\rangle ! read ( 72 , '(2ES24.15E3)' ) system % cProj ( i , j , 1 ) ! enddo enddo ! close ( 72 ) ! return ! end subroutine readProjections","tags":"","loc":"proc/readprojections.html","title":"readProjections – Carrier Cross Sections"},{"text":"public subroutine projectBeta(ik, betaSystem, projectedSystem) Todo Figure out what this subroutine really does Walkthrough Convert the k point index to a string Open the grid.ki file from pw_export_for_TME Ignore the next two lines as they are comments Allocate space for pwGind Read in the index for each plane wave Close the grid.ki file Allocate space for |\\beta\\rangle Initialize all values of |\\beta\\rangle to complex double zero Open the projectors.ki file from pw_export_for_TME Ignore the first line because it is a comment Ignore the second line because it is the number of projectors that\n   was already calculated in readQEExport and the number of plane waves for a given k point that was read in in the\n   same subroutine Read in each |\\beta\\rangle and store in the proper index of beta for the system Deallocate space for pwGind If the system that you are getting |\\beta\\rangle from \n   is the perfect crystal, then calculate \\langle\\beta|\\Phi\\rangle between iBandFinit and iBandFfinal If the system that you are getting |\\beta\\rangle from \n   is the solid defect, then calculate \\langle\\beta|\\Psi\\rangle between iBandIinit and iBandIfinal Deallocate space for |\\beta\\rangle Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: betaSystem Holds the structure for the system you are getting \\beta from\n (either perfectCrystal or solidDefect ) type( crystal ), intent(inout) :: projectedSystem Holds the structure for the system you are projecting\n (either perfectCrystal or solidDefect ) Contents Variables ig i j iDumV iDum pwGind iks Source Code projectBeta Variables Type Visibility Attributes Name Initial integer, public :: ig Loop index integer, public :: i Loop index integer, public :: j Loop index integer, public :: iDumV (3) Dummy variable to ignore input from file integer, public :: iDum Dummy variable to ignore input from file integer, public, allocatable :: pwGind (:) Indices for the wavefunction of a given k point character(len=300), public :: iks String version of the k point index Source Code subroutine projectBeta ( ik , betaSystem , projectedSystem ) !! @todo Figure out what this subroutine really does !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ig , i , j !! Loop index integer :: iDumV ( 3 ), iDum !! Dummy variable to ignore input from file integer , allocatable :: pwGind (:) !! Indices for the wavefunction of a given k point ! character ( len = 300 ) :: iks !! String version of the k point index ! TYPE ( crystal ), intent ( inout ) :: betaSystem !! Holds the structure for the system you are getting \\beta from !! (either `perfectCrystal` or `solidDefect`) TYPE ( crystal ), intent ( inout ) :: projectedSystem !! Holds the structure for the system you are projecting !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , iks ) !! * Convert the k point index to a string ! ! Reading PC projectors ! open ( 72 , file = trim ( betaSystem % exportDir ) // \"/grid.\" // trim ( iks )) !! * Open the `grid.ki` file from [[pw_export_for_tme(program)]] ! !> * Ignore the next two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGind ( betaSystem % npws ( ik )) ) !! * Allocate space for `pwGind` ! do ig = 1 , betaSystem % npws ( ik ) !! * Read in the index for each plane wave ! read ( 72 , '(4i10)' ) pwGind ( ig ), iDumV ( 1 : 3 ) ! enddo ! close ( 72 ) !! * Close the `grid.ki` file ! ! allocate ( betaSystem % beta ( numOfPWs , betaSystem % nProjs ) ) !! * Allocate space for |\\beta\\rangle ! betaSystem % beta (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values of |\\beta\\rangle to complex double zero ! open ( 73 , file = trim ( betaSystem % exportDir ) // \"/projectors.\" // trim ( iks )) !! * Open the `projectors.ki` file from [[pw_export_for_tme(program)]] ! read ( 73 , * ) !! * Ignore the first line because it is a comment read ( 73 , * ) !! * Ignore the second line because it is the number of projectors that !!   was already calculated in [[TMEModule(module):readQEExport(subroutine)]] !!   and the number of plane waves for a given k point that was read in in the !!   same subroutine ! do j = 1 , betaSystem % nProjs do i = 1 , betaSystem % npws ( ik ) !! * Read in each |\\beta\\rangle and store in the proper index of `beta` !!   for the system ! read ( 73 , '(2ES24.15E3)' ) betaSystem % beta ( pwGind ( i ), j ) ! enddo enddo ! close ( 73 ) ! deallocate ( pwGind ) !! * Deallocate space for `pwGind` ! if ( betaSystem % crystalType == \"PC\" ) then !! * If the system that you are getting |\\beta\\rangle from !!   is the perfect crystal, then calculate !!   \\langle\\beta|\\Phi\\rangle between `iBandFinit` !!   and `iBandFfinal` ! do j = iBandFinit , iBandFfinal do i = 1 , betaSystem % nProjs ! betaSystem % cCrossProj ( i , j , 1 ) = sum ( conjg ( betaSystem % beta (:, i )) * projectedSystem % wfc (:, j )) ! enddo enddo ! else if ( betaSystem % crystalType == \"SD\" ) then !! * If the system that you are getting |\\beta\\rangle from !!   is the solid defect, then calculate !!   \\langle\\beta|\\Psi\\rangle between `iBandIinit` !!   and `iBandIfinal` ! do j = iBandIinit , iBandIfinal do i = 1 , betaSystem % nProjs betaSystem % cCrossProj ( i , j , 1 ) = sum ( conjg ( betaSystem % beta (:, i )) * projectedSystem % wfc (:, j )) enddo enddo ! endif ! deallocate ( betaSystem % beta ) !! * Deallocate space for |\\beta\\rangle ! return ! end subroutine projectBeta","tags":"","loc":"proc/projectbeta.html","title":"projectBeta – Carrier Cross Sections"},{"text":"public subroutine pawCorrectionWfc(system) Calculates the augmentation part of the transition matrix element Todo Figure out what this subroutine really does Walkthrough Set the value of ispin to 1 Note ispin never has a value other than one, so I'm not sure\n  what its purpose is Initialize all values in paw_Wfc to complex double zero Initialize the base offset for cProj 's first index to zero For each atom in the system Get the index for the atom type Loop over the projectors twice, each time finding the\n  angular momentum quantum number ( l and l&#94;{\\prime} )\n  and magnetic quantum number ( m and m&#94;{\\prime} ) If l = l&#94;{\\prime} and m = m&#94;{\\prime} , loop over the bands to\n  calculate paw_Wfc Todo Figure out the significance of l = l&#94;{\\prime} and m = m&#94;{\\prime} Todo Figure out why the difference between SD and PC Todo Figure out why the difference between SD and PC Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) Contents Variables iIon iProj jProj ibi ibf m mPrime ispin LMBASE LM LMP l lPrime iAtomType atomicOverlap cProjIe cProjFe Source Code pawCorrectionWfc Variables Type Visibility Attributes Name Initial integer, public :: iIon Loop index over atoms integer, public :: iProj Loop index of projectors integer, public :: jProj Loop index of projectors integer, public :: ibi Loop index over bands integer, public :: ibf Loop index over bands integer, public :: m Loop index for magnetic quantum number for a given projector integer, public :: mPrime Loop index for magnetic quantum number for a given projector integer, public :: ispin integer, public :: LMBASE integer, public :: LM Index for cProj integer, public :: LMP Index for cProj integer, public :: l Angular momentum quantum number for a given projector integer, public :: lPrime Angular momentum quantum number for a given projector integer, public :: iAtomType Atom type index for a given ion in the system real(kind=dp), public :: atomicOverlap complex(kind=dp), public :: cProjIe complex(kind=dp), public :: cProjFe Source Code subroutine pawCorrectionWfc ( system ) !! Calculates the augmentation part of the transition matrix element !! @todo Figure out what this subroutine really does @endtodo !! !! <h2>Walkthrough</h2> !! implicit none integer :: iIon !! Loop index over atoms integer :: iProj , jProj !! Loop index of projectors integer :: ibi , ibf !! Loop index over bands integer :: m , mPrime !! Loop index for magnetic quantum number for a given projector integer :: ispin integer :: LMBASE integer :: LM , LMP !! Index for cProj integer :: l , lPrime !! Angular momentum quantum number for a given projector integer :: iAtomType !! Atom type index for a given ion in the system ! real ( kind = dp ) :: atomicOverlap ! complex ( kind = dp ) :: cProjIe , cProjFe ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! ispin = 1 !! * Set the value of `ispin` to 1 !! @note !! `ispin` never has a value other than one, so I'm not sure !!  what its purpose is !! @endnote ! system % paw_Wfc (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values in `paw_Wfc` to complex double zero ! LMBASE = 0 !! * Initialize the base offset for `cProj`'s first index to zero ! do iIon = 1 , system % nIons !! * For each atom in the system !!    * Get the index for the atom type !!    * Loop over the projectors twice, each time finding the !!      angular momentum quantum number (l and l&#94;{\\prime}) !!      and magnetic quantum number (m and m&#94;{\\prime}) !!    * If l = l&#94;{\\prime} and m = m&#94;{\\prime}, loop over the bands to !!      calculate `paw_Wfc` !! !! @todo Figure out the significance of l = l&#94;{\\prime} and m = m&#94;{\\prime} @endtodo ! iAtomType = system % atomTypeIndex ( iIon ) ! LM = 0 ! do iProj = 1 , system % atoms ( iAtomType )% numProjs ! l = system % atoms ( iAtomType )% projAngMom ( iProj ) ! do m = - l , l ! LM = LM + 1 !1st index for CPROJ ! LMP = 0 ! do jProj = 1 , system % atoms ( iAtomType )% numProjs ! lPrime = system % atoms ( iAtomType )% projAngMom ( jProj ) ! do mPrime = - lPrime , lPrime ! LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp ! if ( ( l == lPrime ). and .( m == mPrime ) ) then ! atomicOverlap = sum ( system % atoms ( iAtomType )% F1 (:, iProj , jProj )) ! do ibi = iBandIinit , iBandIfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! cProjIe = system % cProj ( LMP + LMBASE , ibi , ISPIN ) ! else if ( system % crystalType == 'SD' ) then ! cProjIe = system % cCrossProj ( LMP + LMBASE , ibi , ISPIN ) ! endif ! do ibf = iBandFinit , iBandFfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! cProjFe = conjg ( system % cCrossProj ( LM + LMBASE , ibf , ISPIN )) ! else if ( system % crystalType == 'SD' ) then ! cProjFe = conjg ( system % cProj ( LM + LMBASE , ibf , ISPIN )) ! endif ! system % paw_Wfc ( ibf , ibi ) = system % paw_Wfc ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe ! enddo ! enddo ! endif ! enddo ! enddo ! enddo ! enddo ! LMBASE = LMBASE + system % atoms ( iAtomType )% lmMax ! enddo ! return ! end subroutine pawCorrectionWfc","tags":"","loc":"proc/pawcorrectionwfc.html","title":"pawCorrectionWfc – Carrier Cross Sections"},{"text":"public subroutine pawCorrectionK(system) Todo Figure out what this subroutine really does Walkthrough Set the value of ispin to 1 Note ispin never has a value other than one, so I'm not sure\n  what its purpose is Start a timer Initialize all values in pawK to complex double zero Loop through the plane waves for a given process If this is the root process, output a status update every 1000 plane waves\n   and every multiple of 25000, giving an estimate of the time remaining at each step Todo Figure out if this output slows things down significantly Todo Figure out if formula gives accurate representation of time left Calculate q as \\sqrt{\\mathbf{G}\\cdot\\mathbf{G}} to get length of \\mathbf{G} Define a unit vector in the direction of \\mathbf{G} , \n   but only divide by the length if it is bigger than 1\\times10&#94;{-6} to avoid dividing by very small numbers Initialize the spherical harmonics to complex double zero Calculate spherical harmonics with argument v_in up to Y_{J_{\\text{max}}}&#94;{\\pm J_{\\text{max}}} Initialize the base offset for cProj 's first index to zero For each atom type, loop through the r points\n   in the augmentation sphere and calculate the \n   spherical Bessel functions from 0 to JMAX at each point Todo Figure out if this should be system Todo Figure out significance of \"qr\" point Todo Test if can just directly store in each atom type's bes_J_qr For each atom in the system Calculate \\mathbf{G}\\cdot\\mathbf{r} Calculate e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} Get the index for the atom type Loop over the projectors, finding l, m for each For each possible m Calculate \\text{FI} = j_l\\cdot F where j_l is\n     the Bessel function and F is for a given projector Calculate \\text{VifQ_aug} = e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}}\n     Y_l&#94;m(\\mathbf{G}/|\\mathbf{G}|)(-i)&#94;l\\text{FI} Loop over the bands, summing VifQ_aug*cProj to get pawK Todo Figure out if this should be gDotR Todo Figure out why this is called ATOMIC_CENTER Todo Figure out why the difference between SD and PC Todo Figure out why the difference between SD and PC Todo Figure out why the difference between SD and PC Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) Contents Variables ibi ibf iPW iProj iR iAtomType iIon l m ispin LMBASE LM ind qDotR t1 t2 v_in JL q FI Y ATOMIC_CENTER VifQ_aug Source Code pawCorrectionK Variables Type Visibility Attributes Name Initial integer, public :: ibi Loop index over bands integer, public :: ibf Loop index over bands integer, public :: iPW Loop index over plane waves for a given process integer, public :: iProj Loop index over projectors integer, public :: iR Loop index over radial mesh (up to augmentation sphere) integer, public :: iAtomType Loop index over atom types integer, public :: iIon Loop index over ions in system integer, public :: l Angular momentum quantum number integer, public :: m Magnetic quantum number integer, public :: ispin integer, public :: LMBASE integer, public :: LM integer, public :: ind real(kind=dp), public :: qDotR \\mathbf{G}\\cdot\\mathbf{r} real(kind=dp), public :: t1 Start time real(kind=dp), public :: t2 End time real(kind=dp), public :: v_in (3) Unit vector in the direction of \\mathbf{G} real(kind=dp), public :: JL (0:JMAX) Spherical bessel functions for a point up to JMAX real(kind=dp), public :: q real(kind=dp), public :: FI complex(kind=dp), public :: Y ((JMAX+1)**2) All spherical harmonics up to some max momentum complex(kind=dp), public :: ATOMIC_CENTER e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} complex(kind=dp), public :: VifQ_aug Source Code subroutine pawCorrectionK ( system ) !! @todo Figure out what this subroutine really does @endtodo !! !! <h2>Walkthrough</h2> ! implicit none ! !integer, intent(in) :: ik ! integer :: ibi , ibf !! Loop index over bands integer :: iPW !! Loop index over plane waves for a given process integer :: iProj !! Loop index over projectors integer :: iR !! Loop index over radial mesh (up to augmentation sphere) integer :: iAtomType !! Loop index over atom types integer :: iIon !! Loop index over ions in system integer :: l !! Angular momentum quantum number integer :: m !! Magnetic quantum number integer :: ispin integer :: LMBASE integer :: LM integer :: ind ! real ( kind = dp ) :: qDotR !! \\mathbf{G}\\cdot\\mathbf{r} real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time real ( kind = dp ) :: v_in ( 3 ) !! Unit vector in the direction of \\mathbf{G} real ( kind = dp ) :: JL ( 0 : JMAX ) !! Spherical bessel functions for a point up to `JMAX` real ( kind = dp ) :: q real ( kind = dp ) :: FI ! complex ( kind = dp ) :: Y ( ( JMAX + 1 ) ** 2 ) !! All spherical harmonics up to some max momentum complex ( kind = dp ) :: ATOMIC_CENTER !! e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} complex ( kind = dp ) :: VifQ_aug ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! ispin = 1 !! * Set the value of `ispin` to 1 !! @note !! `ispin` never has a value other than one, so I'm not sure !!  what its purpose is !! @endnote ! call cpu_time ( t1 ) !! * Start a timer ! system % pawK (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values in `pawK` to complex double zero ! do iPW = nPWsI ( myid ), nPWsF ( myid ) !! * Loop through the plane waves for a given process ! if ( myid == root ) then if ( ( iPW == nPWsI ( myid ) + 1000 ) . or . ( mod ( iPW , 25000 ) == 0 ) . or . ( iPW == nPWsF ( myid )) ) then !! * If this is the root process, output a status update every 1000 plane waves !!   and every multiple of 25000, giving an estimate of the time remaining at each step !!   @todo Figure out if this output slows things down significantly @endtodo !!   @todo Figure out if formula gives accurate representation of time left @endtodo ! call cpu_time ( t2 ) ! write ( iostd , '(\"        Done \", i10, \" of\", i10, \" k-vecs. ETR : \", f10.2, \" secs.\")' ) & iPW , nPWsF ( myid ) - nPWsI ( myid ) + 1 , ( t2 - t1 ) * ( nPWsF ( myid ) - nPWsI ( myid ) + 1 - iPW ) / iPW ! flush ( iostd ) ! !call cpu_time(t1) ! endif endif ! q = sqrt ( sum ( gvecs (:, iPW ) * gvecs (:, iPW ))) !! * Calculate `q` as \\sqrt{\\mathbf{G}\\cdot\\mathbf{G}} !!   to get length of \\mathbf{G} ! !> * Define a unit vector in the direction of \\mathbf{G}, !>   but only divide by the length if it is bigger than !>   1\\times10&#94;{-6} to avoid dividing by very small numbers v_in (:) = gvecs (:, iPW ) if ( abs ( q ) > 1.0e-6_dp ) v_in = v_in / q ! Y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize the spherical harmonics to complex double zero call ylm ( v_in , JMAX , Y ) !! * Calculate spherical harmonics with argument `v_in` up to !!   Y_{J_{\\text{max}}}&#94;{\\pm J_{\\text{max}}} ! LMBASE = 0 !! * Initialize the base offset for `cProj`'s first index to zero ! do iAtomType = 1 , system % numOfTypes ! do iR = 1 , system % atoms ( iAtomType )% iRAugMax !! * For each atom type, loop through the r points !!   in the augmentation sphere and calculate the !!   spherical Bessel functions from 0 to `JMAX` !!   at each point ! JL = 0.0_dp ! call bessel_j ( q * solidDefect % atoms ( iAtomType )% r ( iR ), JMAX , JL ) ! returns the spherical bessel at qr point !! @todo Figure out if this should be `system` @endtodo !! @todo Figure out significance of \"qr\" point @endtodo ! system % atoms ( iAtomType )% bes_J_qr (:, iR ) = JL (:) !! @todo Test if can just directly store in each atom type's `bes_J_qr` @endtodo ! enddo ! enddo ! do iIon = 1 , system % nIons !! * For each atom in the system !!    * Calculate \\mathbf{G}\\cdot\\mathbf{r} !!    * Calculate e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} !!    * Get the index for the atom type !!    * Loop over the projectors, finding l, m for each !!    * For each possible m !!       * Calculate \\text{FI} = j_l\\cdot F where j_l is !!         the Bessel function and F is for a given projector !!       * Calculate \\text{VifQ_aug} = e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} !!         Y_l&#94;m(\\mathbf{G}/|\\mathbf{G}|)(-i)&#94;l\\text{FI} !!       * Loop over the bands, summing `VifQ_aug*cProj` to get `pawK` ! qDotR = sum ( gvecs (:, iPW ) * system % posIon (:, iIon )) !! @todo Figure out if this should be `gDotR` @endtodo ! !> @todo Figure out why this is called `ATOMIC_CENTER` @endtodo !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! ATOMIC_CENTER = exp ( - ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! else if ( system % crystalType == 'SD' ) then ! ATOMIC_CENTER = exp ( ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! endif ! iAtomType = system % atomTypeIndex ( iIon ) ! LM = 0 ! do iProj = 1 , system % atoms ( iAtomType )% numProjs ! l = system % atoms ( iAtomType )% projAngMom ( iProj ) ! do m = - l , l ! LM = LM + 1 !1st index for CPROJ ! FI = 0.0_dp ! FI = sum ( system % atoms ( iAtomType )% bes_J_qr ( l ,:) * system % atoms ( iAtomType )% F (:, iProj )) ! radial part integration F contains rab ! ind = l * ( l + 1 ) + m + 1 ! index for spherical harmonics ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! VifQ_aug = ATOMIC_CENTER * Y ( ind ) * ( - II ) ** l * FI ! else if ( system % crystalType == 'SD' ) then ! VifQ_aug = ATOMIC_CENTER * conjg ( Y ( ind )) * ( II ) ** l * FI ! endif ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! system % pawK ( ibf , ibi , iPW ) = system % pawK ( ibf , ibi , iPW ) + & VifQ_aug * system % cProj ( LM + LMBASE , ibi , ISPIN ) ! else if ( system % crystalType == 'SD' ) then ! system % pawK ( ibf , ibi , iPW ) = system % pawK ( ibf , ibi , iPW ) + & VifQ_aug * conjg ( system % cProj ( LM + LMBASE , ibi , ISPIN )) ! endif ! enddo ! enddo ! ENDDO ENDDO LMBASE = LMBASE + system % atoms ( iAtomType )% lmMax ENDDO ! enddo ! !system%pawK(:,:,:) = system%pawK(:,:,:)*4.0_dp*pi/sqrt(solidDefect%omega) ! return ! end subroutine pawCorrectionK","tags":"","loc":"proc/pawcorrectionk.html","title":"pawCorrectionK – Carrier Cross Sections"},{"text":"public subroutine ylm(V_in, LMAX, Y) Returns the spherical harmonics for a given argument vector up to the maximum value of l given Description Purpose The spherical harmonics (Condon and Shortley convention) Y_0&#94;0,Y_1&#94;{-1},Y_1&#94;0,Y_1&#94;1,Y_2&#94;{-2} ... Y_{l_{\\text{max}}}&#94;{\\pm l_{\\text{max}}} for vector \\mathbf{V} (given in Cartesian coordinates)\n        are calculated. In the Condon Shortley convention the\n        spherical harmonics are defined as Y_l&#94;m = (-1)&#94;m \\sqrt{\\frac{1}{\\pi}} P_l&#94;m(\\cos{\\theta})\n        e&#94;{im\\phi} where P_l&#94;m(\\cos{\\theta}) is the normalized Associated\n        Legendre function. Thus, Y_l&#94;{-m} = (-1)&#94;m (Y_l&#94;m)&#94;* Usage DOUBLE PRECISION V ( 3 ), Y ( 5 * 5 ) V ( 1 ) = ... V ( 2 ) = ... V ( 3 ) = ... CALL YLM ( V , 4 , Y ) Argument Description V - DOUBLE PRECISION vector, dimension 3        (input) Must be given in Cartesian coordinates.\n                   Conversion of V to polar coordinates gives the\n                   angles \\theta and \\phi necessary for the calculation\n                   of the spherical harmonics. LMAX - INTEGER value                               (input) upper bound of l for which spherical harmonics\n                   will be calculated constraint: LMAX >= 0 Y - COMPLEX*16 array, dimension (LMAX+1)**2 (output) contains the calculated spherical harmonics Y(1) for l=0 ( m = 0 ) Y(2), ..., Y(4) for l = 1 ( m = -1, 0, 1 ) ... Y(LMAX*LMAX+1), ..., Y((LMAX+1)*(LMAX+1)) for l = l_{\\text{max}} ( m = -l,...,l ) constraint: Dimension of Y \\geq (l_{\\text{max}} + 1)&#94;2 (not checked) Used Subroutines (Directly Called) none Indirectly Called Subroutines none Input/Output (Read/Write) none Machine Dependent Program Parts Type COMPLEX*16 is used which does not conform to the\n           FORTRAN 77 standard.\n           Also the non-standard type conversion function DCMPLX() is used which combines two double precision values into\n           one double complex value. Method The basic algorithm used to calculate the spherical\n           harmonics for vector \\mathbf{V} is as follows: Y ( 0 , 0 ) Y ( 1 , 0 ) Y ( 1 , 1 ) Y ( 1 , - 1 ) = - Y ( 1 , 1 ) DO L = 2 , LMAX Y ( L , L ) = f ( Y ( L - 1 , L - 1 )) ... Formula 1 Y ( L , L - 1 ) = f ( Y ( L - 1 , L - 1 )) ... Formula 2 DO M = L - 2 , 0 , - 1 Y ( L , M ) = f ( Y ( L - 1 , M ) , Y ( L - 2 , M )) ... Formula 2 Y ( L , - M ) = ( - 1 ) ** M * CONJG ( Y ( L , M )) ENDDO ENDDO Formulas Starting values: Y_0&#94;0 = \\sqrt{\\dfrac{1}{4\\pi}} Y_1&#94;0 = \\sqrt{\\dfrac{3}{4\\pi}}\\cos\\theta Y_1&#94;1 = -\\sqrt{\\dfrac{3}{8\\pi}}\\sin\\theta e&#94;{i\\phi} Formula 1: Y_l&#94;l = -\\sqrt{\\dfrac{2l+1}{2l}}\\sin\\theta e&#94;{i\\phi}Y_{l-1}&#94;{l-1} Formula 2: Y_l&#94;m = \\sqrt{\\dfrac{(2l-1)(2l+1)}{(l-m)(l+m)}}\\cos\\theta Y_{l-1}&#94;m - \n                    \\sqrt{\\dfrac{(l-1+m)(l-1-m)(2l+1)}{(2l-3)(l-m)(l+m)}} Y_{l-2}&#94;m Formula 3: (not used in the algorithm because of the division\n                    by \\sin\\theta which may be zero) Y_l&#94;m = -\\sqrt{\\dfrac{4(m+1)(m+1)}{(l+m+1)(l-m)}}\\dfrac{\\cos\\theta}{\\sin\\theta}e&#94;{i\\phi}Y_1&#94;{m+1} -\n                    \\sqrt{\\dfrac{(l-m-1)(l+m+2)}{(l-m)(l+m+1)}}e&#94;{-2i\\phi}Y_l&#94;{m+2} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_in (3) Vector, argument of the spherical harmonics (we calculate Y_l&#94;m(\\mathbf{v}/|\\mathbf{v}|) ) integer, intent(in) :: LMAX Spherical harmonics are calculated for l = 0, 1, ..., l_{\\text{max}} complex(kind=dp), intent(out) :: Y (*) Array containing Y_l&#94;m(\\mathbf{v}) for several l,m Contents Variables pi I2L I4L2 INDEX INDEX2 L M MSIGN A B C AB ABC ABMAX ABCMAX V D4LL1C D2L13 COSTH SINTH COSPH SINPH TEMP1 TEMP2 TEMP3 YLLR YLL1R YL1L1R YLMR YLLI YLL1I YL1L1I YLMI Source Code ylm Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 3.1415926535897932384626433_dp integer, public :: I2L integer, public :: I4L2 integer, public :: INDEX integer, public :: INDEX2 integer, public :: L integer, public :: M integer, public :: MSIGN real(kind=dp), public :: A real(kind=dp), public :: B real(kind=dp), public :: C real(kind=dp), public :: AB real(kind=dp), public :: ABC real(kind=dp), public :: ABMAX real(kind=dp), public :: ABCMAX real(kind=dp), public :: V (3) real(kind=dp), public :: D4LL1C real(kind=dp), public :: D2L13 real(kind=dp), public :: COSTH real(kind=dp), public :: SINTH real(kind=dp), public :: COSPH real(kind=dp), public :: SINPH real(kind=dp), public :: TEMP1 real(kind=dp), public :: TEMP2 real(kind=dp), public :: TEMP3 real(kind=dp), public :: YLLR real(kind=dp), public :: YLL1R real(kind=dp), public :: YL1L1R real(kind=dp), public :: YLMR real(kind=dp), public :: YLLI real(kind=dp), public :: YLL1I real(kind=dp), public :: YL1L1I real(kind=dp), public :: YLMI Source Code subroutine ylm ( v_in , lmax , y ) !! Returns the [spherical harmonics](http://mathworld.wolfram.com/SphericalHarmonic.html) !! for a given argument vector up to the maximum value of l given !! !! <h2>Description</h2> !!   <h3>Purpose</h3> !!        The spherical harmonics (Condon and Shortley convention) !!          Y_0&#94;0,Y_1&#94;{-1},Y_1&#94;0,Y_1&#94;1,Y_2&#94;{-2} ... Y_{l_{\\text{max}}}&#94;{\\pm l_{\\text{max}}} !!        for vector \\mathbf{V} (given in Cartesian coordinates) !!        are calculated. In the Condon Shortley convention the !!        spherical harmonics are defined as !!         Y_l&#94;m = (-1)&#94;m \\sqrt{\\frac{1}{\\pi}} P_l&#94;m(\\cos{\\theta}) !!        e&#94;{im\\phi}  !!        where  P_l&#94;m(\\cos{\\theta}) is the normalized Associated !!        Legendre function. Thus, !!                       Y_l&#94;{-m} = (-1)&#94;m (Y_l&#94;m)&#94;*  !! !!   <h3>Usage</h3> !! !! !!        DOUBLE PRECISION V(3), Y(5*5) !!        V(1) = ... !!        V(2) = ... !!        V(3) = ... !!        CALL YLM(V,4,Y) !! !!   <h3>Argument Description</h3> !!     <ul> !!          <li> !!                  `V`      - `DOUBLE PRECISION` vector, dimension 3        (input)<br/> !!                   Must be given in Cartesian coordinates. !!                   Conversion of V to polar coordinates gives the !!                   angles \\theta and \\phi necessary for the calculation !!                   of the spherical harmonics. !!          </li> !!          <li> !!                   `LMAX`   - `INTEGER` value                               (input)<br/> !!                   upper bound of l for which spherical harmonics !!                   will be calculated<br/> !!                   constraint: `LMAX >= 0` !!          </li> !!          <li> !!                   `Y`      - `COMPLEX*16` array, dimension `(LMAX+1)**2`    (output)<br/> !!                   contains the calculated spherical harmonics<br/> !!                   `Y(1)` for l=0 (m = 0)<br/> !!                   `Y(2), ..., Y(4)` for l = 1 (m = -1, 0, 1)<br/> !!                   ...<br/> !!                   `Y(LMAX*LMAX+1), ..., Y((LMAX+1)*(LMAX+1))` for l = l_{\\text{max}} !!                            (m = -l,...,l)<br/> !!                   constraint: Dimension of `Y` \\geq (l_{\\text{max}} + 1)&#94;2 (not checked) !!          </li> !!        </ul> !! !!   <h3>Used Subroutines (Directly Called)</h3> !!           none !! !!   <h3>Indirectly Called Subroutines</h3> !!           none !! !!   <h3>Input/Output (Read/Write)</h3> !!           none !! !!   <h3>Machine Dependent Program Parts</h3> !!           Type `COMPLEX*16` is used which does not conform to the !!           FORTRAN 77 standard. !!           Also the non-standard type conversion function `DCMPLX()` !!           is used which combines two double precision values into !!           one double complex value. !! !!   <h3>Method</h3> !!           The basic algorithm used to calculate the spherical !!           harmonics for vector \\mathbf{V} is as follows: !! !! !!           Y(0,0) !!           Y(1,0) !!           Y(1,1) !!           Y(1,-1) = -Y(1,1) !!           DO L = 2, LMAX !!              Y(L,L)   = f(Y(L-1,L-1)) ... Formula 1 !!              Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 !!              DO M = L-2, 0, -1 !!                 Y(L,M) = f(Y(L-1,M),Y(L-2,M)) ... Formula 2 !!                 Y(L,-M)= (-1)**M*CONJG(Y(L,M)) !!              ENDDO !!           ENDDO !! !!   <h3>Formulas</h3> !!        Starting values: !!          Y_0&#94;0 = \\sqrt{\\dfrac{1}{4\\pi}} !!          Y_1&#94;0 = \\sqrt{\\dfrac{3}{4\\pi}}\\cos\\theta !!          Y_1&#94;1 = -\\sqrt{\\dfrac{3}{8\\pi}}\\sin\\theta e&#94;{i\\phi} !!        Formula 1: !!          Y_l&#94;l = -\\sqrt{\\dfrac{2l+1}{2l}}\\sin\\theta e&#94;{i\\phi}Y_{l-1}&#94;{l-1} !!        Formula 2: !!          Y_l&#94;m = \\sqrt{\\dfrac{(2l-1)(2l+1)}{(l-m)(l+m)}}\\cos\\theta Y_{l-1}&#94;m - !!                    \\sqrt{\\dfrac{(l-1+m)(l-1-m)(2l+1)}{(2l-3)(l-m)(l+m)}} Y_{l-2}&#94;m !!        Formula 3: (not used in the algorithm because of the division !!                    by \\sin\\theta which may be zero) !!          Y_l&#94;m = -\\sqrt{\\dfrac{4(m+1)(m+1)}{(l+m+1)(l-m)}}\\dfrac{\\cos\\theta}{\\sin\\theta}e&#94;{i\\phi}Y_1&#94;{m+1} - !!                    \\sqrt{\\dfrac{(l-m-1)(l+m+2)}{(l-m)(l+m+1)}}e&#94;{-2i\\phi}Y_l&#94;{m+2} !! ! !REVISION HISTORY: !   26. April 1994                                   Version 1.2 !   Taken 8 1 98 from SRC_lapw2 to SRC_telnes !   Updated November 2004 (Kevin Jorissen) !   cosmetics March 2005 (Kevin Jorissen) ! implicit none ! !   In/Output : ! integer , intent ( in ) :: LMAX !! Spherical harmonics are calculated for !! l = 0, 1, ..., l_{\\text{max}} real ( kind = dp ), intent ( in ) :: V_in ( 3 ) !! Vector, argument of the spherical harmonics (we calculate !! Y_l&#94;m(\\mathbf{v}/|\\mathbf{v}|)) complex ( kind = dp ), intent ( out ) :: Y ( * ) !! Array containing Y_l&#94;m(\\mathbf{v}) for several l,m ! !   Local variables : real ( kind = dp ), parameter :: pi = 3.1415926535897932384626433_dp ! INTEGER :: I2L , I4L2 , INDEX , INDEX2 , L , M , MSIGN real ( kind = dp ) :: A , B , C , AB , ABC , ABMAX , ABCMAX , V ( 3 ) real ( kind = dp ) :: D4LL1C , D2L13 real ( kind = dp ) :: COSTH , SINTH , COSPH , SINPH real ( kind = dp ) :: TEMP1 , TEMP2 , TEMP3 real ( kind = dp ) :: YLLR , YLL1R , YL1L1R , YLMR real ( kind = dp ) :: YLLI , YLL1I , YL1L1I , YLMI ! ! Y(0,0) ! do INDEX = 1 , 3 V ( INDEX ) = dble ( V_in ( INDEX )) enddo YLLR = 1.0_dp / sqrt ( 4.0_dp * PI ) YLLI = 0.0_dp Y ( 1 ) = CMPLX ( YLLR , YLLI , kind = dp ) ! ! continue only if spherical harmonics for (L .GT. 0) are desired ! IF ( LMAX . LE . 0 ) GOTO 999 ! ! calculate sin(Phi), cos(Phi), sin(Theta), cos(Theta) ! Theta, Phi ... polar angles of vector V ! ABMAX = MAX ( ABS ( V ( 1 )), ABS ( V ( 2 ))) IF ( ABMAX . GT . 0.0_dp ) THEN A = V ( 1 ) / ABMAX B = V ( 2 ) / ABMAX AB = SQRT ( A * A + B * B ) COSPH = A / AB SINPH = B / AB ELSE COSPH = 1.0_dp SINPH = 0.0_dp ENDIF ABCMAX = MAX ( ABMAX , ABS ( V ( 3 ))) IF ( ABCMAX . GT . dble ( 0 )) THEN A = V ( 1 ) / ABCMAX B = V ( 2 ) / ABCMAX C = V ( 3 ) / ABCMAX AB = A * A + B * B ABC = SQRT ( AB + C * C ) COSTH = C / ABC SINTH = SQRT ( AB ) / ABC ELSE COSTH = 1.0_dp SINTH = 0.0_dp ENDIF ! ! Y(1,0) ! Y ( 3 ) = CMPLX ( sqrt ( 3.0_dp ) * YLLR * COSTH , 0.0_dp , kind = dp ) ! ! Y(1,1) ( = -DCONJG(Y(1,-1))) ! TEMP1 = - SQRT ( 1.5_dp ) * YLLR * SINTH Y ( 4 ) = CMPLX ( TEMP1 * COSPH , TEMP1 * SINPH , kind = dp ) Y ( 2 ) = - CONJG ( Y ( 4 )) ! DO L = 2 , LMAX INDEX = L * L + 1 INDEX2 = INDEX + 2 * L MSIGN = 1 - 2 * MOD ( L , 2 ) ! ! YLL = Y(L,L) = f(Y(L-1,L-1)) ... Formula 1 ! YL1L1R = DBLE ( Y ( INDEX - 1 )) YL1L1I = DIMAG ( Y ( INDEX - 1 )) TEMP1 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L )) * SINTH YLLR = TEMP1 * ( COSPH * YL1L1R - SINPH * YL1L1I ) YLLI = TEMP1 * ( COSPH * YL1L1I + SINPH * YL1L1R ) Y ( INDEX2 ) = CMPLX ( YLLR , YLLI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! ! YLL1 = Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 ! (the coefficient for Y(L-2,L-1) in Formula 2 is zero) ! TEMP2 = SQRT ( DBLE ( 2 * L + 1 )) * COSTH YLL1R = TEMP2 * YL1L1R YLL1I = TEMP2 * YL1L1I Y ( INDEX2 ) = CMPLX ( YLL1R , YLL1I , kind = dp ) Y ( INDEX ) = - cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = -dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! I4L2 = INDEX2 - 4 * L + 2 I2L = INDEX2 - 2 * L D4LL1C = COSTH * SQRT ( DBLE ( 4 * L * L - 1 )) D2L13 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L - 3 )) ! DO M = L - 2 , 0 , - 1 ! ! YLM = Y(L,M) = f(Y(L-2,M),Y(L-1,M)) ... Formula 2 ! TEMP1 = 1.0_dp / SQRT ( DBLE (( L + M ) * ( L - M ))) TEMP2 = D4LL1C * TEMP1 TEMP3 = D2L13 * SQRT ( DBLE (( L + M - 1 ) * ( L - M - 1 ))) * TEMP1 YLMR = TEMP2 * DBLE ( Y ( I2L )) + TEMP3 * DBLE ( Y ( I4L2 )) YLMI = TEMP2 * DIMAG ( Y ( I2L )) + TEMP3 * DIMAG ( Y ( I4L2 )) Y ( INDEX2 ) = CMPLX ( YLMR , YLMI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) ! MSIGN = - MSIGN INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 I4L2 = I4L2 - 1 I2L = I2L - 1 ENDDO ENDDO ! 999 RETURN END subroutine ylm","tags":"","loc":"proc/ylm.html","title":"ylm – Carrier Cross Sections"},{"text":"public subroutine bessel_j(x, lmax, jl) Generates the spherical bessel function of the first kind for the given argument x and all possible indices from 0 to lmax Walkthrough If x is less than zero, return 0 for all\n   indices but 0 which is 1 Explicitly calculate the first 2 functions so can use \n   recursive definition for later terms Define the rest of the functions as j_l = (2l-1)j_{l-1}/x - j_{l-2} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: lmax real(kind=dp), intent(out) :: jl (0:lmax) Contents Variables l Source Code bessel_j Variables Type Visibility Attributes Name Initial integer, public :: l Source Code subroutine bessel_j ( x , lmax , jl ) !! Generates the !! [spherical bessel function of the first kind](http://mathworld.wolfram.com/SphericalBesselFunctionoftheFirstKind.html) !! for the given argument x and all possible indices from 0 to `lmax` !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: lmax integer :: l ! real ( kind = dp ), intent ( in ) :: x real ( kind = dp ), intent ( out ) :: jl ( 0 : lmax ) ! if ( x <= 0.0_dp ) then !! * If x is less than zero, return 0 for all !!   indices but 0 which is 1 ! jl = 0.0_dp jl ( 0 ) = 1.0_dp ! return ! end if ! !> * Explicitly calculate the first 2 functions so can use !>   recursive definition for later terms jl ( 0 ) = sin ( x ) / x if ( lmax <= 0 ) return jl ( 1 ) = ( jl ( 0 ) - cos ( x )) / x if ( lmax == 1 ) return ! do l = 2 , lmax !! * Define the rest of the functions as !!   j_l = (2l-1)j_{l-1}/x - j_{l-2} ! jl ( l ) = dble ( 2 * l - 1 ) * jl ( l - 1 ) / x - jl ( l - 2 ) ! enddo ! return ! end subroutine bessel_j","tags":"","loc":"proc/bessel_j.html","title":"bessel_j – Carrier Cross Sections"},{"text":"public subroutine writeResults(ik) Todo Document writeResults() @endto Walkthrough Start a timer Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index Contents Variables ibi ibf totalNumberOfElements t1 t2 text Uelements Source Code writeResults Variables Type Visibility Attributes Name Initial integer, public :: ibi Loop index over bands integer, public :: ibf Loop index over bands integer, public :: totalNumberOfElements real(kind=dp), public :: t1 Start time real(kind=dp), public :: t2 End time character(len=300), public :: text character(len=300), public :: Uelements Source Code subroutine writeResults ( ik ) !! @todo Document `writeResults()` @endto !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index ! integer :: ibi , ibf !! Loop index over bands integer :: totalNumberOfElements real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time ! character ( len = 300 ) :: text character ( len = 300 ) :: Uelements ! call cpu_time ( t1 ) !! * Start a timer ! call readEigenvalues ( ik ) ! write ( iostd , '(\" Writing Ufi(:,:).\")' ) ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) ! write ( 17 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(a51, ES24.15E3)'' \", ES24.15E3)' ) solidDefect % omega ! text = \"# Total number of <f|U|i> elements, Initial States (bandI, bandF), Final States (bandI, bandF)\" write ( 17 , '(a, \" Format : ''(5i10)''\")' ) trim ( text ) ! totalNumberOfElements = ( iBandIfinal - iBandIinit + 1 ) * ( iBandFfinal - iBandFinit + 1 ) write ( 17 , '(5i10)' ) totalNumberOfElements , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! write ( 17 , '(\"# Final Band, Initial Band, Delta energy, Complex <f|U|i>, |<f|U|i>|&#94;2 Format : ''(2i10,4ES24.15E3)''\")' ) ! do ibf = iBandFinit , iBandFfinal do ibi = iBandIinit , iBandIfinal ! write ( 17 , 1001 ) ibf , ibi , eigvI ( ibi ) - eigvF ( ibf ), Ufi ( ibf , ibi , ik ), abs ( Ufi ( ibf , ibi , ik )) ** 2 ! enddo enddo ! close ( 17 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Writing Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! return ! end subroutine writeResults","tags":"","loc":"proc/writeresults.html","title":"writeResults – Carrier Cross Sections"},{"text":"public subroutine readUfis(ik) Todo Document readUfis() Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Variables ibi ibf totalNumberOfElements iDum i rDum t1 t2 cUfi Uelements Source Code readUfis Variables Type Visibility Attributes Name Initial integer, public :: ibi integer, public :: ibf integer, public :: totalNumberOfElements integer, public :: iDum integer, public :: i real(kind=dp), public :: rDum real(kind=dp), public :: t1 real(kind=dp), public :: t2 complex(kind=dp), public :: cUfi character(len=300), public :: Uelements Source Code subroutine readUfis ( ik ) !! @todo Document `readUfis()` @endtodo ! implicit none ! integer , intent ( in ) :: ik ! integer :: ibi , ibf , totalNumberOfElements , iDum , i real ( kind = dp ) :: rDum , t1 , t2 complex ( kind = dp ) :: cUfi ! character ( len = 300 ) :: Uelements ! call cpu_time ( t1 ) write ( iostd , '(\" Reading Ufi(:,:) of k-point: \", i4)' ) ik ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) ! read ( 17 , * ) read ( 17 , * ) read ( 17 , '(5i10)' ) totalNumberOfElements , iDum , iDum , iDum , iDum read ( 17 , * ) ! do i = 1 , totalNumberOfElements ! read ( 17 , 1001 ) ibf , ibi , rDum , cUfi , rDum Ufi ( ibf , ibi , ik ) = cUfi ! enddo ! close ( 17 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Reading Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! return ! end subroutine readUfis","tags":"","loc":"proc/readufis.html","title":"readUfis – Carrier Cross Sections"},{"text":"public subroutine calculateVfiElements() Todo Document calculateVFiElements() Arguments None Contents Variables ik ib nOfEnergies iE eMin eMax E av sd x EiMinusEf A DHifMin sumWk sAbsVfiOfE2 absVfiOfE2 nKsInEbin text Source Code calculateVfiElements Variables Type Visibility Attributes Name Initial integer, public :: ik integer, public :: ib integer, public :: nOfEnergies integer, public :: iE real(kind=dp), public :: eMin real(kind=dp), public :: eMax real(kind=dp), public :: E real(kind=dp), public :: av real(kind=dp), public :: sd real(kind=dp), public :: x real(kind=dp), public :: EiMinusEf real(kind=dp), public :: A real(kind=dp), public :: DHifMin real(kind=dp), public, allocatable :: sumWk (:) real(kind=dp), public, allocatable :: sAbsVfiOfE2 (:) real(kind=dp), public, allocatable :: absVfiOfE2 (:) integer, public, allocatable :: nKsInEbin (:) character(len=300), public :: text Source Code subroutine calculateVfiElements () !! @todo Document `calculateVFiElements()` @endtodo ! implicit none ! integer :: ik , ib , nOfEnergies , iE ! real ( kind = dp ) :: eMin , eMax , E , av , sd , x , EiMinusEf , A , DHifMin ! real ( kind = dp ), allocatable :: sumWk (:), sAbsVfiOfE2 (:), absVfiOfE2 (:) integer , allocatable :: nKsInEbin (:) ! character ( len = 300 ) :: text ! allocate ( DE ( iBandIinit : iBandIfinal , perfectCrystal % nKpts ), absVfi2 ( iBandIinit : iBandIfinal , perfectCrystal % nKpts ) ) ! DE (:,:) = 0.0_dp absVfi2 (:,:) = 0.0_dp ! do ik = 1 , perfectCrystal % nKpts ! eigvI (:) = 0.0_dp eigvF (:) = 0.0_dp ! call readEigenvalues ( ik ) ! do ib = iBandIinit , iBandIfinal ! EiMinusEf = eigvI ( ib ) - eigvF ( iBandFinit ) absVfi2 ( ib , ik ) = EiMinusEf ** 2 * ( abs ( Ufi ( iBandFinit , ib , ik )) ** 2 - abs ( Ufi ( iBandFinit , ib , ik )) ** 4 ) ! DE ( ib , ik ) = sqrt ( EiMinusEf ** 2 - 4.0_dp * absVfi2 ( ib , ik )) ! enddo ! enddo ! eMin = minval ( DE (:,:) ) eMax = maxval ( DE (:,:) ) ! nOfEnergies = int (( eMax - eMin ) / eBin ) + 1 ! allocate ( absVfiOfE2 ( 0 : nOfEnergies ), nKsInEbin ( 0 : nOfEnergies ), sumWk ( 0 : nOfEnergies ) ) ! absVfiOfE2 (:) = 0.0_dp nKsInEbin (:) = 0 sumWk (:) = 0.0_dp ! do ik = 1 , perfectCrystal % nKpts ! do ib = iBandIinit , iBandIfinal ! if ( abs ( eMin - DE ( ib , ik )) < 1.0e-3_dp ) DHifMin = absVfi2 ( ib , ik ) iE = int (( DE ( ib , ik ) - eMin ) / eBin ) if ( absVfi2 ( ib , ik ) > 0.0_dp ) then absVfiOfE2 ( iE ) = absVfiOfE2 ( iE ) + perfectCrystal % wk ( ik ) * absVfi2 ( ib , ik ) sumWk ( iE ) = sumWk ( iE ) + perfectCrystal % wk ( ik ) nKsInEbin ( iE ) = nKsInEbin ( iE ) + 1 else write ( iostd , * ) 'lalala' , absVfi2 ( ib , ik ) endif ! enddo ! enddo ! allocate ( sAbsVfiOfE2 ( 0 : nOfEnergies ) ) ! sAbsVfiOfE2 = 0.0_dp ! open ( 11 , file = trim ( VfisOutput ) // 'ofKpt' , status = 'unknown' ) ! write ( 11 , '(\"# |<f|V|i>|&#94;2 versus energy for all the k-points.\")' ) write ( text , '(\"# Energy (eV) shifted by half eBin, |<f|V|i>|&#94;2 (Hartree)&#94;2,\")' ) write ( 11 , '(a, \" k-point index. Format : ''(2ES24.15E3,i10)''\")' ) trim ( text ) ! do ik = 1 , perfectCrystal % nKpts ! do ib = iBandIinit , iBandIfinal ! iE = int (( DE ( ib , ik ) - eMin ) / eBin ) av = absVfiOfE2 ( iE ) / sumWk ( iE ) x = absVfi2 ( ib , ik ) write ( 11 , '(2ES24.15E3,i10)' ) ( eMin + ( iE + 0.5_dp ) * eBin ) * HartreeToEv , x , ik write ( 12 , '(2ES24.15E3,i10)' ) DE ( ib , ik ) * HartreeToEv , absVfi2 ( ib , ik ), ik !write(11, '(2ES24.15E3,i10)') (eMin + iE*eBin + eBin/2.0_dp), x, ik sAbsVfiOfE2 ( iE ) = sAbsVfiOfE2 ( iE ) + perfectCrystal % wk ( ik ) * ( x - av ) ** 2 / sumWk ( iE ) ! enddo ! enddo ! close ( 11 ) ! open ( 63 , file = trim ( VfisOutput ), status = 'unknown' ) ! write ( 63 , '(\"# Averaged |<f|V|i>|&#94;2 over K-points versus energy.\")' ) write ( 63 , '(\"#                 Cell volume : \", ES24.15E3, \" (a.u.)&#94;3,   Format : ''(ES24.15E3)''\")' ) solidDefect % omega write ( 63 , '(\"#   Minimun transition energy : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eMin write ( 63 , '(\"# |DHif|&#94;2 at minimum Tr. En. : \", ES24.15E3, \" (Hartree&#94;2),Format : ''(ES24.15E3)''\")' ) DHifMin write ( 63 , '(\"#                  Energy bin : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eBin write ( text , '(\"# Energy (Hartree), averaged |<f|V|i>|&#94;2 over K-points (Hartree)&#94;2,\")' ) write ( 63 , '(a, \" standard deviation (Hartree)&#94;2. Format : ''(3ES24.15E3)''\")' ) trim ( text ) ! do iE = 0 , nOfEnergies E = iE * eBin av = 0.0_dp sd = 0.0_dp if ( nKsInEbin ( iE ) > 0 ) then av = absVfiOfE2 ( iE ) / sumWk ( iE ) sd = sqrt ( sAbsVfiOfE2 ( iE )) endif write ( 63 , '(3ES24.15E3)' ) eMin + E , av , sd enddo ! close ( 63 ) ! return ! end subroutine calculateVfiElements","tags":"","loc":"proc/calculatevfielements.html","title":"calculateVfiElements – Carrier Cross Sections"},{"text":"public subroutine readEigenvalues(ik) Read in the eigenvalues output from pw_export_for_TME Walkthrough Convert k point index to string Open the perfectCrystal eigenvalues.ik file from pw_export_for_TME Ignore the first two lines as they are comments Ignore eigenvalues for bands that are before iBandIinit Read in the eigenvalues from iBandIinit to iBandIfinal Close the solid defect eigenvalues.ik file Open the solid defect eigenvalues.ik file from pw_export_for_TME Ignore the first two lines as they are comments Ignore eigenvalues for bands that are before iBandFinit Read in the eigenvalues from iBandFinit to iBandFfinal Close the solid defect eigenvalues.ik file Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index Contents Variables ib iks Source Code readEigenvalues Variables Type Visibility Attributes Name Initial integer, public :: ib Loop index over bands character(len=300), public :: iks String version of k point index Source Code subroutine readEigenvalues ( ik ) !! Read in the eigenvalues output from [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ib !! Loop index over bands ! character ( len = 300 ) :: iks !! String version of k point index ! call int2str ( ik , iks ) !! * Convert k point index to string ! open ( 72 , file = trim ( perfectCrystal % exportDir ) // \"/eigenvalues.\" // trim ( iks )) !! * Open the perfectCrystal `eigenvalues.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) read ( 72 , * ) !! * Ignore the first two lines as they are comments ! do ib = 1 , iBandIinit - 1 !! * Ignore eigenvalues for bands that are before `iBandIinit` ! read ( 72 , * ) ! enddo ! do ib = iBandIinit , iBandIfinal !! * Read in the eigenvalues from `iBandIinit` to `iBandIfinal` ! read ( 72 , '(ES24.15E3)' ) eigvI ( ib ) ! enddo ! close ( 72 ) !! * Close the solid defect `eigenvalues.ik` file ! open ( 72 , file = trim ( solidDefect % exportDir ) // \"/eigenvalues.\" // trim ( iks )) !! * Open the solid defect `eigenvalues.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) read ( 72 , * ) !! * Ignore the first two lines as they are comments ! do ib = 1 , iBandFinit - 1 !! * Ignore eigenvalues for bands that are before `iBandFinit` ! read ( 72 , * ) ! enddo ! do ib = iBandFinit , iBandFfinal !! * Read in the eigenvalues from `iBandFinit` to `iBandFfinal` ! read ( 72 , '(ES24.15E3)' ) eigvF ( ib ) ! enddo ! close ( 72 ) !! * Close the solid defect `eigenvalues.ik` file ! return ! end subroutine readEigenvalues","tags":"","loc":"proc/readeigenvalues.html","title":"readEigenvalues – Carrier Cross Sections"},{"text":"public subroutine finalizeCalculation() Stop timer, write out total time taken, and close the output file Arguments None Contents Source Code finalizeCalculation Source Code subroutine finalizeCalculation () !! Stop timer, write out total time taken, and close the output file ! implicit none ! write ( iostd , '(\"-----------------------------------------------------------------\")' ) ! call cpu_time ( tf ) write ( iostd , '(\" Total time needed:                         \", f10.2, \" secs.\")' ) tf - t0 ! close ( iostd ) ! return ! end subroutine finalizeCalculation","tags":"","loc":"proc/finalizecalculation.html","title":"finalizeCalculation – Carrier Cross Sections"},{"text":"public subroutine int2str(integ, string) Write a give integer to a string, using only as many digits as needed Arguments Type Intent Optional Attributes Name integer :: integ character(len=300) :: string Contents Source Code int2str Source Code subroutine int2str ( integ , string ) !! Write a give integer to a string, using only as many digits as needed ! implicit none integer :: integ character ( len = 300 ) :: string ! if ( integ < 10 ) then write ( string , '(i1)' ) integ else if ( integ < 100 ) then write ( string , '(i2)' ) integ else if ( integ < 1000 ) then write ( string , '(i3)' ) integ else if ( integ < 10000 ) then write ( string , '(i4)' ) integ endif ! string = trim ( string ) ! return ! end subroutine int2str","tags":"","loc":"proc/int2str.html","title":"int2str – Carrier Cross Sections"},{"text":"public function msta1(x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer Contents Variables a0 f f0 f1 it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a0 real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn","tags":"","loc":"proc/msta1.html","title":"msta1 – Carrier Cross Sections"},{"text":"public function msta2(x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer Contents Variables a0 ejn f f0 f1 hmp obj it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a0 real(kind=dp), public :: ejn real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: hmp real(kind=dp), public :: obj integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn","tags":"","loc":"proc/msta2.html","title":"msta2 – Carrier Cross Sections"},{"text":"public function envj(n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/envj.html","title":"envj – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents None","tags":"","loc":"proc/readinputs.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents None","tags":"","loc":"proc/initialize.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Arguments None Contents Variables abortExecution Variables Type Visibility Attributes Name Initial logical, public :: abortExecution = .false.","tags":"","loc":"proc/checkandupdateinput.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readPhonons() Arguments None Contents Variables iAtom iMode iq dummyD freqInTHz dummyC Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode integer, public :: iq real(kind=dp), public :: dummyD real(kind=dp), public :: freqInTHz character, public :: dummyC","tags":"","loc":"proc/readphonons.html","title":"readPhonons – Carrier Cross Sections"},{"text":"public subroutine readAtomicPositions() Arguments None Contents Variables iAtom Variables Type Visibility Attributes Name Initial integer, public :: iAtom","tags":"","loc":"proc/readatomicpositions.html","title":"readAtomicPositions – Carrier Cross Sections"},{"text":"public subroutine computeGeneralizedDisplacements() Arguments None Contents Variables iq iMode iAtom Variables Type Visibility Attributes Name Initial integer, public :: iq integer, public :: iMode integer, public :: iAtom","tags":"","loc":"proc/computegeneralizeddisplacements.html","title":"computeGeneralizedDisplacements – Carrier Cross Sections"},{"text":"public subroutine computeVariables() Arguments None Contents Variables i j iMode nm nb bi di bk dk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: iMode integer, public :: nm integer, public :: nb real(kind=dp), public, allocatable :: bi (:) real(kind=dp), public, allocatable :: di (:) real(kind=dp), public, allocatable :: bk (:) real(kind=dp), public, allocatable :: dk (:)","tags":"","loc":"proc/computevariables.html","title":"computeVariables – Carrier Cross Sections"},{"text":"public subroutine arrangeLargerToSmaller() Arguments None Contents Variables i iMode temp tmpr tmpi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iMode real(kind=dp), public, allocatable :: temp (:) real(kind=dp), public :: tmpr integer, public :: tmpi","tags":"","loc":"proc/arrangelargertosmaller.html","title":"arrangeLargerToSmaller – Carrier Cross Sections"},{"text":"public subroutine displaceAtoms() Arguments None Contents Variables istat iAtom iMode iRand ran norm Variables Type Visibility Attributes Name Initial integer, public :: istat integer, public :: iAtom integer, public :: iMode integer, public :: iRand real(kind=dp), public :: ran real(kind=dp), public :: norm","tags":"","loc":"proc/displaceatoms.html","title":"displaceAtoms – Carrier Cross Sections"},{"text":"public subroutine writeNewAtomicPositions() Arguments None Contents Variables iAtom iMode Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode","tags":"","loc":"proc/writenewatomicpositions.html","title":"writeNewAtomicPositions – Carrier Cross Sections"},{"text":"public subroutine exportQEInput() Arguments None Contents Variables iAtom iMode line fn modeFolder mkDir Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode character(len=256), public :: line character(len=256), public :: fn character(len=256), public :: modeFolder character(len=256), public :: mkDir","tags":"","loc":"proc/exportqeinput.html","title":"exportQEInput – Carrier Cross Sections"},{"text":"public subroutine iknb(n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) Contents Variables bs el f f0 f1 k m ik pi s0 sk0 ifact Variables Type Visibility Attributes Name Initial double precision, public :: bs double precision, public :: el double precision, public :: f double precision, public :: f0 double precision, public :: f1 integer, public :: k integer, public :: m integer, public :: ik double precision, public :: pi double precision, public :: s0 double precision, public :: sk0 double precision, public :: ifact","tags":"","loc":"proc/iknb.html","title":"iknb – Carrier Cross Sections"},{"text":"public subroutine iknb2(n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) Contents Variables pi el a0 bkl bs f f0 f1 g g0 g1 r s0 sk0 vt k k0 l m Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 3.141592653589793_dp real(kind=dp), public, parameter :: el = 0.5772156649015329_dp real(kind=dp), public :: a0 real(kind=dp), public :: bkl real(kind=dp), public :: bs real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: g real(kind=dp), public :: g0 real(kind=dp), public :: g1 real(kind=dp), public :: r real(kind=dp), public :: s0 real(kind=dp), public :: sk0 real(kind=dp), public :: vt integer, public :: k integer, public :: k0 integer, public :: l integer, public :: m","tags":"","loc":"proc/iknb2.html","title":"iknb2 – Carrier Cross Sections"},{"text":"public function lcg(s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer Contents None","tags":"","loc":"proc/lcg.html","title":"lcg – Carrier Cross Sections"},{"text":"public function msta1(x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer Contents Variables a0 f f0 f1 it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a0 real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn","tags":"","loc":"proc/msta1~2.html","title":"msta1 – Carrier Cross Sections"},{"text":"public function msta2(x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer Contents Variables a0 ejn f f0 f1 hmp obj it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a0 real(kind=dp), public :: ejn real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: hmp real(kind=dp), public :: obj integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn","tags":"","loc":"proc/msta2~2.html","title":"msta2 – Carrier Cross Sections"},{"text":"public function envj(n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/envj~2.html","title":"envj – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents None","tags":"","loc":"proc/readinputs~2.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initializeLSF() Arguments None Contents Variables dummyD dummyI dummyC1 dummyC8 dummyC9 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dummyD integer, public :: dummyI character(len=1), public :: dummyC1 character(len=8), public :: dummyC8 character(len=9), public :: dummyC9","tags":"","loc":"proc/initializelsf.html","title":"initializeLSF – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents None","tags":"","loc":"proc/initialize~2.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Arguments None Contents Variables abortExecution Variables Type Visibility Attributes Name Initial logical, public :: abortExecution = .false.","tags":"","loc":"proc/checkandupdateinput~2.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readPhononsVASP() Arguments None Contents Variables iAtom iMode iq dummyD freqInTHz dummyC Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode integer, public :: iq real(kind=dp), public :: dummyD real(kind=dp), public :: freqInTHz character, public :: dummyC","tags":"","loc":"proc/readphononsvasp.html","title":"readPhononsVASP – Carrier Cross Sections"},{"text":"public subroutine readPhononsQE() Arguments None Contents Variables iAtom iMode iq dummyD freqInTHz dummyC Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode integer, public :: iq real(kind=dp), public :: dummyD real(kind=dp), public :: freqInTHz character, public :: dummyC","tags":"","loc":"proc/readphononsqe.html","title":"readPhononsQE – Carrier Cross Sections"},{"text":"public subroutine computeGeneralizedDisplacements() Arguments None Contents Variables iq iMode iAtom Variables Type Visibility Attributes Name Initial integer, public :: iq integer, public :: iMode integer, public :: iAtom","tags":"","loc":"proc/computegeneralizeddisplacements~2.html","title":"computeGeneralizedDisplacements – Carrier Cross Sections"},{"text":"public subroutine computeVariables() Arguments None Contents Variables i j nm nb bi di bk dk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: nm integer, public :: nb real(kind=dp), public, allocatable :: bi (:) real(kind=dp), public, allocatable :: di (:) real(kind=dp), public, allocatable :: bk (:) real(kind=dp), public, allocatable :: dk (:)","tags":"","loc":"proc/computevariables~2.html","title":"computeVariables – Carrier Cross Sections"},{"text":"public subroutine arrangeLargerToSmaller() Arguments None Contents Variables i iMode temp tmpr tmpi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iMode real(kind=dp), public, allocatable :: temp (:) real(kind=dp), public :: tmpr integer, public :: tmpi","tags":"","loc":"proc/arrangelargertosmaller~2.html","title":"arrangeLargerToSmaller – Carrier Cross Sections"},{"text":"public subroutine lsfDeterministicFourPhononsByFourBands() Arguments None Contents Variables ic iMode1 iMode2 iMode3 iMode4 pm1 pm2 pm3 pm4 t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: ic integer, public :: iMode1 integer, public :: iMode2 integer, public :: iMode3 integer, public :: iMode4 integer, public :: pm1 integer, public :: pm2 integer, public :: pm3 integer, public :: pm4 real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfdeterministicfourphononsbyfourbands.html","title":"lsfDeterministicFourPhononsByFourBands – Carrier Cross Sections"},{"text":"public subroutine lsfOfConfigurationPj() Arguments None Contents Variables iE j E Fj prodFj sumOverj besPj besRatio Variables Type Visibility Attributes Name Initial integer, public :: iE integer, public :: j real(kind=dp), public :: E real(kind=dp), public :: Fj real(kind=dp), public :: prodFj real(kind=dp), public :: sumOverj real(kind=dp), public :: besPj real(kind=dp), public :: besRatio","tags":"","loc":"proc/lsfofconfigurationpj.html","title":"lsfOfConfigurationPj – Carrier Cross Sections"},{"text":"public subroutine calculatePlusMinusStates(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l Contents Variables iDes other Variables Type Visibility Attributes Name Initial integer, public :: iDes integer, public :: other (0:l-1)","tags":"","loc":"proc/calculateplusminusstates.html","title":"calculatePlusMinusStates – Carrier Cross Sections"},{"text":"public subroutine distrubutePhononsInBands(m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l Contents Variables i i1 i2 i3 i4 i5 i6 i7 i8 i9 i10 i11 i12 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i1 integer, public :: i2 integer, public :: i3 integer, public :: i4 integer, public :: i5 integer, public :: i6 integer, public :: i7 integer, public :: i8 integer, public :: i9 integer, public :: i10 integer, public :: i11 integer, public :: i12","tags":"","loc":"proc/distrubutephononsinbands.html","title":"distrubutePhononsInBands – Carrier Cross Sections"},{"text":"public subroutine lsfWithMphonons(m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes Contents Variables ii iMC iM i pick j picks iE iDes iRand steps E Fj prodFj sumOverj besPj besRatio randy picked Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: iMC integer, public :: iM integer, public :: i integer, public :: pick integer, public :: j integer, public :: picks (l) integer, public :: iE integer, public :: iDes integer, public :: iRand integer, public :: steps real(kind=dp), public :: E real(kind=dp), public :: Fj real(kind=dp), public :: prodFj real(kind=dp), public :: sumOverj real(kind=dp), public :: besPj real(kind=dp), public :: besRatio real(kind=dp), public :: randy logical, public :: picked","tags":"","loc":"proc/lsfwithmphonons.html","title":"lsfWithMphonons – Carrier Cross Sections"},{"text":"public subroutine decimalToOther(iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) Contents Variables m j Variables Type Visibility Attributes Name Initial integer, public :: m integer, public :: j","tags":"","loc":"proc/decimaltoother.html","title":"decimalToOther – Carrier Cross Sections"},{"text":"public subroutine calculateDE(maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de Contents Variables iE j ic ib iEmMax nSteps jMax iEstep tmpB iEsteps empty Variables Type Visibility Attributes Name Initial integer, public :: iE integer, public :: j integer, public :: ic integer, public :: ib integer, public :: iEmMax integer, public :: nSteps integer, public :: jMax integer, public :: iEstep integer, public, allocatable :: tmpB (:) integer, public, allocatable :: iEsteps (:) logical, public :: empty","tags":"","loc":"proc/calculatede.html","title":"calculateDE – Carrier Cross Sections"},{"text":"public subroutine lsfMbyOneBand(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables iMode1 pm1 t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: iMode1 integer, public :: pm1 real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfmbyoneband.html","title":"lsfMbyOneBand – Carrier Cross Sections"},{"text":"public subroutine lsfMbyTwoBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables iMode1 iMode2 pm1 pm2 l t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: iMode1 integer, public :: iMode2 integer, public :: pm1 integer, public :: pm2 integer, public :: l real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfmbytwobands.html","title":"lsfMbyTwoBands – Carrier Cross Sections"},{"text":"public subroutine lsfMbyThreeBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables t1 t2 times3 iMode1 iMode2 iMode3 ni mi iDes ii Variables Type Visibility Attributes Name Initial real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: times3 integer, public :: iMode1 integer, public :: iMode2 integer, public :: iMode3 integer, public :: ni integer, public :: mi integer, public :: iDes integer, public :: ii","tags":"","loc":"proc/lsfmbythreebands.html","title":"lsfMbyThreeBands – Carrier Cross Sections"},{"text":"public subroutine writeLSFandCrossSection() Arguments None Contents Variables iE E Variables Type Visibility Attributes Name Initial integer, public :: iE real(kind=dp), public :: E","tags":"","loc":"proc/writelsfandcrosssection.html","title":"writeLSFandCrossSection – Carrier Cross Sections"},{"text":"public subroutine init_random_seed() Arguments None Contents Variables seed n t Variables Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: seed (:) integer(kind=int32), public :: n integer, public :: t","tags":"","loc":"proc/init_random_seed.html","title":"init_random_seed – Carrier Cross Sections"},{"text":"public subroutine iknb(n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) Contents Variables bs el f f0 f1 k m ik pi s0 sk0 ifact Variables Type Visibility Attributes Name Initial double precision, public :: bs double precision, public :: el double precision, public :: f double precision, public :: f0 double precision, public :: f1 integer, public :: k integer, public :: m integer, public :: ik double precision, public :: pi double precision, public :: s0 double precision, public :: sk0 double precision, public :: ifact","tags":"","loc":"proc/iknb~2.html","title":"iknb – Carrier Cross Sections"},{"text":"public subroutine iknb2(n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) Contents Variables pi el a0 bkl bs f f0 f1 g g0 g1 r s0 sk0 vt k k0 l m Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 3.141592653589793_dp real(kind=dp), public, parameter :: el = 0.5772156649015329_dp real(kind=dp), public :: a0 real(kind=dp), public :: bkl real(kind=dp), public :: bs real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: g real(kind=dp), public :: g0 real(kind=dp), public :: g1 real(kind=dp), public :: r real(kind=dp), public :: s0 real(kind=dp), public :: sk0 real(kind=dp), public :: vt integer, public :: k integer, public :: k0 integer, public :: l integer, public :: m","tags":"","loc":"proc/iknb2~2.html","title":"iknb2 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy3() Arguments None Contents Variables parTotal parTotal2 totalStates states averageStatesPerProc i iState iproc Variables Type Visibility Attributes Name Initial real(kind=dp), public :: parTotal real(kind=dp), public :: parTotal2 real(kind=dp), public :: totalStates real(kind=dp), public :: states real(kind=dp), public :: averageStatesPerProc integer, public :: i integer, public :: iState integer, public :: iproc","tags":"","loc":"proc/parallelisfsby3.html","title":"parallelIsFsBy3 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy4() Arguments None Contents Variables parTotal parTotal2 totalStates states averageStatesPerProc i iState iproc Variables Type Visibility Attributes Name Initial real(kind=dp), public :: parTotal real(kind=dp), public :: parTotal2 real(kind=dp), public :: totalStates real(kind=dp), public :: states real(kind=dp), public :: averageStatesPerProc integer, public :: i integer, public :: iState integer, public :: iproc","tags":"","loc":"proc/parallelisfsby4.html","title":"parallelIsFsBy4 – Carrier Cross Sections"},{"text":"public function lcg(s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer Contents None","tags":"","loc":"proc/lcg~2.html","title":"lcg – Carrier Cross Sections"},{"text":"public function msta1(x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer Contents Variables a0 f f0 f1 it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a0 real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn","tags":"","loc":"proc/msta1~3.html","title":"msta1 – Carrier Cross Sections"},{"text":"public function msta2(x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer Contents Variables a0 ejn f f0 f1 hmp obj it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a0 real(kind=dp), public :: ejn real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: hmp real(kind=dp), public :: obj integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn","tags":"","loc":"proc/msta2~3.html","title":"msta2 – Carrier Cross Sections"},{"text":"public function envj(n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/envj~3.html","title":"envj – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents None","tags":"","loc":"proc/readinputs~3.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initializeLSF() Arguments None Contents Variables dummyD dummyI dummyC1 dummyC8 dummyC9 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dummyD integer, public :: dummyI character(len=1), public :: dummyC1 character(len=8), public :: dummyC8 character(len=9), public :: dummyC9","tags":"","loc":"proc/initializelsf~2.html","title":"initializeLSF – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents None","tags":"","loc":"proc/initialize~3.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Arguments None Contents Variables abortExecution Variables Type Visibility Attributes Name Initial logical, public :: abortExecution = .false.","tags":"","loc":"proc/checkandupdateinput~3.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readPhonons() Arguments None Contents Variables iAtom iMode iq dummyD freqInTHz dummyC Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode integer, public :: iq real(kind=dp), public :: dummyD real(kind=dp), public :: freqInTHz character, public :: dummyC","tags":"","loc":"proc/readphonons~2.html","title":"readPhonons – Carrier Cross Sections"},{"text":"public subroutine computeGeneralizedDisplacements() Arguments None Contents Variables iq iMode iAtom Variables Type Visibility Attributes Name Initial integer, public :: iq integer, public :: iMode integer, public :: iAtom","tags":"","loc":"proc/computegeneralizeddisplacements~3.html","title":"computeGeneralizedDisplacements – Carrier Cross Sections"},{"text":"public subroutine computeVariables() Arguments None Contents Variables i j nm nb bi di bk dk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: nm integer, public :: nb real(kind=dp), public, allocatable :: bi (:) real(kind=dp), public, allocatable :: di (:) real(kind=dp), public, allocatable :: bk (:) real(kind=dp), public, allocatable :: dk (:)","tags":"","loc":"proc/computevariables~3.html","title":"computeVariables – Carrier Cross Sections"},{"text":"public subroutine arrangeLargerToSmaller() Arguments None Contents Variables i iMode temp tmpr tmpi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iMode real(kind=dp), public, allocatable :: temp (:) real(kind=dp), public :: tmpr integer, public :: tmpi","tags":"","loc":"proc/arrangelargertosmaller~3.html","title":"arrangeLargerToSmaller – Carrier Cross Sections"},{"text":"public subroutine readMjs() Arguments None Contents Variables i iE0 iE numOfMjs dummyD1 dummyD2 Ee MjOfE MjOfE0 eBin DHifMin eifMin volume dummyC1 dummyC32 dummyC35 modeFolder Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iE0 integer, public :: iE integer, public :: numOfMjs real(kind=dp), public :: dummyD1 real(kind=dp), public :: dummyD2 real(kind=dp), public :: Ee real(kind=dp), public :: MjOfE real(kind=dp), public :: MjOfE0 real(kind=dp), public :: eBin real(kind=dp), public :: DHifMin real(kind=dp), public :: eifMin real(kind=dp), public :: volume character(len=1), public :: dummyC1 character(len=32), public :: dummyC32 character(len=35), public :: dummyC35 character(len=256), public :: modeFolder","tags":"","loc":"proc/readmjs.html","title":"readMjs – Carrier Cross Sections"},{"text":"public subroutine lsfDeterministicFourPhononsByFourBands() Arguments None Contents Variables ic iMode1 iMode2 iMode3 iMode4 pm1 pm2 pm3 pm4 t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: ic integer, public :: iMode1 integer, public :: iMode2 integer, public :: iMode3 integer, public :: iMode4 integer, public :: pm1 integer, public :: pm2 integer, public :: pm3 integer, public :: pm4 real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfdeterministicfourphononsbyfourbands~2.html","title":"lsfDeterministicFourPhononsByFourBands – Carrier Cross Sections"},{"text":"public subroutine lsfOfConfigurationPj() Arguments None Contents Variables iE j E Fj prodFj sumOverj besPj besRatio Variables Type Visibility Attributes Name Initial integer, public :: iE integer, public :: j real(kind=dp), public :: E real(kind=dp), public :: Fj real(kind=dp), public :: prodFj real(kind=dp), public :: sumOverj real(kind=dp), public :: besPj real(kind=dp), public :: besRatio","tags":"","loc":"proc/lsfofconfigurationpj~2.html","title":"lsfOfConfigurationPj – Carrier Cross Sections"},{"text":"public subroutine calculatePlusMinusStates(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l Contents Variables iDes other Variables Type Visibility Attributes Name Initial integer, public :: iDes integer, public :: other (0:l-1)","tags":"","loc":"proc/calculateplusminusstates~2.html","title":"calculatePlusMinusStates – Carrier Cross Sections"},{"text":"public subroutine distrubutePhononsInBands(m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l Contents Variables i i1 i2 i3 i4 i5 i6 i7 i8 i9 i10 i11 i12 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i1 integer, public :: i2 integer, public :: i3 integer, public :: i4 integer, public :: i5 integer, public :: i6 integer, public :: i7 integer, public :: i8 integer, public :: i9 integer, public :: i10 integer, public :: i11 integer, public :: i12","tags":"","loc":"proc/distrubutephononsinbands~2.html","title":"distrubutePhononsInBands – Carrier Cross Sections"},{"text":"public subroutine lsfWithMphonons(m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes Contents Variables ii iMC iM i pick j picks iE iDes iRand steps E Fj prodFj sumOverj besPj besRatio randy picked Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: iMC integer, public :: iM integer, public :: i integer, public :: pick integer, public :: j integer, public :: picks (l) integer, public :: iE integer, public :: iDes integer, public :: iRand integer, public :: steps real(kind=dp), public :: E real(kind=dp), public :: Fj real(kind=dp), public :: prodFj real(kind=dp), public :: sumOverj real(kind=dp), public :: besPj real(kind=dp), public :: besRatio real(kind=dp), public :: randy logical, public :: picked","tags":"","loc":"proc/lsfwithmphonons~2.html","title":"lsfWithMphonons – Carrier Cross Sections"},{"text":"public subroutine decimalToOther(iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) Contents Variables m j Variables Type Visibility Attributes Name Initial integer, public :: m integer, public :: j","tags":"","loc":"proc/decimaltoother~2.html","title":"decimalToOther – Carrier Cross Sections"},{"text":"public subroutine calculateDE(maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de Contents Variables iE j ic ib iEmMax nSteps jMax iEstep tmpB iEsteps empty Variables Type Visibility Attributes Name Initial integer, public :: iE integer, public :: j integer, public :: ic integer, public :: ib integer, public :: iEmMax integer, public :: nSteps integer, public :: jMax integer, public :: iEstep integer, public, allocatable :: tmpB (:) integer, public, allocatable :: iEsteps (:) logical, public :: empty","tags":"","loc":"proc/calculatede~2.html","title":"calculateDE – Carrier Cross Sections"},{"text":"public subroutine lsfMbyOneBand(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables iMode1 pm1 t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: iMode1 integer, public :: pm1 real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfmbyoneband~2.html","title":"lsfMbyOneBand – Carrier Cross Sections"},{"text":"public subroutine lsfMbyTwoBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables iMode1 iMode2 pm1 pm2 l t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: iMode1 integer, public :: iMode2 integer, public :: pm1 integer, public :: pm2 integer, public :: l real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfmbytwobands~2.html","title":"lsfMbyTwoBands – Carrier Cross Sections"},{"text":"public subroutine lsfMbyThreeBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables t1 t2 times3 iMode1 iMode2 iMode3 ni mi iDes ii Variables Type Visibility Attributes Name Initial real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: times3 integer, public :: iMode1 integer, public :: iMode2 integer, public :: iMode3 integer, public :: ni integer, public :: mi integer, public :: iDes integer, public :: ii","tags":"","loc":"proc/lsfmbythreebands~2.html","title":"lsfMbyThreeBands – Carrier Cross Sections"},{"text":"public subroutine writeLSFandCrossSection() Arguments None Contents Variables iE E Variables Type Visibility Attributes Name Initial integer, public :: iE real(kind=dp), public :: E","tags":"","loc":"proc/writelsfandcrosssection~2.html","title":"writeLSFandCrossSection – Carrier Cross Sections"},{"text":"public subroutine init_random_seed() Arguments None Contents Variables seed n t Variables Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: seed (:) integer(kind=int32), public :: n integer, public :: t","tags":"","loc":"proc/init_random_seed~2.html","title":"init_random_seed – Carrier Cross Sections"},{"text":"public subroutine iknb(n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) Contents Variables bs el f f0 f1 k m ik pi s0 sk0 ifact Variables Type Visibility Attributes Name Initial double precision, public :: bs double precision, public :: el double precision, public :: f double precision, public :: f0 double precision, public :: f1 integer, public :: k integer, public :: m integer, public :: ik double precision, public :: pi double precision, public :: s0 double precision, public :: sk0 double precision, public :: ifact","tags":"","loc":"proc/iknb~3.html","title":"iknb – Carrier Cross Sections"},{"text":"public subroutine iknb2(n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) Contents Variables pi el a0 bkl bs f f0 f1 g g0 g1 r s0 sk0 vt k k0 l m Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 3.141592653589793_dp real(kind=dp), public, parameter :: el = 0.5772156649015329_dp real(kind=dp), public :: a0 real(kind=dp), public :: bkl real(kind=dp), public :: bs real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: g real(kind=dp), public :: g0 real(kind=dp), public :: g1 real(kind=dp), public :: r real(kind=dp), public :: s0 real(kind=dp), public :: sk0 real(kind=dp), public :: vt integer, public :: k integer, public :: k0 integer, public :: l integer, public :: m","tags":"","loc":"proc/iknb2~3.html","title":"iknb2 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy3() Arguments None Contents Variables parTotal parTotal2 totalStates states averageStatesPerProc i iState iproc Variables Type Visibility Attributes Name Initial real(kind=dp), public :: parTotal real(kind=dp), public :: parTotal2 real(kind=dp), public :: totalStates real(kind=dp), public :: states real(kind=dp), public :: averageStatesPerProc integer, public :: i integer, public :: iState integer, public :: iproc","tags":"","loc":"proc/parallelisfsby3~2.html","title":"parallelIsFsBy3 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy4() Arguments None Contents Variables parTotal parTotal2 totalStates states averageStatesPerProc i iState iproc Variables Type Visibility Attributes Name Initial real(kind=dp), public :: parTotal real(kind=dp), public :: parTotal2 real(kind=dp), public :: totalStates real(kind=dp), public :: states real(kind=dp), public :: averageStatesPerProc integer, public :: i integer, public :: iState integer, public :: iproc","tags":"","loc":"proc/parallelisfsby4~2.html","title":"parallelIsFsBy4 – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents Source Code readInputs Source Code subroutine readInputs () ! implicit none ! ! Check if an output file exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , elphscat , iostat = ios ) ! call checkInputAndUpdateParameters () ! call readLSF () ! call readVfis () ! return ! end subroutine readInputs","tags":"","loc":"proc/readinputs~4.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents Source Code initialize Source Code subroutine initialize () ! implicit none ! VfisInput = '' LSFinput = '' crossSectionOutput = '' ! de = maxEnergy * eVToHartree / real ( nOfEnergyBins , dp ) ! return ! end subroutine initialize","tags":"","loc":"proc/initialize~4.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkInputAndUpdateParameters() Arguments None Contents Source Code checkInputAndUpdateParameters Source Code subroutine checkInputAndUpdateParameters () ! implicit none ! if ( VfisInput == '' ) then write ( iostd , '(\" Vfi elements input (input variable VfisInput) is not defined!\")' ) else inquire ( file = trim ( VfisInput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" Vfi elements input : \", a)' ) trim ( VfisInput ) else write ( iostd , '(\" Vfi elements input : \", a, \" does not exist!\")' ) trim ( VfisInput ) endif endif ! if ( LSFinput == '' ) then write ( iostd , '(\" LSF input (input variable LSFinput) is not defined!\")' ) else inquire ( file = trim ( LSFinput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" LSF input : \", a)' ) trim ( LSFinput ) else write ( iostd , '(\" LSF input : \", a, \" does not exist!\")' ) trim ( LSFinput ) endif endif ! if ( crossSectionOutput == '' ) then write ( iostd , '(\" crossSectionOutput is not defined! File name : crossSection, will be used.\")' ) crossSectionOutput = 'crossSection' else write ( iostd , '(\" Cross section output file name : \", a)' ) trim ( crossSectionOutput ) endif ! if ( ( VfisInput == '' ) . or . ( LSFinput == '' ) ) then ! write ( iostd , '(\" One or both of the input files is not defined! \")' ) write ( iostd , '(\" ********************************************** \")' ) write ( iostd , '(\" *               Program stops!               * \")' ) write ( iostd , '(\" *       Please check the output file.        * \")' ) write ( iostd , '(\" ********************************************** \")' ) ! stop ! endif ! flush ( iostd ) ! return ! end subroutine checkInputAndUpdateParameters","tags":"","loc":"proc/checkinputandupdateparameters.html","title":"checkInputAndUpdateParameters – Carrier Cross Sections"},{"text":"public subroutine readLSF() Arguments None Contents Variables dummyC1 dummyC8 dummyC9 ee iE Source Code readLSF Variables Type Visibility Attributes Name Initial character(len=1), public :: dummyC1 character(len=8), public :: dummyC8 character(len=9), public :: dummyC9 real(kind=dp), public :: ee integer, public :: iE Source Code subroutine readLSF () ! implicit none ! character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! real ( kind = dp ) :: ee ! integer :: iE ! open ( 1 , file = trim ( LSFinput ), status = 'old' ) ! read ( 1 , '(a1, i10, a9, i5, a8)' ) dummyC1 , nEnergies , dummyC9 , m , dummyC8 ! allocate ( E ( - nEnergies : nEnergies ), lsfVsE ( - nEnergies : nEnergies ), lsfVsEbyPhonon ( - nEnergies : nEnergies ) ) ! do iE = - nEnergies , nEnergies ! read ( 1 , '(F16.8,2E18.6e3)' ) ee , lsfVsE ( iE ), lsfVsEbyPhonon ( iE ) E ( iE ) = ee * eVToHartree ! enddo ! close ( 1 ) ! end subroutine readLSF","tags":"","loc":"proc/readlsf.html","title":"readLSF – Carrier Cross Sections"},{"text":"public subroutine readVfis() Arguments None Contents Variables i iE0 iE dummyD1 dummyD2 Ee VfiOfE VfiOfE0 eBin dummyC1 dummyC32 dummyC35 Source Code readVfis Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iE0 integer, public :: iE real(kind=dp), public :: dummyD1 real(kind=dp), public :: dummyD2 real(kind=dp), public :: Ee real(kind=dp), public :: VfiOfE real(kind=dp), public :: VfiOfE0 real(kind=dp), public :: eBin character(len=1), public :: dummyC1 character(len=32), public :: dummyC32 character(len=35), public :: dummyC35 Source Code subroutine readVfis () ! implicit none ! integer :: i , iE0 , iE real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , VfiOfE , VfiOfE0 , eBin character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 ! open ( 1 , file = trim ( VfisInput ), status = \"old\" ) ! !read(1, '(a1, i10, a9, f15.4, a16)') dummyC1, nEVfi, dummyC9, volume, dummyC16 ! read ( 1 , * ) read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 read ( 1 , * ) ! read ( 1 , '(i10)' ) numOfVfis ! allocate ( Vfis ( 0 : numOfVfis ), energy ( 0 : numOfVfis ), lsf ( 0 : numOfVfis ) ) ! Vfis (:) = 0.0_dp energy (:) = 0.0_dp lsf (:) = 0.0_dp ! read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE0 , dummyD1 ! Vfis ( 1 ) = VfiOfE0 energy ( 1 ) = Ee ! iE = int ( Ee / de ) + 1 ! do i = 2 , numOfVfis ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE , dummyD2 energy ( i ) = Ee iE = int ( Ee / de ) + 1 !Vfis(iE0:iE) = VfiOfE0 Vfis ( i ) = VfiOfE !VfiOfE0 = VfiOfE lsf ( i - 1 ) = sum ( lsfVsE ( iE0 : iE )) / ( iE - iE0 + 1 ) write ( 26 , * ) E ( iE0 ), Ee , lsf ( i ) ! sum(lsfVsE(iE0:iE))/(iE-iE0+1) ! enddo ! close ( 1 ) close ( 26 ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies write ( 44 , * ) energy ( iE ) * HartreeToEv , Vfis ( iE ), lsf ( iE ) enddo ! close ( 44 ) ! return ! end subroutine readVfis","tags":"","loc":"proc/readvfis.html","title":"readVfis – Carrier Cross Sections"},{"text":"public subroutine calculateSigma() Arguments None Contents Variables iE vg sigma0 Source Code calculateSigma Variables Type Visibility Attributes Name Initial integer, public :: iE real(kind=dp), public :: vg real(kind=dp), public :: sigma0 Source Code subroutine calculateSigma () ! implicit none ! integer :: iE real ( kind = dp ) :: vg , sigma0 ! allocate ( sigma ( numOfVfis ) ) ! , sigmaByPhonon(-nEnergies:nEnergies) ) !allocate( sigma(-nEnergies:nEnergies), sigmaByPhonon(-nEnergies:nEnergies) ) ! iE = int ( eifMin / de ) + 1 write ( 6 , * ) eifMin , eifMin * HartreeToEv , iE sigma0 = twoPi * abCM ** 2 * volume * DHifMin * lsfVsE ( iE ) / sqrt ( 2.0_dp * E ( iE )) ! !do iE = 1, numOfVfis ! -nEnergies, nEnergies - 1 !  if ( (E(iE) < eifMin).and.(E(iE+1) > eifMin) ) sigma0 = twoPi*abCM**2*volume*DHifMin*lsfVsE(iE)/sqrt(2.0_dp*E(iE)) !enddo ! write ( 6 , * ) eifMin * HartreeToEv , sigma0 ! sigma (:) = 0.0_dp ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies vg = 1.0_dp if ( energy ( iE ) > 0.0_dp ) vg = sqrt ( 2.0_dp * energy ( iE )) !write(6,*) iE, energy(iE), vg, Vfis(iE), lsf(iE) sigma ( iE ) = twoPi * abCM ** 2 * volume * Vfis ( iE ) * lsf ( iE ) / vg !sigma(iE)         = twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg !sigmaByPhonon(iE) = twoPi*abCM**2*volume*Vfis(iE)*lsfVsEbyPhonon(iE)/vg enddo ! return ! end subroutine calculateSigma","tags":"","loc":"proc/calculatesigma.html","title":"calculateSigma – Carrier Cross Sections"},{"text":"public subroutine writeSigma() Arguments None Contents Variables iE Source Code writeSigma Variables Type Visibility Attributes Name Initial integer, public :: iE Source Code subroutine writeSigma () ! implicit none ! integer :: iE ! open ( 2 , file = trim ( crossSectionOutput ), status = 'unknown' ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies ! write ( 2 , * ) energy ( iE ) * HartreeToEv , sigma ( iE ) !, sigmaByPhonon(iE) !write(2,*) E(iE), sigma(iE), sigmaByPhonon(iE) ! enddo ! close ( 2 ) ! return ! end subroutine writeSigma","tags":"","loc":"proc/writesigma.html","title":"writeSigma – Carrier Cross Sections"},{"text":"Uses io_global kinds parameters Contents Variables file_version restart_module_verbosity Subroutines write_restart_wfc Variables Type Visibility Attributes Name Initial integer, public, parameter :: file_version = 202 integer, public :: restart_module_verbosity = 0 Subroutines public subroutine write_restart_wfc (iuni, exportDir, ik, nk, kunit, ispin, nspin, scal, wf0, t0, wfm, tm, ngw, gamma_only, nbnd, igl, ngwl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iuni character(len=256), intent(in) :: exportDir integer, intent(in) :: ik integer, intent(in) :: nk integer, intent(in) :: kunit integer, intent(in) :: ispin integer, intent(in) :: nspin real(kind=DP), intent(in) :: scal complex(kind=DP), intent(in) :: wf0 (:,:) logical, intent(in) :: t0 complex(kind=DP), intent(in) :: wfm (:,:) logical, intent(in) :: tm integer, intent(in) :: ngw logical, intent(in) :: gamma_only integer, intent(in) :: nbnd integer, intent(in) :: igl (:) integer, intent(in) :: ngwl","tags":"","loc":"module/io_base_export.html","title":"io_base_export – Carrier Cross Sections"},{"text":"Declare all global variables\n and house all subroutines Contents Variables dp iostd root evToHartree HartreeToEv pi sq4pi ii output gx gy gz i iBandFfinal iBandFinit iBandIfinal iBandIinit ibf ibi id ierr ig ik ind2 ios iPn iTypes j JMAX kf ki maxL myid n n1 n2 n3 n4 nF nGf nGi nGvsF nGvsI nI np nPP npw npwMf npwMi npwNf npwNi nSquareProcs numOfPWs numOfUsedGvecsPP numprocs eBin t0 tf threej paw paw2 pseudo1 pseudo2 calculateVfis coulomb gamma_only master tmes_file_exists elementsPath mkdir textDum VfisOutput counts igvs iqs nFs ngs nIs nPWsI nPWsF pwGvecs pwGs absVfi2 DE eigvF eigvI gvecs paw_id paw_fi pawPsiPC pawSDPhi paw_SDKKPC Ufi perfectCrystal solidDefect vecs newVecs Derived Types atom crystal vec Functions wasRead Subroutines initializeCalculation readInput checkInitialization readQEExport readPWsSet distributePWsToProcs checkIfCalculated calculatePWsOverlap readWfc readProjections projectBeta pawCorrectionWfc pawCorrectionK ylm bessel_j writeResults readUfis calculateVfiElements readEigenvalues finalizeCalculation int2str Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) Used to set real variables to double precision integer, public, parameter :: iostd = 16 Unit number for output file integer, public, parameter :: root = 0 ID of the root process real(kind=dp), public, parameter :: evToHartree = 0.03674932538878_dp Conversion factor from eV to Hartree real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp Conversion factor from Hartree to eV real(kind=dp), public, parameter :: pi = 3.141592653589793_dp Pi real(kind=dp), public, parameter :: sq4pi = 3.544907701811032_dp \\sqrt{4\\pi} complex(kind=dp), public, parameter :: ii = cmplx(0.0_dp, 1.0_dp, kind=dp) Complex i character(len=6), public, parameter :: output = 'output' Name of the output file;\n used in readInput Todo Change I/O from file to console so that usage matches that of QE integer, public :: gx integer, public :: gy integer, public :: gz integer, public :: i integer, public :: iBandFfinal integer, public :: iBandFinit integer, public :: iBandIfinal integer, public :: iBandIinit integer, public :: ibf integer, public :: ibi integer, public :: id integer, public :: ierr Error code returned from MPI integer, public :: ig integer, public :: ik integer, public :: ind2 integer, public :: ios Status returned from I/O commands integer, public :: iPn integer, public :: iTypes integer, public :: j integer, public :: JMAX 2*L_{\\text{max}} + 1 integer, public :: kf integer, public :: ki integer, public :: maxL Maximum angular momentum of projector from any atom type integer, public :: myid ID for each MPI process integer, public :: n integer, public :: n1 integer, public :: n2 integer, public :: n3 integer, public :: n4 integer, public :: nF integer, public :: nGf integer, public :: nGi integer, public :: nGvsF integer, public :: nGvsI integer, public :: nI integer, public :: np integer, public :: nPP integer, public :: npw integer, public :: npwMf integer, public :: npwMi integer, public :: npwNf integer, public :: npwNi integer, public :: nSquareProcs integer, public :: numOfPWs integer, public :: numOfUsedGvecsPP integer, public :: numprocs Number of processes in the MPI pool real(kind=dp), public :: eBin real(kind=dp), public :: t0 Start time for program real(kind=dp), public :: tf End time for program real(kind=dp), public :: threej complex(kind=dp), public :: paw complex(kind=dp), public :: paw2 complex(kind=dp), public :: pseudo1 complex(kind=dp), public :: pseudo2 logical, public :: calculateVfis logical, public :: coulomb logical, public :: gamma_only logical, public :: master logical, public :: tmes_file_exists character(len=300), public :: elementsPath character(len=320), public :: mkdir Command for creating the elements path directory character(len=300), public :: textDum Dummy variable to hold unneeded lines from input file character(len=200), public :: VfisOutput Output file for ?? integer, public, allocatable :: counts (:) integer, public, allocatable :: igvs (:,:,:) integer, public, allocatable :: iqs (:) integer, public, allocatable :: nFs (:,:) integer, public, allocatable :: ngs (:,:) integer, public, allocatable :: nIs (:,:) integer, public, allocatable :: nPWsI (:) integer, public, allocatable :: nPWsF (:) integer, public, allocatable :: pwGvecs (:,:) integer, public, allocatable :: pwGs (:,:) real(kind=dp), public, allocatable :: absVfi2 (:,:) real(kind=dp), public, allocatable :: DE (:,:) real(kind=dp), public, allocatable :: eigvF (:) real(kind=dp), public, allocatable :: eigvI (:) real(kind=dp), public, allocatable :: gvecs (:,:) complex(kind=dp), public, allocatable :: paw_id (:,:) complex(kind=dp), public, allocatable :: paw_fi (:,:) complex(kind=dp), public, allocatable :: pawPsiPC (:,:) complex(kind=dp), public, allocatable :: pawSDPhi (:,:) complex(kind=dp), public, allocatable :: paw_SDKKPC (:,:) complex(kind=dp), public, allocatable :: Ufi (:,:,:) type( crystal ), public :: perfectCrystal Structure that holds all of the information on the perfect crystal type( crystal ), public :: solidDefect Structure that holds all of the information on the solid defect type( vec ), public, allocatable :: vecs (:) type( vec ), public, allocatable :: newVecs (:) Derived Types type, public :: atom Define a new type to represent an atom in the structure. \n Each different type of atom in the structure will be another\n variable with the type atom . Read more… Components Type Visibility Attributes Name Initial integer, public :: iRAugMax Maximum radius of beta projector (outer radius to integrate);\n for PAW augmentation charge may extend a bit further; I think this\n is the max index for the augmentation sphere, so I'm changing the \n name; last name was iRc integer, public :: numOfAtoms Number of atoms of a specific type in the structure integer, public :: numProjs Number of projectors integer, public :: lmMax Number of channels integer, public :: nMax Number of radial mesh points character(len=2), public :: symbol Element name for the given atom type integer, public, allocatable :: projAngMom (:) Angular momentum of each projector real(kind=dp), public, allocatable :: bes_J_qr (:,:) real(kind=dp), public, allocatable :: F (:,:) real(kind=dp), public, allocatable :: F1 (:,:,:) real(kind=dp), public, allocatable :: F2 (:,:,:) real(kind=dp), public, allocatable :: r (:) Radial mesh real(kind=dp), public, allocatable :: rab (:) Derivative of radial mesh real(kind=dp), public, allocatable :: wae (:,:) All electron wavefunction real(kind=dp), public, allocatable :: wps (:,:) Psuedowavefunction type, public :: crystal Components Type Visibility Attributes Name Initial integer, public :: nKpts Number of k points integer, public :: numOfPWs Total number of plane waves integer, public :: nIons Total number of atoms in system integer, public :: numOfTypes Number of different types of atoms integer, public :: nProjs Number of projectors integer, public :: numOfGvecs Number of G vectors Read more… integer, public :: nBands Number of bands integer, public :: nSpins Number of spins integer, public, allocatable :: npws (:) Number of plane waves per k point integer, public, allocatable :: atomTypeIndex (:) Index of the given atom type real(kind=dp), public :: omega Cell volume real(kind=dp), public :: bg (3,3) real(kind=dp), public, allocatable :: wk (:) real(kind=dp), public, allocatable :: xk (:,:) real(kind=dp), public, allocatable :: posIon (:,:) complex(kind=dp), public, allocatable :: wfc (:,:) complex(kind=dp), public, allocatable :: beta (:,:) complex(kind=dp), public, allocatable :: cProj (:,:,:) complex(kind=dp), public, allocatable :: cCrossProj (:,:,:) complex(kind=dp), public, allocatable :: paw_Wfc (:,:) complex(kind=dp), public, allocatable :: pawK (:,:,:) character(len=2), public :: crystalType 'PC' for pristine crystal and 'SD' for solid defect character(len=200), public :: exportDir Export directory from pw_export_for_TME type( atom ), public, allocatable :: atoms (:) type, public :: vec Components Type Visibility Attributes Name Initial integer, public :: ind integer, public, allocatable :: igN (:) integer, public, allocatable :: igM (:) Functions public function wasRead (inputVal, variableName, usage, abortExecution) Determine if an input variable still has the default value.\n If it does, output an error message and possibly set the program\n to abort. Not all variables would cause the program to abort,\n so this program assumes that if you pass in the logical abortExecution then the variable is required and causes the program to abort \n if missing. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputVal Value to compare with 0 to see if a variable has been read; character(len=*), intent(in) :: variableName Name of the variable used in output message character(len=*), intent(in) :: usage Example of how the variable can be used logical, intent(inout), optional :: abortExecution Optional logical for if the program should be aborted Return Value logical Whether or not the input variable was read from the input file;\n this is the return value Read more… Subroutines public subroutine initializeCalculation (solidDefect, pristineCrystal, elementsPath, VfisOutput, ki, kf, eBin, iBandIinit, iBandIfinal, iBandFinit, iBandFfinal, calculateVfis, t0) Initialize the calculation by starting timer,\n setting start values for variables to be read from .in file, removing any existing output in the output directory,\n and opening a clean output file Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: solidDefect type( crystal ), intent(inout) :: pristineCrystal character(len=300), intent(out) :: elementsPath character(len=200), intent(out) :: VfisOutput integer, intent(out) :: ki integer, intent(out) :: kf real(kind=dp), intent(out) :: eBin integer, intent(out) :: iBandIinit integer, intent(out) :: iBandIfinal integer, intent(out) :: iBandFinit integer, intent(out) :: iBandFfinal logical, intent(out) :: calculateVfis real(kind=dp), intent(out) :: t0 public subroutine readInput (perfectCrystal, solidDefect, elementsPath, iBandIinit, iBandIfinal, iBandFinit, iBandFfinal, ki, kf, calculateVfis, VfisOutput) Delete any previous output, initialize input variables,\n start a timer, and read in the input files Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: perfectCrystal Holds all of the information on the perfect crystal type( crystal ), intent(inout) :: solidDefect Holds all of the information on the defective crystal character(len=300), intent(inout) :: elementsPath integer, intent(inout) :: iBandIinit integer, intent(inout) :: iBandIfinal integer, intent(inout) :: iBandFinit integer, intent(inout) :: iBandFfinal integer, intent(inout) :: ki integer, intent(inout) :: kf logical, intent(inout) :: calculateVfis character(len=200), intent(inout) :: VfisOutput public subroutine checkInitialization () Check to see if variables from .in file still\n have the values set in initializeCalculation or if they have values that aren't allowed Read more… Arguments None public subroutine readQEExport (system) Read input files in the Export directory created by pw_export_for_TME Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect public subroutine readPWsSet () Read the g vectors in Miller indices from mgrid file and convert\n using reciprocal lattice vectors Read more… Arguments None public subroutine distributePWsToProcs (nOfPWs, nOfBlocks) Determine how many g vectors each process should get Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nOfPWs Number of g vectors integer, intent(in) :: nOfBlocks Number of processes public subroutine checkIfCalculated (ik, tmes_file_exists) Determine if the output file for a given k point already exists Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index logical, intent(out) :: tmes_file_exists Whether or not the output file exists public subroutine calculatePWsOverlap (ik) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index public subroutine readWfc (ik, system) Open the grid.ki file from pw_export_for_TME to get the indices for the wavefunction to be stored in, then\n open the wfc.ki file and read in the wavefunction for the \n proper bands and store in the proper indices in the system's wfc Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) public subroutine readProjections (ik, system) Read in the projection \\langle\\beta|\\Psi\\rangle for each band Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) public subroutine projectBeta (ik, betaSystem, projectedSystem) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: betaSystem Holds the structure for the system you are getting \\beta from\n (either perfectCrystal or solidDefect ) type( crystal ), intent(inout) :: projectedSystem Holds the structure for the system you are projecting\n (either perfectCrystal or solidDefect ) public subroutine pawCorrectionWfc (system) Calculates the augmentation part of the transition matrix element Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) public subroutine pawCorrectionK (system) Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) public subroutine ylm (V_in, LMAX, Y) Returns the spherical harmonics for a given argument vector up to the maximum value of l given Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_in (3) Vector, argument of the spherical harmonics (we calculate Y_l&#94;m(\\mathbf{v}/|\\mathbf{v}|) ) integer, intent(in) :: LMAX Spherical harmonics are calculated for l = 0, 1, ..., l_{\\text{max}} complex(kind=dp), intent(out) :: Y (*) Array containing Y_l&#94;m(\\mathbf{v}) for several l,m public subroutine bessel_j (x, lmax, jl) Generates the spherical bessel function of the first kind for the given argument x and all possible indices from 0 to lmax Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: lmax real(kind=dp), intent(out) :: jl (0:lmax) public subroutine writeResults (ik) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index public subroutine readUfis (ik) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine calculateVfiElements () Read more… Arguments None public subroutine readEigenvalues (ik) Read in the eigenvalues output from pw_export_for_TME Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index public subroutine finalizeCalculation () Stop timer, write out total time taken, and close the output file Arguments None public subroutine int2str (integ, string) Write a give integer to a string, using only as many digits as needed Arguments Type Intent Optional Attributes Name integer :: integ character(len=300) :: string","tags":"","loc":"module/tmemodule.html","title":"TMEModule – Carrier Cross Sections"},{"text":"read ( 1 , ' (d22.14,i5,4d22.14) ' ) E , dummyI , dummyD , MjsOfE0 , dummyD ! E = E * eVToHartree iE = int ( E / deltaE ) + 1 ! do i = 1 , nEMjs - 1 ! iE0 = iE read ( 1 , ' (d22.14,i5,4d22.14) ' ) E , dummyI , dummyD , MjsOfE , dummyD E = E * eVToHartree iE = int ( E / deltaE ) + 1 Mjs ( iE0 : iE ) = MjsOfE0 MjsOfE0 = MjsOfE ! enddo ! close ( 1 ) ! ! do iE = - nEnergies , nEnergies ! write ( 44 , * ) real ( iE , dp ) * deltaE * HartreeToEv , Mjs ( iE ) ! enddo ! Contents Variables dp int32 int64 iostd un pi twopi abCM THzToHartree HartreeToEv eVToHartree nAtoms nOfqPoints nModes ios ti tf t1 t2 temperature kT s2L atomD atomM phonQ phonF genCoord atomPosition newAtomicPosition wby2kT phonD x Sj coth besOrderNofModeM maxDisplacement modeI modeF qPoint elements output phononsInput equilibriumAtomicPositions newAtomicPositions QEInput file_exists readQEInput Functions msta1 msta2 envj Subroutines readInputs initialize checkAndUpdateInput readPhonons readAtomicPositions computeGeneralizedDisplacements computeVariables arrangeLargerToSmaller displaceAtoms writeNewAtomicPositions exportQEInput iknb iknb2 Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: iostd = 16 integer, public, parameter :: un = 3 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: THzToHartree = 1.0_dp/6579.683920729_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer, public :: nAtoms integer, public :: nOfqPoints integer, public :: nModes integer, public :: ios real(kind=dp), public :: ti real(kind=dp), public :: tf real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: temperature real(kind=dp), public :: kT integer, public, allocatable :: s2L (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: atomPosition (:,:) real(kind=dp), public, allocatable :: newAtomicPosition (:,:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: x (:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public :: maxDisplacement integer, public :: modeI integer, public :: modeF integer, public :: qPoint character(len=2), public, allocatable :: elements (:) character(len=6), public, parameter :: output = 'status' character(len=256), public :: phononsInput character(len=256), public :: equilibriumAtomicPositions character(len=256), public :: newAtomicPositions character(len=256), public :: QEInput logical, public :: file_exists logical, public :: readQEInput Functions public function msta1 (x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer public function msta2 (x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer public function envj (n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public subroutine readInputs () Arguments None public subroutine initialize () Arguments None public subroutine checkAndUpdateInput () Arguments None public subroutine readPhonons () Arguments None public subroutine readAtomicPositions () Arguments None public subroutine computeGeneralizedDisplacements () Arguments None public subroutine computeVariables () Arguments None public subroutine arrangeLargerToSmaller () Arguments None public subroutine displaceAtoms () Arguments None public subroutine writeNewAtomicPositions () Arguments None public subroutine exportQEInput () Arguments None public subroutine iknb (n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) public subroutine iknb2 (n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n)","tags":"","loc":"module/mjmodule.html","title":"MjModule – Carrier Cross Sections"},{"text":"Contents Variables dp int32 int64 iostd un root pi twopi abCM THzToHartree HartreeToEv eVToHartree myid numprocs ios istat ierr iMode l m nMC nProcMax iMint iMmod i printsteps iE ni mi nAtoms nOfqPoints nModes minimumNumberOfPhonons maximumNumberOfPhonons nEnergies ti tf t1 t2 weight times de E temperature maxEnergy deltaE kT iModeIs iModeFs pj pj0s pms s2L iEbinsByBands iEbinsByPhonons atomD atomM phonQ phonF genCoord wby2kT phonD x Sj coth besOrderNofModeM lsfVsEbyBands lsfVsE lsfVsEbyPhonons lsfbyPhononsPerProc output phononsInputFormat phononsInput fn continueLSFfromFile file_exists Functions lcg msta1 msta2 envj Subroutines readInputs initializeLSF initialize checkAndUpdateInput readPhononsVASP readPhononsQE computeGeneralizedDisplacements computeVariables arrangeLargerToSmaller lsfDeterministicFourPhononsByFourBands lsfOfConfigurationPj calculatePlusMinusStates distrubutePhononsInBands lsfWithMphonons decimalToOther calculateDE lsfMbyOneBand lsfMbyTwoBands lsfMbyThreeBands writeLSFandCrossSection init_random_seed iknb iknb2 parallelIsFsBy3 parallelIsFsBy4 Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: iostd = 16 integer, public, parameter :: un = 3 integer, public, parameter :: root = 0 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: THzToHartree = 1.0_dp/6579.683920729_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer(kind=int32), public :: myid integer(kind=int32), public :: numprocs integer(kind=int32), public :: ios integer(kind=int32), public :: istat integer(kind=int32), public :: ierr integer, public :: iMode integer, public :: l integer, public :: m integer, public :: nMC integer, public :: nProcMax integer, public :: iMint integer, public :: iMmod integer, public :: i integer, public :: printsteps integer, public :: iE integer, public :: ni integer, public :: mi integer, public :: nAtoms integer, public :: nOfqPoints integer, public :: nModes integer, public :: minimumNumberOfPhonons integer, public :: maximumNumberOfPhonons integer, public :: nEnergies real(kind=dp), public :: ti real(kind=dp), public :: tf real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: weight real(kind=dp), public :: times real(kind=dp), public :: de real(kind=dp), public :: E real(kind=dp), public :: temperature real(kind=dp), public :: maxEnergy real(kind=dp), public :: deltaE real(kind=dp), public :: kT integer, public, allocatable :: iModeIs (:) integer, public, allocatable :: iModeFs (:) integer, public, allocatable :: pj (:) integer, public, allocatable :: pj0s (:,:) integer, public, allocatable :: pms (:,:) integer, public, allocatable :: s2L (:) integer, public, allocatable :: iEbinsByBands (:) integer, public, allocatable :: iEbinsByPhonons (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: x (:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public, allocatable :: lsfVsEbyBands (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonons (:) real(kind=dp), public, allocatable :: lsfbyPhononsPerProc (:) character(len=6), public, parameter :: output = 'status' character(len=256), public :: phononsInputFormat character(len=256), public :: phononsInput character(len=256), public :: fn character(len=256), public :: continueLSFfromFile logical, public :: file_exists Functions public function lcg (s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer public function msta1 (x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer public function msta2 (x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer public function envj (n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public subroutine readInputs () Arguments None public subroutine initializeLSF () Arguments None public subroutine initialize () Arguments None public subroutine checkAndUpdateInput () Arguments None public subroutine readPhononsVASP () Arguments None public subroutine readPhononsQE () Arguments None public subroutine computeGeneralizedDisplacements () Arguments None public subroutine computeVariables () Arguments None public subroutine arrangeLargerToSmaller () Arguments None public subroutine lsfDeterministicFourPhononsByFourBands () Arguments None public subroutine lsfOfConfigurationPj () Arguments None public subroutine calculatePlusMinusStates (l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l public subroutine distrubutePhononsInBands (m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l public subroutine lsfWithMphonons (m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes public subroutine decimalToOther (iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) public subroutine calculateDE (maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de public subroutine lsfMbyOneBand (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyTwoBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyThreeBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine writeLSFandCrossSection () Arguments None public subroutine init_random_seed () Arguments None public subroutine iknb (n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) public subroutine iknb2 (n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) public subroutine parallelIsFsBy3 () Arguments None public subroutine parallelIsFsBy4 () Arguments None","tags":"","loc":"module/lsf.html","title":"lsf – Carrier Cross Sections"},{"text":"Contents Variables dp int32 int64 iostd un root pi twopi abCM THzToHartree HartreeToEv eVToHartree myid numprocs ios istat ierr iMode l m nMC nProcMax iMint iMmod i printsteps iE ni mi nAtoms nOfqPoints nModes minimumNumberOfPhonons maximumNumberOfPhonons nEnergies ti tf t1 t2 weight times de E temperature maxEnergy deltaE kT iModeIs iModeFs pj pj0s pms s2L iEbinsByBands iEbinsByPhonons atomD atomM phonQ phonF genCoord Mjs wby2kT phonD x Sj coth besOrderNofModeM lsfVsEbyBands lsfVsE lsfVsEbyPhonons lsfbyPhononsPerProc modes output MjsInput phononsInput fn continueLSFfromFile equilibriumAtomicPositions file_exists Functions lcg msta1 msta2 envj Subroutines readInputs initializeLSF initialize checkAndUpdateInput readPhonons computeGeneralizedDisplacements computeVariables arrangeLargerToSmaller readMjs lsfDeterministicFourPhononsByFourBands lsfOfConfigurationPj calculatePlusMinusStates distrubutePhononsInBands lsfWithMphonons decimalToOther calculateDE lsfMbyOneBand lsfMbyTwoBands lsfMbyThreeBands writeLSFandCrossSection init_random_seed iknb iknb2 parallelIsFsBy3 parallelIsFsBy4 Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: iostd = 16 integer, public, parameter :: un = 3 integer, public, parameter :: root = 0 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: THzToHartree = 1.0_dp/6579.683920729_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer(kind=int32), public :: myid integer(kind=int32), public :: numprocs integer(kind=int32), public :: ios integer(kind=int32), public :: istat integer(kind=int32), public :: ierr integer, public :: iMode integer, public :: l integer, public :: m integer, public :: nMC integer, public :: nProcMax integer, public :: iMint integer, public :: iMmod integer, public :: i integer, public :: printsteps integer, public :: iE integer, public :: ni integer, public :: mi integer, public :: nAtoms integer, public :: nOfqPoints integer, public :: nModes integer, public :: minimumNumberOfPhonons integer, public :: maximumNumberOfPhonons integer, public :: nEnergies real(kind=dp), public :: ti real(kind=dp), public :: tf real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: weight real(kind=dp), public :: times real(kind=dp), public :: de real(kind=dp), public :: E real(kind=dp), public :: temperature real(kind=dp), public :: maxEnergy real(kind=dp), public :: deltaE real(kind=dp), public :: kT integer, public, allocatable :: iModeIs (:) integer, public, allocatable :: iModeFs (:) integer, public, allocatable :: pj (:) integer, public, allocatable :: pj0s (:,:) integer, public, allocatable :: pms (:,:) integer, public, allocatable :: s2L (:) integer, public, allocatable :: iEbinsByBands (:) integer, public, allocatable :: iEbinsByPhonons (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: Mjs (:,:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: x (:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public, allocatable :: lsfVsEbyBands (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonons (:) real(kind=dp), public, allocatable :: lsfbyPhononsPerProc (:) integer, public :: modes character(len=6), public, parameter :: output = 'status' character(len=256), public :: MjsInput character(len=256), public :: phononsInput character(len=256), public :: fn character(len=256), public :: continueLSFfromFile character(len=256), public :: equilibriumAtomicPositions logical, public :: file_exists Functions public function lcg (s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer public function msta1 (x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer public function msta2 (x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer public function envj (n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public subroutine readInputs () Arguments None public subroutine initializeLSF () Arguments None public subroutine initialize () Arguments None public subroutine checkAndUpdateInput () Arguments None public subroutine readPhonons () Arguments None public subroutine computeGeneralizedDisplacements () Arguments None public subroutine computeVariables () Arguments None public subroutine arrangeLargerToSmaller () Arguments None public subroutine readMjs () Arguments None public subroutine lsfDeterministicFourPhononsByFourBands () Arguments None public subroutine lsfOfConfigurationPj () Arguments None public subroutine calculatePlusMinusStates (l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l public subroutine distrubutePhononsInBands (m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l public subroutine lsfWithMphonons (m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes public subroutine decimalToOther (iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) public subroutine calculateDE (maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de public subroutine lsfMbyOneBand (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyTwoBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyThreeBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine writeLSFandCrossSection () Arguments None public subroutine init_random_seed () Arguments None public subroutine iknb (n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) public subroutine iknb2 (n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) public subroutine parallelIsFsBy3 () Arguments None public subroutine parallelIsFsBy4 () Arguments None","tags":"","loc":"module/lsf~2.html","title":"lsf – Carrier Cross Sections"},{"text":"Contents Variables dp int32 iostd maxEnergy nOfEnergyBins pi twopi abCM HartreeToEv eVToHartree ios nEnergies m numOfVfis volume de eifMin DHifMin E Vfis lsfVsE lsfVsEbyPhonon energy lsf sigma sigmaByPhonon lorentz lorentzByPhonon output VfisInput LSFinput crossSectionOutput file_exists Subroutines readInputs initialize checkInputAndUpdateParameters readLSF readVfis calculateSigma writeSigma Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: iostd = 16 real(kind=dp), public, parameter :: maxEnergy = 10.0_dp integer, public, parameter :: nOfEnergyBins = 5040 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer(kind=int32), public :: ios integer, public :: nEnergies integer, public :: m integer, public :: numOfVfis real(kind=dp), public :: volume real(kind=dp), public :: de real(kind=dp), public :: eifMin real(kind=dp), public :: DHifMin real(kind=dp), public, allocatable :: E (:) real(kind=dp), public, allocatable :: Vfis (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonon (:) real(kind=dp), public, allocatable :: energy (:) real(kind=dp), public, allocatable :: lsf (:) real(kind=dp), public, allocatable :: sigma (:) real(kind=dp), public, allocatable :: sigmaByPhonon (:) real(kind=dp), public, allocatable :: lorentz (:) real(kind=dp), public, allocatable :: lorentzByPhonon (:) character(len=11), public, parameter :: output = 'sigmaStatus' character(len=256), public :: VfisInput character(len=256), public :: LSFinput character(len=256), public :: crossSectionOutput logical, public :: file_exists Subroutines public subroutine readInputs () Arguments None public subroutine initialize () Arguments None public subroutine checkInputAndUpdateParameters () Arguments None public subroutine readLSF () Arguments None public subroutine readVfis () Arguments None public subroutine calculateSigma () Arguments None public subroutine writeSigma () Arguments None","tags":"","loc":"module/sigma_module.html","title":"sigma_module – Carrier Cross Sections"},{"text":"Uses wrappers pwcom io_global io_files ions_base iotk_module mp_global mp_pools mp_world mp environment Contents Variables trimcheck ik i kunittmp ios ryToHartree pp_file exportDir writeWFC Subroutines write_export Source Code pw_export_for_TME Variables Type Attributes Name Initial character(len=256), EXTERNAL :: trimcheck integer :: ik integer :: i integer :: kunittmp integer :: ios real(kind=dp), parameter :: ryToHartree = 0.5_dp character(len=256) :: pp_file character(len=256) :: exportDir logical :: writeWFC Subroutines subroutine write_export (pp_file, exportDir, kunit) Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: pp_file character(len=256), intent(in) :: exportDir integer, intent(in) :: kunit Source Code PROGRAM pw_export_for_TME !----------------------------------------------------------------------- ! ! writes PWSCF data for postprocessing purposes in XML format using IOTK lib ! Wave-functions are collected and written using IO_BASE module. ! ! input:  namelist \"&inputpp\", with variables !   prefix       prefix of input files saved by program pwscf !   outdir       temporary directory where files resides !   exportDir    output directory. A directory !                \"exportDir\" is created and !                output files are put there. All the data !                are accessible through the \"\"exportDir\"/input\" file. ! USE wrappers , ONLY : f_mkdir_safe USE pwcom USE io_global , ONLY : ionode , ionode_id USE io_files , ONLY : prefix , tmp_dir , outdir USE ions_base , ONLY : ntype => nsp USE iotk_module USE mp_global , ONLY : mp_startup USE mp_pools , ONLY : kunit USE mp_world , ONLY : world_comm USE mp , ONLY : mp_bcast USE environment , ONLY : environment_start ! IMPLICIT NONE ! CHARACTER ( LEN = 256 ), EXTERNAL :: trimcheck ! INTEGER :: ik , i , kunittmp , ios ! real ( kind = dp ), parameter :: ryToHartree = 0.5_dp ! CHARACTER ( len = 256 ) :: pp_file , exportDir LOGICAL :: writeWFC ! NAMELIST / inputpp / prefix , outdir , exportDir , writeWFC ! ! initialise environment ! #ifdef __MPI CALL mp_startup ( ) #endif CALL environment_start ( 'PW_EXPORT' ) ! !   set default values for variables in namelist ! prefix = '' CALL get_environment_variable ( 'ESPRESSO_TMPDIR' , outdir ) IF ( trim ( outdir ) == ' ' ) outdir = './' exportDir = './Export' ! writeWFC = . true . ! gdb : by default the wavefunctions are needed, !       this gives the user the ability not to write the wavefunctions ! !    Reading input file ! IF ( ionode ) THEN ! CALL input_from_file ( ) ! READ ( 5 , inputpp , IOSTAT = ios ) ! IF ( ios /= 0 ) CALL errore ( 'pw_export' , 'reading inputpp namelist' , abs ( ios ) ) ! ios = f_mkdir_safe ( trim ( exportDir ) ) ! pp_file = trim ( exportDir ) // \"/input\" ! ! ENDIF ! ! ... Broadcasting variables ! tmp_dir = trimcheck ( outdir ) CALL mp_bcast ( outdir , ionode_id , world_comm ) CALL mp_bcast ( tmp_dir , ionode_id , world_comm ) CALL mp_bcast ( prefix , ionode_id , world_comm ) ! !   Now allocate space for pwscf variables, read and check them. ! CALL read_file CALL openfil_pp ! #if defined __MPI kunittmp = kunit #else kunittmp = 1 #endif CALL write_export ( pp_file , exportDir , kunittmp ) CALL stop_pp ! CONTAINS ! !----------------------------------------------------------------------- SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export END PROGRAM pw_export_for_TME","tags":"","loc":"program/pw_export_for_tme.html","title":"pw_export_for_TME – Carrier Cross Sections"},{"text":"Uses mpi TMEModule Todo Finish documentation for main program Walkthrough Use pre-built mpi library and declarations module that \n is defined in TME_Module_v28.f90 Initialize MPI environment Determine the rank or ID of the calling process Determine the size of the MPI pool (i.e., the number of processes) If this is the root process Call initializeCalculation to start timer and set default values Call readInput to read program input and\n  QE Export output Call readPWsSet to read g vectors from mgrid file Initialize all values in Ufi matrix to complex double zero Figure out how many g vectors/plane waves to give each process Initialize the number of initial and final plane waves to zero for each process For each process, calculate the initial (before this process) and final (after this process)\n  number of plane waves Todo Figure out if need to allocate space for arrays so soon Todo Figure out if SD and PC numOfGvecs should be the same Broadcast variables from root process to all other processes, allocating space as needed Todo Figure out if should be solid defect volume or pristine Todo Are pristine and solid defect volume the same? Contents Variables t1 t2 Source Code transitionMatrixElements Variables Type Attributes Name Initial real(kind=dp) :: t1 Declare start and end times real(kind=dp) :: t2 Declare start and end times Source Code program transitionMatrixElements !! @todo Finish documentation for main program @endtodo !! !! <h2>Walkthrough</h2> !! use mpi use TMEModule !! * Use pre-built mpi library and declarations module that !! is defined in TME_Module_v28.f90 ! implicit none ! real ( kind = dp ) :: t1 , t2 !! * Declare start and end times ! call MPI_INIT ( ierr ) !! * Initialize MPI environment call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) !! * Determine the rank or ID of the calling process call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) !! * Determine the size of the MPI pool (i.e., the number of processes) ! allocate ( nPWsI ( 0 : numprocs - 1 ), nPWsF ( 0 : numprocs - 1 ) ) ! if ( myid == root ) then !! * If this is the root process !!    * Call [[TMEModule(module):initializeCalculation(subroutine)]] !!      to start timer and set default values !!    * Call [[TMEModule(module):readInput(subroutine)]] to read program input and !!      QE Export output !!    * Call [[TMEModule(module):readPWsSet(subroutine)]] to read g vectors from `mgrid` file !!    * Initialize all values in `Ufi` matrix to complex double zero !!    * Figure out how many g vectors/plane waves to give each process !!    * Initialize the number of initial and final plane waves to zero for each process !!    * For each process, calculate the initial (before this process) and final (after this process) !!      number of plane waves ! call initializeCalculation ( solidDefect , perfectCrystal , elementsPath , VFisOutput , ki , kf , eBin , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , calculateVFis , t0 ) ! call readInput ( perfectCrystal , solidDefect , elementsPath , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput ) ! call readPWsSet () ! !> @todo Figure out if need to allocate space for arrays so soon @endtodo allocate ( counts ( 0 : numprocs - 1 ) ) !, displmnt(0:numprocs-1) ) allocate ( Ufi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , perfectCrystal % nKpts ) ) allocate ( paw_SDKKPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( perfectCrystal % paw_Wfc ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( solidDefect % paw_Wfc ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_fi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( eigvI ( iBandIinit : iBandIfinal ), eigvF ( iBandFinit : iBandFfinal ) ) ! Ufi (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! call distributePWsToProcs ( solidDefect % numOfGvecs , numprocs ) !! @todo Figure out if SD and PC `numOfGvecs` should be the same @endtodo ! nPWsI (:) = 0 nPWsF (:) = 0 ! do i = 0 , numprocs - 1 nPWsI ( i ) = 1 + sum ( counts (: i - 1 )) nPWsF ( i ) = sum ( counts (: i )) enddo ! endif ! !-------------------------------------------------------------------------------------------------------- !> Broadcast variables from root process to all other processes, allocating space as needed ! call MPI_BCAST ( iBandIinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandIfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % nKpts , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % nProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nBands , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nSpins , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % numOfPWs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % numOfGvecs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nPWsI , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nPWsF , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( JMAX , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( gvecs ( 3 , solidDefect % numOfGvecs ) ) call MPI_BCAST ( gvecs , size ( gvecs ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( perfectCrystal % atoms ( perfectCrystal % numOfTypes ) ) ! do i = 1 , perfectCrystal % numOfTypes ! call MPI_BCAST ( perfectCrystal % atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% numProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% iRAugMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( perfectCrystal % atoms ( i )% projAngMom ( perfectCrystal % atoms ( i )% numProjs ) ) allocate ( perfectCrystal % atoms ( i )% r ( perfectCrystal % atoms ( i )% nMax ) ) allocate ( perfectCrystal % atoms ( i )% rab ( perfectCrystal % atoms ( i )% nMax ) ) allocate ( perfectCrystal % atoms ( i )% F ( perfectCrystal % atoms ( i )% iRAugMax , perfectCrystal % atoms ( i )% numProjs ) ) allocate ( perfectCrystal % atoms ( i )% F1 ( perfectCrystal % atoms ( i )% iRAugMax , perfectCrystal % atoms ( i )% numProjs , & perfectCrystal % atoms ( i )% numProjs )) allocate ( perfectCrystal % atoms ( i )% bes_J_qr ( 0 : JMAX , perfectCrystal % atoms ( i )% iRAugMax ) ) endif ! call MPI_BCAST ( perfectCrystal % atoms ( i )% projAngMom , size ( perfectCrystal % atoms ( i )% projAngMom ), & MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% r , size ( perfectCrystal % atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% rab , size ( perfectCrystal % atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% F , size ( perfectCrystal % atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% F1 , size ( perfectCrystal % atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% bes_J_qr , size ( perfectCrystal % atoms ( i )% bes_J_qr ), & MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( perfectCrystal % nIons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( perfectCrystal % posIon ( 3 , perfectCrystal % nIons ), perfectCrystal % atomTypeIndex ( perfectCrystal % nIons ) ) call MPI_BCAST ( perfectCrystal % atomTypeIndex , size ( perfectCrystal % atomTypeIndex ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % posIon , size ( perfectCrystal % posIon ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( solidDefect % numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( solidDefect % atoms ( solidDefect % numOfTypes ) ) ! do i = 1 , solidDefect % numOfTypes ! call MPI_BCAST ( solidDefect % atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% numProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% iRAugMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( solidDefect % atoms ( i )% projAngMom ( solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% r ( solidDefect % atoms ( i )% nMax ) ) allocate ( solidDefect % atoms ( i )% rab ( solidDefect % atoms ( i )% nMax ) ) allocate ( solidDefect % atoms ( i )% F ( solidDefect % atoms ( i )% iRAugMax , solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% F1 ( solidDefect % atoms ( i )% iRAugMax , & solidDefect % atoms ( i )% numProjs , solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% bes_J_qr ( 0 : JMAX , solidDefect % atoms ( i )% iRAugMax ) ) endif ! call MPI_BCAST ( solidDefect % atoms ( i )% projAngMom , size ( solidDefect % atoms ( i )% projAngMom ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% r , size ( solidDefect % atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% rab , size ( solidDefect % atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% F , size ( solidDefect % atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% F1 , size ( solidDefect % atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% bes_J_qr , size ( solidDefect % atoms ( i )% bes_J_qr ), MPI_DOUBLE_PRECISION , & root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( solidDefect % nIons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( solidDefect % posIon ( 3 , solidDefect % nIons ), solidDefect % atomTypeIndex ( solidDefect % nIons ) ) call MPI_BCAST ( solidDefect % atomTypeIndex , size ( solidDefect % atomTypeIndex ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % posIon , size ( solidDefect % posIon ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! allocate ( paw_id ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) ! !-------------------------------------------------------------------------------------------------------- ! do ik = 1 , perfectCrystal % nKpts ! if ( myid == root ) then ! tmes_file_exists = . false . call checkIfCalculated ( ik , tmes_file_exists ) ! endif ! call MPI_BCAST ( tmes_file_exists , 1 , MPI_LOGICAL , root , MPI_COMM_WORLD , ierr ) ! if ( . not . tmes_file_exists ) then ! allocate ( perfectCrystal % cProj ( perfectCrystal % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) allocate ( solidDefect % cProj ( solidDefect % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) ! if ( myid == root ) then ! write ( iostd , '(\" Starting Ufi(:,:) calculation for k-point\", i4, \" of\", i4)' ) ik , perfectCrystal % nKpts flush ( iostd ) ! write ( iostd , * ) write ( iostd , '(\"    Plane waves part begun.\")' ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> begun.\")' ) call cpu_time ( t1 ) allocate ( perfectCrystal % wfc ( solidDefect % numOfPWs , iBandIinit : iBandIfinal ), & solidDefect % wfc ( solidDefect % numOfPWs , iBandFinit : iBandFfinal ) ) ! call calculatePWsOverlap ( ik ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! write ( iostd , '(\"    Plane waves part done in\", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) write ( iostd , '(\"    PAW part begun.\")' ) ! call cpu_time ( t1 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> begun.\")' ) flush ( iostd ) ! call readProjections ( ik , perfectCrystal ) ! allocate ( perfectCrystal % cCrossProj ( perfectCrystal % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) call projectBeta ( ik , perfectCrystal , solidDefect ) ! deallocate ( solidDefect % wfc ) ! call pawCorrectionWfc ( perfectCrystal ) ! deallocate ( perfectCrystal % cCrossProj ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 call cpu_time ( t1 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> begun.\")' ) flush ( iostd ) ! call readProjections ( ik , solidDefect ) ! allocate ( solidDefect % cCrossProj ( solidDefect % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) call projectBeta ( ik , solidDefect , perfectCrystal ) ! deallocate ( perfectCrystal % wfc ) ! call pawCorrectionWfc ( solidDefect ) deallocate ( solidDefect % cCrossProj ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! call cpu_time ( t1 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6ES14.5E3)') ibi, ibf, solidDefect%paw_Wfc(ibf,ibi), perfectCrystal%paw_Wfc(ibf,ibi), paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! !call pawCorrection() !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) + paw_fi(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf,ibi,ik), paw, Ufi(ibf,ibi,ik) + paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! endif ! call MPI_BCAST ( perfectCrystal % cProj , size ( perfectCrystal % cProj ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % cProj , size ( solidDefect % cProj ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) ! allocate ( perfectCrystal % pawK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid )) ) ! call pawCorrectionK ( perfectCrystal ) ! if ( myid == root ) then call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 ! call cpu_time ( t1 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> begun.\")' ) flush ( iostd ) ! endif ! allocate ( solidDefect % pawK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid ) ) ) ! call pawCorrectionK ( solidDefect ) ! if ( myid == root ) then ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> done in\", f10.2, \" secs.\")' ) t2 - t1 ! call cpu_time ( t1 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) ! endif ! paw_id (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal paw_id ( ibf , ibi ) = sum ( solidDefect % pawK ( ibf , ibi ,:) * perfectCrystal % pawK ( ibf , ibi ,:)) enddo ! enddo ! if ( myid == root ) paw_SDKKPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! CALL MPI_REDUCE ( paw_id , paw_SDKKPC , size ( paw_id ), MPI_DOUBLE_COMPLEX , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call cpu_time ( t2 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! Ufi (:,:, ik ) = Ufi (:,:, ik ) + solidDefect % paw_Wfc (:,:) + perfectCrystal % paw_Wfc (:,:) + & paw_SDKKPC (:,:) * 1 6.0_dp * pi * pi / solidDefect % omega !! @todo Figure out if should be solid defect volume or pristine @endtodo !! @todo Are pristine and solid defect volume the same? @endtodo ! call writeResults ( ik ) ! !write(iostd,*)'--------------------------------------------------------------------------------------------' ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = iBandFinit, iBandFfinal !    !paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) + paw_SDKKPC(ibf,ibi)*16.0_dp*pi*pi/solidDefect%omega !    !write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf, ibi, ik), paw, Ufi(ibf, ibi, ik) + paw !    !Ufi(ibf, ibi, ik) = Ufi(ibf, ibi, ik) + paw !    write(iostd,'(\" Ufi \", 2i4, 2ES24.15E3)') ibi, ibf, Ufi(ibf, ibi, ik) !  enddo !  ! !  flush(iostd) !  ! !enddo ! !write(iostd,*)'--------------------------------------------------------------------------------------------' !flush(iostd) ! endif ! deallocate ( perfectCrystal % cProj , perfectCrystal % pawK ) deallocate ( solidDefect % cProj , solidDefect % pawK ) ! else ! if ( myid == root ) call readUfis ( ik ) ! endif ! enddo ! if ( allocated ( paw_id ) ) deallocate ( paw_id ) if ( myid == root ) then if ( allocated ( perfectCrystal % paw_Wfc ) ) deallocate ( perfectCrystal % paw_Wfc ) if ( allocated ( solidDefect % paw_Wfc ) ) deallocate ( solidDefect % paw_Wfc ) endif ! ! Calculating Vfi ! if ( myid == root ) then ! if ( calculateVfis ) call calculateVfiElements () ! ! Finalize Calculation ! call finalizeCalculation () ! endif ! call MPI_FINALIZE ( ierr ) ! end program transitionMatrixElements","tags":"","loc":"program/transitionmatrixelements.html","title":"transitionMatrixElements – Carrier Cross Sections"},{"text":"Uses MjModule Contents Source Code MjME Source Code program MjME ! use MjModule ! implicit none ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call displaceAtoms () ! if ( readQEInput ) then call exportQEInput () else call writeNewAtomicPositions () endif ! end program MjME","tags":"","loc":"program/mjme.html","title":"MjME – Carrier Cross Sections"},{"text":"Uses mpi lsf Contents Variables lll iPhonon charI Source Code lineShapeFunction Variables Type Attributes Name Initial integer :: lll integer :: iPhonon character(len=2) :: charI Source Code program lineShapeFunction ! ! Pull in modules use mpi use lsf ! implicit none ! ! Define an integer for ???? integer :: lll , iPhonon ! character ( len = 2 ) :: charI ! ! Initialize mpi and set up processes call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! ! If root process if ( myid == root ) then ! ! Start a timer call cpu_time ( ti ) ! ! Read input, check all variables needed and initialize the calculation. call readInputs () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call initializeLSF () ! endif ! ! Broadcast calculation parameters to all processes call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! ! For all processes that aren't the root if ( myid /= root ) then ! Allocate space for arrays allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !allocate( Vfis(-nEnergies:nEnergies) ) endif ! ! Broadcast arrays to all processes call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) !call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! ! Allocate space for arrays allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( 3 <= maximumNumberOfPhonons ) then ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! end if ! do iPhonon = minimumNumberOfPhonons , MIN0 ( maximumNumberOfPhonons , 4 ) if ( ( ( iPhonon == 1 . or . iPhonon == 2 ) . and . myid == root ) . or . iPhonon > 2 ) then if ( iPhonon > 2 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! endif ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then call cpu_time ( t1 ) ! call lsfMbyOneBand ( iPhonon ) ! if ( iPhonon > 1 ) then ! call lsfMbyTwoBands ( iPhonon ) ! else if ( iPhonon > 2 ) then ! call parallelIsFsBy3 () ! endif ! endif ! if ( iPhonon > 2 ) then ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( iPhonon ) ! endif ! if ( iPhonon > 3 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfDeterministicFourPhononsByFourBands () ! endif ! if ( iPhonon > 2 ) then ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! endif if ( myid == root ) then ! call cpu_time ( t2 ) ! write ( iostd , '(i2, \" modes, time needed :,\" , f10.2, \" secs.\")' ) iPhonon , t2 - t1 flush ( iostd ) ! if ( iPhonon > 2 ) then ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! else ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByBands , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! endif ! write ( iostd , * ) 'DE' , iPhonon , de flush ( iostd ) ! charI = '' write ( charI , \"(i2.2)\" ) iPhonon ! open ( 1 , file = 'lsfVsEwithUpTo' // trim ( charI ) // 'phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , iPhonon ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! if ( iPhonon < 3 ) then ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de ! else ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de ! endif ! enddo ! close ( 1 ) ! endif ! endif ! enddo ! if ( maximumNumberOfPhonons >= 5 ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then ! if ( istat /= 0 ) then ! write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' ! else ! write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' ! endif ! flush ( iostd ) ! endif ! if ( istat /= 0 ) close ( un ) ! ! allocate ( lsfbyPhononsPerProc(-nEnergies:nEnergies) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC ! do i = numprocs - 1 , 1 , - 1 ! iModeIs ( i ) = i * iMint + 1 ! if ( iMmod > 0 ) then ! iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 ! endif ! iModeFs ( i - 1 ) = iModeIs ( i ) - 1 ! enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 ! do ni = m - 1 , m - l + 1 , - 1 ! times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 ! enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = nModes ! do iMode = 2 , l ! weight = weight * ( nModes - iMode + 1 ) / iMode ! enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m ! elseif ( m < 100 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m ! elseif ( m < 1000 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m ! else ! write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m ! endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de ! enddo ! close ( 5000 ) ! endif ! enddo ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! deallocate ( lsfVsEbyBands , iEbinsByBands , pj ) ! if ( 3 <= maximumNumberOfPhonons ) then ! deallocate ( iModeIs , iModeFs ) ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! end if ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"program/lineshapefunction.html","title":"lineShapeFunction – Carrier Cross Sections"},{"text":"Uses mpi lsf Contents Source Code lineShapeFunction Source Code program lineShapeFunction ! use mpi use lsf ! implicit none ! call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! if ( myid == root ) then ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call readPhonons () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call readMjs () ! call initializeLSF () ! endif ! call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( modes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !    allocate( Vfis(-nEnergies:nEnergies) ) endif ! call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( s2L , size ( s2L ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) !  call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( myid == root ) then ! !if ( maximumNumberOfPhonons > 0 ) then if ( ( minimumNumberOfPhonons < 2 ) . and . ( maximumNumberOfPhonons > 0 ) . and . ( modes > 0 ) ) then ! ! One phonon ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call lsfMbyOneBand ( 1 ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 1 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 1 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 1 , file = 'lsfVsEwithUpTo1phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 1 ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 1 ) ! endif ! if ( ( minimumNumberOfPhonons < 3 ) . and . ( maximumNumberOfPhonons > 1 ) . and . ( modes > 1 ) ) then ! ! Two phonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call cpu_time ( t1 ) ! call lsfMbyOneBand ( 2 ) call lsfMbyTwoBands ( 2 ) ! call cpu_time ( t2 ) ! write ( iostd , '(\" 2 modes, time needed :,\" , f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 2 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 2 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 2 , file = 'lsfVsEwithUpTo2phonons' , status = 'unknown' ) ! !      write(2,'(\"# \", i5, \" phonons\")') 2 write ( 2 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 2 do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 2 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 2 ) ! endif ! !   call lsfDeterministicOneAndTwoBands() ! !deallocate ( lsfVsEbyPhonons ) ! endif ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! !if ( maximumNumberOfPhonons > 2 ) then if ( ( minimumNumberOfPhonons < 4 ) . and . ( maximumNumberOfPhonons > 2 ) . and . ( modes > 2 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then ! call lsfMbyOneBand ( 3 ) call lsfMbyTwoBands ( 3 ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 3 ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 3 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 3 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo3phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 3 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 3 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! !if ( maximumNumberOfPhonons > 3 ) then if ( ( minimumNumberOfPhonons < 5 ) . and . ( maximumNumberOfPhonons > 3 ) . and . ( modes > 3 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( 4 ) call lsfMbyTwoBands ( 4 ) ! call parallelIsFsBy3 () ! !write(6,*) '3' !do i = 0, nProcMax - 1 !  write(6,*) i, iModeIs(i), iModeFs(i) !enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 4 ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !if ( myid == root ) then !  write(6,*) '4' !  do i = 0, nProcMax - 1 !    write(6,*) i, iModeIs(i), iModeFs(i) !  enddo !endif ! call lsfDeterministicFourPhononsByFourBands () ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 4 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 4 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo4phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 4 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 4 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! if ( ( maximumNumberOfPhonons > 4 ) . and . ( modes > 4 ) ) then !if ( ( minimumNumberOfPhonons < 6 ) .and. ( maximumNumberOfPhonons > 4 ) ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then if ( istat /= 0 ) then write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' else write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' endif flush ( iostd ) endif ! if ( istat /= 0 ) close ( un ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) allocate ( lsfbyPhononsPerProc ( - nEnergies : nEnergies ) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC do i = numprocs - 1 , 1 , - 1 iModeIs ( i ) = i * iMint + 1 if ( iMmod > 0 ) then iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 endif iModeFs ( i - 1 ) = iModeIs ( i ) - 1 enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 do ni = m - 1 , m - l + 1 , - 1 times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = modes ! do iMode = 2 , l weight = weight * ( modes - iMode + 1 ) / iMode enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m elseif ( m < 100 ) then write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m elseif ( m < 1000 ) then write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m else write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !        write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de enddo close ( 5000 ) ! endif ! enddo ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"program/lineshapefunction~2.html","title":"lineShapeFunction – Carrier Cross Sections"},{"text":"Uses sigma_module Contents Source Code crossSection Source Code program crossSection ! use sigma_module ! implicit none ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call calculateSigma () ! call writeSigma () ! end program crossSection","tags":"","loc":"program/crosssection.html","title":"crossSection – Carrier Cross Sections"},{"text":"Welcome to the README for the Carrier Cross Sections project! This tab contains more information\non the theory behind the code, the input and output files used by the code, and how to install/run\nthe code as well as a Todo list for cleaning up and developing the code.","tags":"","loc":"page//index.html","title":"README – Carrier Cross Sections"},{"text":"There are several input and output files used by this program. The goal of this\npage is to make it clear where these files come from, how they are used by the code\nand the physical meaning of the data in the files.","tags":"","loc":"page/inputOutput/index.html","title":"Input and Output Files – Carrier Cross Sections"},{"text":"This file is exported from pw_export_for_TME . It has the following format: # Cell volume ( a . u . ) &#94; 3 . Format : ' (ES24.15E3) ' 2 . 653020000000000 E + 002 # Number of K - points . Format : ' (i10) ' 2 # ik , groundState , ngk_g ( ik ) , wk ( ik ) , xk ( 1 : 3 , ik ) . Format : ' (3i10,4ES24.15E3) ' 1 0 180 5 . 000000000000000 E - 001 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 2 0 186 1 . 500000000000000 E + 000 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 7 . 500000000000000 E - 001 # Number of G - vectors . Format : ' (i10) ' 1459 # Number of PW - vectors . Format : ' (i10) ' 266 # Number of min - max values of fft grid in x , y and z axis . Format : ' (6i10) ' - 7 7 - 7 7 - 7 7 # Cell ( a . u . ) . Format : ' (a5, 3ES24.15E3) ' # a1 - 5 . 100000000000000 E + 000 0 . 000000000000000 E + 000 5 . 100000000000000 E + 000 # a2 0 . 000000000000000 E + 000 5 . 100000000000000 E + 000 5 . 100000000000000 E + 000 # a3 - 5 . 100000000000000 E + 000 5 . 100000000000000 E + 000 0 . 000000000000000 E + 000 # Reciprocal cell ( a . u . ) . Format : ' (a5, 3ES24.15E3) ' # b1 - 6 . 159985595274104 E - 001 - 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 # b2 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 # b3 - 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 - 6 . 159985595274104 E - 001 # Number of Atoms . Format : ' (i10) ' 2 # Number of Types . Format : ' (i10) ' 1 # Atoms type , position ( 1 : 3 ) ( a . u . ) . Format : ' (i10,3ES24.15E3) ' 1 0 . 000000000000000 E + 000 0 . 000000000000000 E + 000 0 . 000000000000000 E + 000 1 2 . 550000000000000 E + 000 2 . 550000000000000 E + 000 2 . 550000000000000 E + 000 # Number of Bands . Format : ' (i10) ' 4 # Spin . Format : ' (i10) ' 1 # Element Si # Number of Atoms of this type . Format : ' (i10) ' 2 # Number of projectors . Format : ' (i10) ' 6 # Angular momentum , index of the projectors . Format : ' (2i10) ' 0 1 0 2 1 3 1 4 2 5 2 6 # Number of channels . Format : ' (i10) ' 18 # Number of radial mesh points . Format : ' (2i10) ' 1141 837 # Radial grid , Integratable grid . Format : ' (2ES24.15E3) ' 6 . 513442611103688 E - 005 8 . 141803263879609 E - 007 6 . 595371633350159 E - 005 8 . 244214541687697 E - 007 6 . 678331195832729 E - 005 8 . 347913994790911 E - 007 6 . 762334261151813 E - 005 8 . 452917826439768 E - 007 6 . 847393954957285 E - 005 8 . 559242443696606 E - 007 ...\n# AE , PS radial wfc for each beta function . Format : ' (2ES24.15E3) ' 5 . 130578464215461 E - 004 3 . 370121859129863 E - 005 5 . 194773426646861 E - 004 3 . 412512773645108 E - 005 5 . 259771611021033 E - 004 3 . 455436900225269 E - 005 5 . 325583067433258 E - 004 3 . 498900945852498 E - 005 5 . 392217087420185 E - 004 3 . 542911701872407 E - 005 ...\n# Fermi Energy ( Hartree ) . Format : ' (ES24.15E3) ' 2 . 090654946391985 E - 001 Currently, the program does not read in cell volume, groundState , number of G vectors, the fft grid min and max values, real space or reciprocal space lattice vectors, number of bands, or spin format.","tags":"","loc":"page/inputOutput/exportedInput.html","title":"input – Carrier Cross Sections"},{"text":"Can use xcrysden to visualize QE input and output Can convert from QE output to xsf (VASP format) using PW/tools/pwo2xsf.sh There are four different types of extraction from the PWscf output: initial structure: the one reported from the input at the beginning of the output file (for the SCF calculation one should select this option) latest structure: the latest structure in the output file; if the latest structure is the optimized structure, then this one is extracted. For an SCF calculation only initial structure is reported and the \"latest structure\" extraction extracts noting in this case optimized structure: extracts the optimized structure, if it is not present it extracts nothing all structures as animation What is the purpose of the QE calculation? --> Explore the TME program PC stands for perfect crystal and SD stands for solid defect","tags":"","loc":"page/./notes.html","title":"Notes – Carrier Cross Sections"},{"text":"Binary file ../TME/src/.TME_Main_v9.f90.swp matches ../TME/src/TME_Main_v9.f90:2: Finish documentation for main program ../TME/src/TME_Main_v9.f90:46: Figure out if need to allocate space for arrays so soon ../TME/src/TME_Main_v9.f90:58: Figure out if SD and PC numOfGvecs should be the same ../TME/src/TME_Main_v9.f90:329: Figure out if should be solid defect volume or pristine ../TME/src/TME_Main_v9.f90:330: Are pristine and solid defect volume the same? ../TME/src/TME_Module_v28.f90:34: Change I/O from file to console so that usage matches that of QE ../TME/src/TME_Module_v28.f90:156: Consider changing atom type to element since it holds more than one atom ../TME/src/TME_Module_v28.f90:402: Change checkInitialization() to have arguments to make clear that these variables are getting changed ../TME/src/TME_Module_v28.f90:544: Remove everything with ki and kf because never used ../TME/src/TME_Module_v28.f90:831: Look more into how AE and PS wavefunctions are combined to further understand this ../TME/src/TME_Module_v28.f90:832: Move this behavior to another subroutine for clarity ../TME/src/TME_Module_v28.f90:841: Figure out if differences in PC and SD F1 calculations are intentional ../TME/src/TME_Module_v28.f90:842: Figure out if should be (wae_i wae_j - wps_i wps_j)r_{ab} ../TME/src/TME_Module_v28.f90:843: Figure out if first term in each should be conjugated for inner product form ../TME/src/TME_Module_v28.f90:844: Figure out if rab plays role of dr within augmentation sphere ../TME/src/TME_Module_v28.f90:883: Figure out if intentional to only use JMAX from SD input ../TME/src/TME_Module_v28.f90:1039: Document calculatePWsOverlap() ../TME/src/TME_Module_v28.f90:1066: Figure out what Ufi is supposed to be ../TME/src/TME_Module_v28.f90:1217: Get actual perfect crystal and solid defect output to test ../TME/src/TME_Module_v28.f90:1218: Figure out if loop should be over solidDefect or perfectCrystal ../TME/src/TME_Module_v28.f90:1219: Look into nSpins to figure out if it is needed ../TME/src/TME_Module_v28.f90:1237: Figure out what this subroutine really does ../TME/src/TME_Module_v28.f90:1359: Figure out what this subroutine really does ../TME/src/TME_Module_v28.f90:1411: Figure out the significance of l = l&#94;{\\prime} and m = m&#94;{\\prime} ../TME/src/TME_Module_v28.f90:1443: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:1456: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:1493: Figure out what this subroutine really does ../TME/src/TME_Module_v28.f90:1565: Figure out if this output slows things down significantly ../TME/src/TME_Module_v28.f90:1566: Figure out if formula gives accurate representation of time left ../TME/src/TME_Module_v28.f90:1610: Figure out if this should be system ../TME/src/TME_Module_v28.f90:1611: Figure out significance of \"qr\" point ../TME/src/TME_Module_v28.f90:1614: Test if can just directly store in each atom type's bes_J_qr ../TME/src/TME_Module_v28.f90:1634: Figure out if this should be gDotR ../TME/src/TME_Module_v28.f90:1636: Figure out why this is called ATOMIC_CENTER ../TME/src/TME_Module_v28.f90:1637: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:1666: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:1681: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:2003: Document writeResults() @endto ../TME/src/TME_Module_v28.f90:2075: Document readUfis() ../TME/src/TME_Module_v28.f90:2129: Document calculateVFiElements()","tags":"","loc":"page/./todo.html","title":"Todo – Carrier Cross Sections"}]}