var tipuesearch = {"pages":[{"text":"Carrier Cross Sections Installation Dependencies Install all of the required dependencies (commands given for Unix environment): sudo apt-get update\nsudo apt install gfortran\nsudo apt install libmpich-dev\nsudo apt install libopenmpi-dev\nsudo apt-get install python-pip python-dev build-essential\nsudo pip install ford\nsudo apt-get install graphviz\nsudo wget https://github.com/QEF/q-e/archive/qe-5.3.tar.gz\nsudo apt-get install git Set up Quantum Espresso Change to whatever directory you saved the QE tar file in on the CLI Decompress the tar file using tar -xvzf q-e-qe-5.3.tar.gz Change into the q-e-qe-5.3 directory and run ./configure Confirm that the last line of output is configure: success Run make pw pp ph to build the PW, PP, and PHonon packages Compile Source Clone the repository using git clone https://github.com/laurarnichols/carrierCrossSections.git Change into the carrierCrossSections directory Open the Makefile and edit the path to Quantum Espresso to match your system Note: Make sure that your path does not have a / at the end or there will be an error * You should now be able to make the target you want (e.g., to compile everything, use make all_QE-5.3.0 )\n* For a list of some possible targets, read through the Makefile or type make Documentation This documentation is generated by FORD . Note This documentation is in progress. Please report any issues you find. How to Run I don't know how to run yet, so this section contains notes to try to figure that out. Here is a flow chart describing \nhow the programs connect as far as I know. TME stands for transition matrix element LSF stands for line shape function Sigma is likely the cross section calculation Mj is likely calculating equation 46 (for linear phonon TMEs) If cross section (sigma) is goal (zeroth order): TME and LSF --> Sigma ? QE --> TME ? Input and Output QE: Input: scf.in Output: scf.out output directory (e.g. tmp ) Export: Input: output directory Output: export directory TME: Input: export directory Output: VfisVsE LSF: Input: phonons_disp.dat --> where does this come from? Output: lsfVsEwithUpTo<%i>phonons Sigma Input: VfisVsE lsfVsEwithUpTo<%i>phonons","tags":"home","loc":"index.html","title":" Carrier Cross Sections "},{"text":"Contents Programs pw_export_for_TME Modules io_base_export Source Code Export_QE-5.3.0_v3.f90 Source Code ! ! Copyright (C) 2003-2009 Andrea Ferretti and Quantum ESPRESSO group ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !=----------------------------------------------------------------------------=! MODULE io_base_export !=----------------------------------------------------------------------------=! ! do i = 1, nk             !                                                   ! !   WAVEFUNCTIONS( i )     !  write_restart_wfc         read_restart_wfc       ! ! end do                   !                                                   ! USE io_global , ONLY : stdout USE kinds USE parameters , ONLY : nsx IMPLICIT NONE SAVE INTEGER , PARAMETER :: file_version = 202 INTEGER :: restart_module_verbosity = 0 !=----------------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------------=! ! !=----------------------------------------------------------------------------=! ! ..  This subroutine write wavefunctions to the disk ! .. Where: ! iuni    = Restart file I/O fortran unit ! SUBROUTINE write_restart_wfc ( iuni , exportDir , & ik , nk , kunit , ispin , nspin , scal , wf0 , t0 , wfm , tm , ngw , gamma_only , nbnd , igl , ngwl ) ! USE mp_wave USE mp , ONLY : mp_sum , mp_get , mp_max USE mp_pools , ONLY : me_pool , my_pool_id , & nproc_pool , intra_pool_comm , root_pool USE mp_world , ONLY : mpime , nproc , root , world_comm USE io_global , ONLY : ionode , ionode_id USE iotk_module ! IMPLICIT NONE ! INTEGER , INTENT ( in ) :: iuni character ( len = 256 ), intent ( in ) :: exportDir INTEGER , INTENT ( in ) :: ik , nk , kunit , ispin , nspin COMPLEX ( DP ), INTENT ( in ) :: wf0 (:,:) COMPLEX ( DP ), INTENT ( in ) :: wfm (:,:) INTEGER , INTENT ( in ) :: ngw ! LOGICAL , INTENT ( in ) :: gamma_only INTEGER , INTENT ( in ) :: nbnd INTEGER , INTENT ( in ) :: ngwl INTEGER , INTENT ( in ) :: igl (:) REAL ( DP ), INTENT ( in ) :: scal LOGICAL , INTENT ( in ) :: t0 , tm INTEGER :: i , j , ierr , idum = 0 INTEGER :: nkl , nkr , nkbl , iks , ike , nkt , ikt , igwx , ig INTEGER :: npool , ipmask ( nproc ), ipsour COMPLEX ( DP ), ALLOCATABLE :: wtmp (:) INTEGER , ALLOCATABLE :: igltot (:) CHARACTER ( len = 20 ) :: section_name = 'wfc' LOGICAL :: twrite = . true . INTEGER :: ierr_iotk CHARACTER ( len = iotk_attlenx ) :: attr ! ! ... Subroutine Body ! ! set working variables for k point index (ikt) and k points number (nkt) ikt = ik nkt = nk !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkt / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkt - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ipmask = 0 ipsour = ionode_id !  find out the index of the processor which collect the data in the pool of ik IF ( npool > 1 ) THEN IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN IF ( me_pool == root_pool ) ipmask ( mpime + 1 ) = 1 ENDIF CALL mp_sum ( ipmask , world_comm ) DO i = 1 , nproc IF ( ipmask ( i ) == 1 ) ipsour = ( i - 1 ) ENDDO ENDIF igwx = 0 ierr = 0 IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN IF ( ngwl > size ( igl ) ) THEN ierr = 1 ELSE igwx = maxval ( igl ( 1 : ngwl ) ) ENDIF ENDIF ! get the maximum index within the pool ! CALL mp_max ( igwx , intra_pool_comm ) ! now notify all procs if an error has been found ! CALL mp_max ( ierr , world_comm ) IF ( ierr > 0 ) & CALL errore ( ' write_restart_wfc ' , ' wrong size ngl ' , ierr ) IF ( ipsour /= ionode_id ) THEN CALL mp_get ( igwx , igwx , mpime , ionode_id , ipsour , 1 , world_comm ) ENDIF ALLOCATE ( wtmp ( max ( igwx , 1 ) ) ) wtmp = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) DO j = 1 , nbnd IF ( t0 ) THEN IF ( npool > 1 ) THEN IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN CALL mergewf ( wf0 (:, j ), wtmp , ngwl , igl , me_pool , & nproc_pool , root_pool , intra_pool_comm ) ENDIF IF ( ipsour /= ionode_id ) THEN CALL mp_get ( wtmp , wtmp , mpime , ionode_id , ipsour , j , world_comm ) ENDIF ELSE CALL mergewf ( wf0 (:, j ), wtmp , ngwl , igl , mpime , nproc , & ionode_id , world_comm ) ENDIF IF ( ionode ) THEN do ig = 1 , igwx write ( iuni , '(2ES24.15E3)' ) wtmp ( ig ) enddo ! !              do j = 1, nbnd !                do i = 1, igwx ! ngk_g(ik) !                  write(74,'(2ES24.15E3)') wf0(i,j) ! wf0 is the local array for evc(i,j) !                enddo !              enddo ! ENDIF ELSE ENDIF ENDDO !        DO j = 1, nbnd !          IF( tm ) THEN !            IF( npool > 1 ) THEN !              IF( ( ikt >= iks ) .and. ( ikt <= ike ) ) THEN !                CALL mergewf(wfm(:,j), wtmp, ngwl, igl, me_pool, & !                             nproc_pool, root_pool, intra_pool_comm) !              ENDIF !              IF( ipsour /= ionode_id ) THEN !                CALL mp_get( wtmp, wtmp, mpime, ionode_id, ipsour, j, world_comm ) !              ENDIF !            ELSE !              CALL mergewf(wfm(:,j), wtmp, ngwl, igl, mpime, nproc, ionode_id, world_comm ) !            ENDIF !            IF( ionode ) THEN !              CALL iotk_write_dat(iuni,\"Wfcm\"//iotk_index(j),wtmp(1:igwx)) !            ENDIF !          ELSE !          ENDIF !        ENDDO IF ( ionode ) then close ( iuni ) !CALL iotk_write_end  (iuni,\"Kpoint\"//iotk_index(ik)) endif DEALLOCATE ( wtmp ) RETURN END SUBROUTINE END MODULE !=----------------------------------------------------------------------------=! !----------------------------------------------------------------------- PROGRAM pw_export_for_TME !----------------------------------------------------------------------- ! ! writes PWSCF data for postprocessing purposes in XML format using IOTK lib ! Wave-functions are collected and written using IO_BASE module. ! ! input:  namelist \"&inputpp\", with variables !   prefix       prefix of input files saved by program pwscf !   outdir       temporary directory where files resides !   exportDir    output directory. A directory !                \"exportDir\" is created and !                output files are put there. All the data !                are accessible through the \"\"exportDir\"/input\" file. ! USE wrappers , ONLY : f_mkdir_safe USE pwcom USE io_global , ONLY : ionode , ionode_id USE io_files , ONLY : prefix , tmp_dir , outdir USE ions_base , ONLY : ntype => nsp USE iotk_module USE mp_global , ONLY : mp_startup USE mp_pools , ONLY : kunit USE mp_world , ONLY : world_comm USE mp , ONLY : mp_bcast USE environment , ONLY : environment_start ! IMPLICIT NONE ! CHARACTER ( LEN = 256 ), EXTERNAL :: trimcheck ! INTEGER :: ik , i , kunittmp , ios ! real ( kind = dp ), parameter :: ryToHartree = 0.5_dp ! CHARACTER ( len = 256 ) :: pp_file , exportDir LOGICAL :: writeWFC ! NAMELIST / inputpp / prefix , outdir , exportDir , writeWFC ! ! initialise environment ! #ifdef __MPI CALL mp_startup ( ) #endif CALL environment_start ( 'PW_EXPORT' ) ! !   set default values for variables in namelist ! prefix = '' CALL get_environment_variable ( 'ESPRESSO_TMPDIR' , outdir ) IF ( trim ( outdir ) == ' ' ) outdir = './' exportDir = './Export' ! writeWFC = . true . ! gdb : by default the wavefunctions are needed, !       this gives the user the ability not to write the wavefunctions ! !    Reading input file ! IF ( ionode ) THEN ! CALL input_from_file ( ) ! READ ( 5 , inputpp , IOSTAT = ios ) ! IF ( ios /= 0 ) CALL errore ( 'pw_export' , 'reading inputpp namelist' , abs ( ios ) ) ! ios = f_mkdir_safe ( trim ( exportDir ) ) ! pp_file = trim ( exportDir ) // \"/input\" ! ! ENDIF ! ! ... Broadcasting variables ! tmp_dir = trimcheck ( outdir ) CALL mp_bcast ( outdir , ionode_id , world_comm ) CALL mp_bcast ( tmp_dir , ionode_id , world_comm ) CALL mp_bcast ( prefix , ionode_id , world_comm ) ! !   Now allocate space for pwscf variables, read and check them. ! CALL read_file CALL openfil_pp ! #if defined __MPI kunittmp = kunit #else kunittmp = 1 #endif CALL write_export ( pp_file , exportDir , kunittmp ) CALL stop_pp ! CONTAINS ! !----------------------------------------------------------------------- SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export END PROGRAM pw_export_for_TME","tags":"","loc":"sourcefile/export_qe-5.3.0_v3.f90.html","title":"Export_QE-5.3.0_v3.f90 – Carrier Cross Sections"},{"text":"Contents Programs transitionMatrixElements Source Code TME_Main_v9.f90 Source Code program transitionMatrixElements ! ! Use pre-built mpi library and declarations module that ! is defined in TME_Module_v28.f90 use mpi use TMEModule ! implicit none ! ! Declare start and end times real ( kind = dp ) :: t1 , t2 ! ! Initialize MPI environment call MPI_INIT ( ierr ) ! Determine the rank or ID of the calling process call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) ! Determine the size of the MPI pool (i.e., the number of processes) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! ! Allocate space for variables allocate ( nPWsI ( 0 : numprocs - 1 ), nPWsF ( 0 : numprocs - 1 ) ) ! ! If this is the root process if ( myid == root ) then ! ! Start a timer call cpu_time ( t0 ) ! ! Reading input, initializing and checking all variables of the calculation. call readInput () ! ! ???????????????????????????????? call readPWsSet () ! ! Allocate space for variables allocate ( counts ( 0 : numprocs - 1 ), displmnt ( 0 : numprocs - 1 ) ) allocate ( Ufi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nKptsPC ) ) allocate ( paw_SDKKPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_PsiPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_SDPhi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_fi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( eigvI ( iBandIinit : iBandIfinal ), eigvF ( iBandFinit : iBandFfinal ) ) ! ! Initialize all values in Ufi matrix to complex double zero Ufi (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! ! Distribute plane waves to processes ??? call distributePWsToProcs ( numOfGvecs , numprocs ) ! ! Initialize the number of initial and final plane waves to zero for each process nPWsI (:) = 0 nPWsF (:) = 0 ! ! For each process, calculate the number of initial and final plane waves do i = 0 , numprocs - 1 nPWsI ( i ) = 1 + sum ( counts (: i - 1 )) nPWsF ( i ) = sum ( counts (: i )) enddo ! endif ! ! Broadcast variables from root process to all other processes call MPI_BCAST ( iBandIinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandIfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nKptsPC , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nProjsPC , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nProjsSD , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nBands , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nSpins , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( numOfPWs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( numOfGvecs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nPWsI , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nPWsF , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( numOfTypesPC , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( JMAX , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! ! Have other processes allocate space for gvecs so that root can send to them if ( myid /= root ) allocate ( gvecs ( 3 , numOfGvecs ) ) call MPI_BCAST ( gvecs , size ( gvecs ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( atomsPC ( numOfTypesPC ) ) ! ! For each type of ??? do i = 1 , numOfTypesPC ! ! Broadcast the variables in the atomsPC structure array call MPI_BCAST ( atomsPC ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% lMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% iRc , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! ! Allocate space for arrays in atomsPC structure if ( myid /= root ) then allocate ( atomsPC ( i )% lps ( atomsPC ( i )% lMax ) ) allocate ( atomsPC ( i )% r ( atomsPC ( i )% nMax ) ) allocate ( atomsPC ( i )% rab ( atomsPC ( i )% nMax ) ) allocate ( atomsPC ( i )% F ( atomsPC ( i )% iRc , atomsPC ( i )% lMax ) ) allocate ( atomsPC ( i )% F1 ( atomsPC ( i )% iRc , atomsPC ( i )% lMax , atomsPC ( i )% lMax ) ) allocate ( atomsPC ( i )% bes_J_qr ( 0 : JMAX , atomsPC ( i )% iRc ) ) endif ! ! Broadcast arrays from root to all other processes call MPI_BCAST ( atomsPC ( i )% lps , size ( atomsPC ( i )% lps ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% r , size ( atomsPC ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% rab , size ( atomsPC ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% F , size ( atomsPC ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% F1 , size ( atomsPC ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% bes_J_qr , size ( atomsPC ( i )% bes_J_qr ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( nIonsPC , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( posIonPC ( 3 , nIonsPC ), TYPNIPC ( nIonsPC ) ) call MPI_BCAST ( TYPNIPC , size ( TYPNIPC ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( posIonPC , size ( posIonPC ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( atoms ( numOfTypes ) ) ! do i = 1 , numOfTypes ! call MPI_BCAST ( atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% lMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% iRc , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( atoms ( i )% lps ( atoms ( i )% lMax ) ) allocate ( atoms ( i )% r ( atoms ( i )% nMax ) ) allocate ( atoms ( i )% rab ( atoms ( i )% nMax ) ) allocate ( atoms ( i )% F ( atoms ( i )% iRc , atoms ( i )% lMax ) ) allocate ( atoms ( i )% F1 ( atoms ( i )% iRc , atoms ( i )% lMax , atoms ( i )% lMax ) ) allocate ( atoms ( i )% bes_J_qr ( 0 : JMAX , atoms ( i )% iRc ) ) endif ! call MPI_BCAST ( atoms ( i )% lps , size ( atoms ( i )% lps ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% r , size ( atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% rab , size ( atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% F , size ( atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% F1 , size ( atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% bes_J_qr , size ( atoms ( i )% bes_J_qr ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( nIonsSD , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( posIonSD ( 3 , nIonsSD ), TYPNISD ( nIonsSD ) ) call MPI_BCAST ( TYPNISD , size ( TYPNISD ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( posIonSD , size ( posIonSD ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! allocate ( paw_id ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) ! do ik = 1 , nKptsPC ! if ( myid == root ) then ! tmes_file_exists = . false . call checkIfCalculated ( ik , tmes_file_exists ) ! endif ! call MPI_BCAST ( tmes_file_exists , 1 , MPI_LOGICAL , root , MPI_COMM_WORLD , ierr ) ! if ( . not . tmes_file_exists ) then ! allocate ( cProjPC ( nProjsPC , nBands , nSpins ) ) allocate ( cProjSD ( nProjsSD , nBands , nSpins ) ) ! if ( myid == root ) then ! write ( iostd , '(\" Starting Ufi(:,:) calculation for k-point\", i4, \" of\", i4)' ) ik , nKptsPC flush ( iostd ) ! write ( iostd , * ) write ( iostd , '(\"    Plane waves part begun.\")' ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> begun.\")' ) call cpu_time ( t1 ) allocate ( wfcPC ( numOfPWs , iBandIinit : iBandIfinal ), wfcSD ( numOfPWs , iBandFinit : iBandFfinal ) ) ! call calculatePWsOverlap ( ik ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! write ( iostd , '(\"    Plane waves part done in\", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) write ( iostd , '(\"    PAW part begun.\")' ) ! call cpu_time ( t1 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> begun.\")' ) flush ( iostd ) ! call readProjectionsPC ( ik ) ! allocate ( cProjBetaPCPsiSD ( nProjsPC , nBands , nSpins ) ) call projectBetaPCwfcSD ( ik ) ! deallocate ( wfcSD ) ! call pawCorrectionPsiPC () ! deallocate ( cProjBetaPCPsiSD ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 call cpu_time ( t1 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> begun.\")' ) flush ( iostd ) ! call readProjectionsSD ( ik ) ! allocate ( cProjBetaSDPhiPC ( nProjsSD , nBands , nSpins ) ) call projectBetaSDwfcPC ( ik ) ! deallocate ( wfcPC ) ! call pawCorrectionSDPhi () deallocate ( cProjBetaSDPhiPC ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! call cpu_time ( t1 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = paw_SDPhi(ibf,ibi) + paw_PsiPC(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6ES14.5E3)') ibi, ibf, paw_SDPhi(ibf,ibi), paw_PsiPC(ibf,ibi), paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! !call pawCorrection() !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = paw_SDPhi(ibf,ibi) + paw_PsiPC(ibf,ibi) + paw_fi(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf,ibi,ik), paw, Ufi(ibf,ibi,ik) + paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! endif ! call MPI_BCAST ( cProjPC , size ( cProjPC ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( cProjSD , size ( cProjSD ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) ! allocate ( pawKPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid )) ) ! call pawCorrectionKPC () ! if ( myid == root ) then call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 ! call cpu_time ( t1 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> begun.\")' ) flush ( iostd ) ! endif ! allocate ( pawSDK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid ) ) ) ! call pawCorrectionSDK () ! if ( myid == root ) then ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> done in\", f10.2, \" secs.\")' ) t2 - t1 ! call cpu_time ( t1 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) ! endif ! paw_id (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal paw_id ( ibf , ibi ) = sum ( pawSDK ( ibf , ibi ,:) * pawKPC ( ibf , ibi ,:)) enddo ! enddo ! if ( myid == root ) paw_SDKKPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! CALL MPI_REDUCE ( paw_id , paw_SDKKPC , size ( paw_id ), MPI_DOUBLE_COMPLEX , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call cpu_time ( t2 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! Ufi (:,:, ik ) = Ufi (:,:, ik ) + paw_SDPhi (:,:) + paw_PsiPC (:,:) + paw_SDKKPC (:,:) * 1 6.0_dp * pi * pi / omega ! call writeResults ( ik ) ! !write(iostd,*)'--------------------------------------------------------------------------------------------' ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = iBandFinit, iBandFfinal !    !paw = paw_SDPhi(ibf,ibi) + paw_PsiPC(ibf,ibi) + paw_SDKKPC(ibf,ibi)*16.0_dp*pi*pi/omega !    !write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf, ibi, ik), paw, Ufi(ibf, ibi, ik) + paw !    !Ufi(ibf, ibi, ik) = Ufi(ibf, ibi, ik) + paw !    write(iostd,'(\" Ufi \", 2i4, 2ES24.15E3)') ibi, ibf, Ufi(ibf, ibi, ik) !  enddo !  ! !  flush(iostd) !  ! !enddo ! !write(iostd,*)'--------------------------------------------------------------------------------------------' !flush(iostd) ! endif ! deallocate ( cProjPC , pawKPC ) deallocate ( cProjSD , pawSDK ) ! else ! if ( myid == root ) call readUfis ( ik ) ! endif ! enddo ! if ( allocated ( paw_id ) ) deallocate ( paw_id ) if ( myid == root ) then if ( allocated ( paw_PsiPC ) ) deallocate ( paw_PsiPC ) if ( allocated ( paw_SDPhi ) ) deallocate ( paw_SDPhi ) endif ! ! Calculating Vfi ! if ( myid == root ) then ! if ( calculateVfis ) call calculateVfiElements () ! ! Finalize Calculation ! call finalizeCalculation () ! endif ! call MPI_FINALIZE ( ierr ) ! end program transitionMatrixElements","tags":"","loc":"sourcefile/tme_main_v9.f90.html","title":"TME_Main_v9.f90 – Carrier Cross Sections"},{"text":"Contents Modules TMEModule Source Code TME_Module_v28.f90 Source Code module TMEModule ! !! Declare all global variables !! and house all subroutines !! implicit none ! ! Declare integer parameters integer , parameter :: dp = selected_real_kind ( 15 , 307 ) !! Used to set real variables to double precision integer , parameter :: iostd = 16 !! Unit number for output file integer , parameter :: root = 0 !! ID of the root process ! ! Declare real parameters real ( kind = dp ), parameter :: evToHartree = 0.03674932538878_dp !! Conversion factor from eV to Hartree real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp !! Conversion factor from Hartree to eV real ( kind = dp ), parameter :: pi = 3.141592653589793_dp !! Pi real ( kind = dp ), parameter :: sq4pi = 3.544907701811032_dp !! \\sqrt{4\\pi} ! ! Declare complex parameter complex ( kind = dp ), parameter :: ii = cmplx ( 0.0_dp , 1.0_dp , kind = dp ) !! Complex i ! ! Declare character parameter character ( len = 6 ), parameter :: output = 'output' !! Name of the output file; !! used in [[TMEModule(module):readInput(subroutine)]] ! ! ! Declare scalar integers integer :: fftxMin integer :: fftxMax integer :: fftyMin integer :: fftyMax integer :: fftzMin integer :: fftzMax integer :: gx integer :: gy integer :: gz integer :: i integer :: iBandFfinal integer :: iBandFinit integer :: iBandIfinal integer :: iBandIinit integer :: ibf integer :: ibi integer :: id integer :: ierr !! Error code returned from MPI integer :: ig integer :: ik integer :: ind2 integer :: ios !! Status returned from I/O commands integer :: iPn integer :: iTypes integer :: j integer :: JMAX integer :: kf integer :: ki integer :: maxL integer :: myid !! ID for each MPI process integer :: n integer :: n1 integer :: n2 integer :: n3 integer :: n4 integer :: nBands integer :: nF integer :: nGf integer :: nGi integer :: nGvsF integer :: nGvsI integer :: nI integer :: nIonsPC integer :: nIonsSD integer :: nKpts integer :: nKptsPC integer :: np integer :: nPP integer :: nProjsPC integer :: nProjsSD integer :: npw integer :: npwMf integer :: npwMi integer :: npwNf integer :: npwNi integer :: nSquareProcs integer :: nSpins integer :: numOfGvecs integer :: numOfPWs integer :: numOfPWsPC integer :: numOfPWsSD integer :: numOfTypes integer :: numOfTypesPC integer :: numOfUsedGvecsPP integer :: numprocs !! Number of processes in the MPI pool ! ! Declare scalar reals real ( kind = dp ) :: eBin real ( kind = dp ) t0 !! Start time for program real ( kind = dp ) tf !! End time for program real ( kind = dp ) :: omega real ( kind = dp ) :: threej ! ! Declare scalar complex numbers complex ( kind = dp ) :: paw complex ( kind = dp ) :: paw2 complex ( kind = dp ) :: pseudo1 complex ( kind = dp ) :: pseudo2 ! ! Define scalar logicals logical :: calculateVfis logical :: coulomb logical :: gamma_only logical :: master logical :: tmes_file_exists ! ! Declare scalar characters character ( len = 300 ) :: elementsPath character ( len = 200 ) :: exportDirSD !! SD output directory from the [[pw_export_for_TME(program)]] program character ( len = 200 ) :: exportDirPC !! PC output directory from the [[pw_export_for_TME(program)]] program character ( len = 300 ) :: input character ( len = 300 ) :: inputPC character ( len = 320 ) :: mkdir !! Command for creating the elements path directory character ( len = 300 ) :: textDum !! Dummy variable to hold unneeded lines from input file character ( len = 200 ) :: VfisOutput !! Output file for ?? ! ! ! Declare matrix/vector integers integer , allocatable :: counts (:) integer , allocatable :: displmnt (:) integer , allocatable :: groundState (:) integer , allocatable :: igvs (:,:,:) integer , allocatable :: iqs (:) integer , allocatable :: nFs (:,:) integer , allocatable :: ngs (:,:) integer , allocatable :: nIs (:,:) integer , allocatable :: nPWsI (:) integer , allocatable :: nPWsF (:) integer , allocatable :: npwsPC (:) integer , allocatable :: npwsSD (:) integer , allocatable :: pwGindPC (:) integer , allocatable :: pwGindSD (:) integer , allocatable :: pwGvecs (:,:) integer , allocatable :: pwGs (:,:) integer , allocatable :: TYPNIPC (:) integer , allocatable :: TYPNISD (:) ! ! Declare matrix/vector reals real ( kind = dp ) at ( 3 , 3 ) real ( kind = dp ) bg ( 3 , 3 ) real ( kind = dp ), allocatable :: absVfi2 (:,:) real ( kind = dp ), allocatable :: DE (:,:) real ( kind = dp ), allocatable :: eigvF (:) real ( kind = dp ), allocatable :: eigvI (:) real ( kind = dp ), allocatable :: gvecs (:,:) real ( kind = dp ), allocatable :: posIonPC (:,:) real ( kind = dp ), allocatable :: posIonSD (:,:) real ( kind = dp ), allocatable :: wk (:) real ( kind = dp ), allocatable :: wkPC (:) real ( kind = dp ), allocatable :: xk (:,:) real ( kind = dp ), allocatable :: xkPC (:,:) ! ! Declare matrix/vector complex numbers complex ( kind = dp ), allocatable :: betaPC (:,:) complex ( kind = dp ), allocatable :: betaSD (:,:) complex ( kind = dp ), allocatable :: cProjBetaPCPsiSD (:,:,:) complex ( kind = dp ), allocatable :: cProjBetaSDPhiPC (:,:,:) complex ( kind = dp ), allocatable :: cProjPC (:,:,:) complex ( kind = dp ), allocatable :: cProjSD (:,:,:) complex ( kind = dp ), allocatable :: paw_id (:,:) complex ( kind = dp ), allocatable :: paw_fi (:,:) complex ( kind = dp ), allocatable :: pawKPC (:,:,:) complex ( kind = dp ), allocatable :: paw_PsiPC (:,:) complex ( kind = dp ), allocatable :: pawPsiPC (:,:) complex ( kind = dp ), allocatable :: pawSDK (:,:,:) complex ( kind = dp ), allocatable :: paw_SDPhi (:,:) complex ( kind = dp ), allocatable :: pawSDPhi (:,:) complex ( kind = dp ), allocatable :: paw_SDKKPC (:,:) complex ( kind = dp ), allocatable :: Ufi (:,:,:) complex ( kind = dp ), allocatable :: wfcPC (:,:) complex ( kind = dp ), allocatable :: wfcSD (:,:) ! ! !  type :: crystal !    integer :: Jmax, maxL, iTypes, nn, nm !    integer :: numOfPWs, nIons, nKpts, nProjs, numOfTypes !    integer :: nBands, nSpins !    integer :: i, j, n1, n2, n3, n4, n, id !    ! !    real(kind = dp) at(3,3), bg(3,3) !    ! !    real(kind = dp) :: omega !    ! !    real(kind = dp), allocatable :: eigvI(:), eigvF(:), posIon(:,:), wk(:), xk(:,:) !    real(kind = dp), allocatable :: DE(:,:), absVfi2(:,:) !    ! !    complex(kind = dp), allocatable :: wfc(:,:), wfcSD(:,:), Ufi(:,:,:) !    complex(kind = dp), allocatable :: cProjPC(:,:,:), cProjSD(:,:,:) !    ! !    integer, allocatable :: TYPNISD(:), TYPNIPC(:), igvs(:,:,:), pwGvecs(:,:), iqs(:), groundState(:) !    integer, allocatable :: npws(:), pwGindI(:), pwGindF(:), pwGs(:,:), nIs(:,:), nFs(:,:), ngs(:,:) !    integer, allocatable :: npwsPC(:) !    real(kind = dp), allocatable :: wkPC(:), xkPC(:,:) ! !  end type crystal ! type :: atom !! Define a new type to represent an atom in the structure. !! Each different type of atom in the structure will be another !! variable with the type `atom`. ! ! Define scalar integers integer :: iRc integer :: numOfAtoms !! Number of atoms of a specific type in the structure integer :: lMax integer :: lmMax integer :: nMax ! ! Define scalar character character ( len = 2 ) :: symbol ! ! Define matrix/vector integer integer , allocatable :: lps (:) ! ! Define matrix/vector reals real ( kind = dp ), allocatable :: bes_J_qr (:,:) real ( kind = dp ), allocatable :: F (:,:) real ( kind = dp ), allocatable :: F1 (:,:,:) real ( kind = dp ), allocatable :: F2 (:,:,:) real ( kind = dp ), allocatable :: r (:) real ( kind = dp ), allocatable :: rab (:) real ( kind = dp ), allocatable :: wae (:,:) real ( kind = dp ), allocatable :: wps (:,:) ! end type atom ! ! Define vectors of atoms TYPE ( atom ), allocatable :: atoms (:) TYPE ( atom ), allocatable :: atomsPC (:) ! type :: vec ! integer :: ind integer , allocatable :: igN (:) integer , allocatable :: igM (:) end type vec ! ! Define vectors of vecs TYPE ( vec ), allocatable :: vecs (:) TYPE ( vec ), allocatable :: newVecs (:) ! ! NAMELIST / TME_Input / exportDirSD , exportDirPC , elementsPath , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput , eBin !! Used to group the variables read in from the .in file ! ! !===================================================================================================== contains ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine readInput () !! Delete any previous output, initialize input variables, !! start a timer, and read in the input files !! !! @todo Change `readInput()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! logical :: file_exists !! Whether or not the output file already exists !! @todo Change `file_exists` to `fileExists` in `readInput()` @endtodo ! call cpu_time ( t0 ) !! * Start a timer ! inquire ( file = output , exist = file_exists ) !! * Check if file output exists, if ( file_exists ) then !! and delete it if it does open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! call initialize () !! * Set default values for input variables ! READ ( 5 , TME_Input , iostat = ios ) !! * Read input from command line (or input file if use `< TME_Input.md`) ! call checkInitialization () !! * Check that all required variables were input and have values that make sense ! !> @todo Figure out what the difference in PC and SD is @endtodo call readInputPC () !! * Read PC inputs call readInputSD () !! * Read SD inputs ! numOfPWs = max ( numOfPWsPC , numOfPWsSD ) !! * Calculate the number of plane waves as the maximum of the number of PC and SD plane waves ! return ! end subroutine readInput ! ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine initialize () !! Set default values for all of the input variables !! that can easily be tested to see if they were changed !! !! @todo Change `initialize()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! exportDirSD = '' exportDirPC = '' elementsPath = '' VfisOutput = '' ! ki = - 1 kf = - 1 nKpts = - 1 ! eBin = - 1.0_dp ! iBandIinit = - 1 iBandIfinal = - 1 iBandFinit = - 1 iBandFfinal = - 1 ! calculateVfis = . false . ! return ! end subroutine initialize ! ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine checkInitialization () !! Check to see if variables from .in file still !! have the values set in [[TMEModule(module):initialize(subroutine)]] !! or if they have values that aren't allowed !! !! <h2>Walkthrough</h2> !! !! @todo Change `checkInitialization()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! logical :: file_exists !! Whether or not the exported directory from [[pw_export_for_TME(program)]] !! exists !> !> @todo Change `file_exists` to `fileExists` in `checkInitialization()` @endtodo logical :: abortExecution ! abortExecution = . false . !! * Set the default value of abort execution so that the program !! will only abort if there is an issue with the inputs ! write ( iostd , '(\" Inputs : \")' ) !! * Write out a header to the output file ! !> * If the SD export directory variable is blank !>    * Output an error message and set `abortExecution` to true !> * Otherwise !>    * Check if the SD export directory exists !>    * If the SD export directory doesn't exist !>       * Output an error message and set `abortExecution` to true if ( trim ( exportDirSD ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"exportDirSD\"\" is not defined!\")' ) write ( iostd , '(\" usage : exportDirSD = ''./Export/''\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! else ! inquire ( file = trim ( exportDirSD ), exist = file_exists ) ! if ( file_exists . eqv . . false . ) then ! write ( iostd , '(\" exportDirSD :\", a, \" does not exist !\")' ) trim ( exportDirSD ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! endif ! write ( iostd , '(\"exportDirSD = ''\", a, \"''\")' ) trim ( exportDirSD ) !! * Output the given SD export directory ! !> * If the PC export directory variable is blank !>    * Output an error message and set `abortExecution` to true !> * Otherwise !>    * Check if the PC export directory exists !>    * If the PC export directory doesn't exist !>       * Output an error message and set `abortExecution` to true if ( trim ( exportDirPC ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"exportDirPC\"\" is not defined!\")' ) write ( iostd , '(\" usage : exportDirPC = ''./Export/''\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! else ! inquire ( file = trim ( exportDirPC ), exist = file_exists ) ! if ( file_exists . eqv . . false . ) then ! write ( iostd , '(\" exportDir :\", a, \" does not exist !\")' ) trim ( exportDirPC ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! endif ! write ( iostd , '(\"exportDirPC = ''\", a, \"''\")' ) trim ( exportDirPC ) !! * Output the given PC export directory ! !> * If the elements path is blank !>    * Output a warning message and set the default value to `./` if ( trim ( elementsPath ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"elementsPath\"\" is not defined!\")' ) write ( iostd , '(\" usage : elementsPath = ''./''\")' ) write ( iostd , '(\" The current directory will be used as elementsPath.\")' ) elementsPath = './' ! endif ! inquire ( file = trim ( elementsPath ), exist = file_exists ) !! * Check if the elements path folder exists already ! !> * If the elements path folder doesn't already exist !>    * Create the directory by writing the `mkdir` command to a string !>    * Then execute the command if ( . not . file_exists ) then ! write ( mkDir , '(\"mkdir -p \", a)' ) trim ( elementsPath ) ! call system ( mkDir ) ! endif ! write ( iostd , '(\"elementsPath = ''\", a, \"''\")' ) trim ( elementsPath ) !! * Output the elements path ! !............................................................................................... !! * If `iBandIinit`, `iBandIfinal`, `iBandFinit`, or `iBandFfinal` is still less than zero !!    * Output an error message and set `abortExecution` to true !! * Then output each of their values ! if ( iBandIinit < 0 ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"iBandIinit\"\" is not defined!\")' ) write ( iostd , '(\" usage : iBandIinit = 10\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"iBandIinit = \", i4)' ) iBandIinit ! if ( iBandIfinal < 0 ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"iBandIfinal\"\" is not defined!\")' ) write ( iostd , '(\" usage : iBandIfinal = 20\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"iBandIfinal = \", i4)' ) iBandIfinal ! if ( iBandFinit < 0 ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"iBandFinit\"\" is not defined!\")' ) write ( iostd , '(\" usage : iBandFinit = 9\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"iBandFinit = \", i4)' ) iBandFinit ! if ( iBandFfinal < 0 ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"iBandFfinal\"\" is not defined!\")' ) write ( iostd , '(\" usage : iBandFfinal = 9\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"iBandFfinal = \", i4)' ) iBandFfinal ! !............................................................................................... ! !> * If `calculateVfis` is true and `iBandFinit` and `iBandFfinal` are not equal !>    * Output an error message and set `abortExecution` to true if ( ( calculateVfis ) . and . ( iBandFinit /= iBandFfinal ) ) then ! write ( iostd , * ) write ( iostd , '(\" Vfis can be calculated only if the final state is one and only one!\")' ) write ( iostd , '(\" ''iBandFInit'' = \", i10)' ) iBandFinit write ( iostd , '(\" ''iBandFfinal'' = \", i10)' ) iBandFfinal write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"calculateVfis = \", l )' ) calculateVfis !! * Output the value of `calculateVfis` ! !> * If the `VfisOutput` file name is blank !>    * Output a warning message and set the default value to `VfisVsE` if ( trim ( VfisOutput ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"VfisOutput\"\" is not defined!\")' ) write ( iostd , '(\" usage : VfisOutput = ''VfisVsE''\")' ) write ( iostd , '(\" The default value ''VfisVsE'' will be used.\")' ) VfisOutput = 'VfisVsE' ! endif ! write ( iostd , '(\"VfisOutput = ''\", a, \"''\")' ) trim ( VfisOutput ) !! * Output the value of `VfisOutput` !> @todo Check if there is any kind of check on `ki` and `kf`. Why was this commented out? @endtodo ! !if ( ki < 0 ) then !  write(iostd, *) !  write(iostd, '(\" Initial k-point index is not defined!\")') !  write(iostd, '(\" Variable : \"\"ki\"\" is not defined!\")') !  write(iostd, '(\" usage : ki = 1\")') !  !write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  !abortExecution = .true. !  write(iostd, '(\" ki = 1 will be used.\")') !  ki = 1 !endif ! !if ( kf < 0 ) then !  write(iostd, *) !  write(iostd, '(\" Final k-point index is not defined!\")') !  write(iostd, '(\" Variable : \"\"kf\"\" is not defined!\")') !  write(iostd, '(\" usage : kf = 1\")') !  !write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  write(iostd, '(\" kf = total number of k-points will be used.\")') !  !abortExecution = .true. !endif ! !if ( ki /= kf ) then !  write(iostd, *) !  write(iostd, '(\" Initial k-point index ''ki'', should be equal to the Final k-point index ''kf'' !\")') !  write(iostd, '(\" Calculation of transition matrix elements with momentum transfer is not implemented!\")') !  write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  abortExecution = .true. !endif ! !> * If the value of `eBin` is still less than zero !>    * Output a warning message and set the default value to 0.01 eV if ( eBin < 0.0_dp ) then ! write ( iostd , '(\" Variable : \"\"eBin\"\" is not defined!\")' ) write ( iostd , '(\" usage : eBin = 0.01\")' ) write ( iostd , '(\" A default value of 0.01 eV will be used !\")' ) eBin = 0.01_dp ! eV ! endif ! write ( iostd , '(\"eBin = \", f8.4, \" (eV)\")' ) eBin !! * Output the value of eBin ! eBin = eBin * evToHartree !! * Convert `eBin` from eV to Hartree ! !> * If `abortExecution` was ever set to true !>    * Output an error message and stop the program if ( abortExecution ) then write ( iostd , '(\" Program stops!\")' ) stop endif ! flush ( iostd ) !! * Make the output file available for other processes ! return ! end subroutine checkInitialization ! ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine readInputPC () !! Read input files in the Export directory created by !! [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! !! @todo Change `readInputPC()` to have arguments so that it is clear that these variables are getting changed @endtodo ! implicit none ! !integer, intent(in) :: id ! integer :: i , j , l , ind , ik , iDum , iType , ni , irc ! real ( kind = dp ) :: t1 , t2 ! character ( len = 300 ) :: textDum ! logical :: file_exists !! Whether or not the `input` file exists in the given !! Export directory !> @todo Change `file_exists` to `fileExists` in `readInputPC()`@endtodo ! call cpu_time ( t1 ) !! * Start a local timer ! !> * Output header to output file write ( iostd , * ) write ( iostd , '(\" Reading perfect crystal inputs.\")' ) write ( iostd , * ) ! inputPC = trim ( trim ( exportDirPC ) // '/input' ) !! * Set the path for the input file from the PC export directory ! inquire ( file = trim ( inputPC ), exist = file_exists ) !! * Check if the input file from the PC export directory exists ! !> * If the input file doesn't exist !>    * Output an error message and end the program if ( file_exists . eqv . . false . ) then ! write ( iostd , '(\" File : \", a, \" , does not exist!\")' ) trim ( inputPC ) write ( iostd , '(\" Please make sure that folder : \", a, \" has been created successfully !\")' ) trim ( exportDirPC ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! !............................................................................................... !> * Open and read the [input](../../pages/inputOutput/input) file !> @todo Add information about these variables to top @endtodo open ( 50 , file = trim ( inputPC ), status = 'old' ) ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nKptsPC !if ( kf < 0 ) kf = nKptsPC ! read ( 50 , '(a)' ) textDum ! allocate ( npwsPC ( nKptsPC ), wkPC ( nKptsPC ), xkPC ( 3 , nKptsPC ) ) ! do ik = 1 , nKptsPC ! read ( 50 , '(3i10,4ES24.15E3)' ) iDum , iDum , npwsPC ( ik ), wkPC ( ik ), xkPC ( 1 : 3 , ik ) ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! numOfGvecs ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfPWsPC ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! fftxMin, fftxMax, fftyMin, fftyMax, fftzMin, fftzMax !read(50, '(6i10)') fftxMin, fftxMax, fftyMin, fftyMax, fftzMin, fftzMax ! read ( 50 , '(a)' ) textDum read ( 50 , * ) read ( 50 , * ) read ( 50 , * ) ! read ( 50 , '(a)' ) textDum read ( 50 , * ) read ( 50 , * ) read ( 50 , * ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nIonsPC ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfTypesPC ! allocate ( posIonPC ( 3 , nIonsPC ), TYPNIPC ( nIonsPC ) ) ! read ( 50 , '(a)' ) textDum ! do ni = 1 , nIonsPC ! read ( 50 , '(i10, 3ES24.15E3)' ) TYPNIPC ( ni ), ( posIonPC ( j , ni ) , j = 1 , 3 ) ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! allocate ( atomsPC ( numOfTypesPC ) ) ! nProjsPC = 0 ! do iType = 1 , numOfTypesPC ! read ( 50 , '(a)' ) textDum read ( 50 , * ) atomsPC ( iType )% symbol ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atomsPC ( iType )% numOfAtoms ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atomsPC ( iType )% lMax ! number of projectors ! allocate ( atomsPC ( iType )% lps ( atomsPC ( iType )% lMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , atomsPC ( iType )% lMax ! read ( 50 , '(2i10)' ) l , ind atomsPC ( iType )% lps ( ind ) = l ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atomsPC ( iType )% lmMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(2i10)' ) atomsPC ( iType )% nMax , atomsPC ( iType )% iRc ! allocate ( atomsPC ( iType )% r ( atomsPC ( iType )% nMax ), atomsPC ( iType )% rab ( atomsPC ( iType )% nMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , atomsPC ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) atomsPC ( iType )% r ( i ), atomsPC ( iType )% rab ( i ) ! enddo ! allocate ( atomsPC ( iType )% wae ( atomsPC ( iType )% nMax , atomsPC ( iType )% lMax ) ) allocate ( atomsPC ( iType )% wps ( atomsPC ( iType )% nMax , atomsPC ( iType )% lMax ) ) ! read ( 50 , '(a)' ) textDum do j = 1 , atomsPC ( iType )% lMax do i = 1 , atomsPC ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) atomsPC ( iType )% wae ( i , j ), atomsPC ( iType )% wps ( i , j ) ! write(iostd, '(2i5, ES24.15E3)') j, i, abs(atomsPC(iType)%wae(i, j)-atomsPC(iType)%wps(i, j)) ! enddo enddo ! allocate ( atomsPC ( iType )% F ( atomsPC ( iType )% iRc , atomsPC ( iType )% lMax ) ) !, atomsPC(iType)%lMax) ) allocate ( atomsPC ( iType )% F1 ( atomsPC ( iType )% iRc , atomsPC ( iType )% lMax , atomsPC ( iType )% lMax ) ) allocate ( atomsPC ( iType )% F2 ( atomsPC ( iType )% iRc , atomsPC ( iType )% lMax , atomsPC ( iType )% lMax ) ) ! atomsPC ( iType )% F = 0.0_dp atomsPC ( iType )% F1 = 0.0_dp atomsPC ( iType )% F2 = 0.0_dp ! !> * Calculate `F`, `F1`, and `F2` using the all-electron and psuedowvefunctions !> @todo Look more into how AE and PS wavefunctions are combined to further understand this @endtodo !> @todo Move this behavior to another subroutine for clarity @endtodo do j = 1 , atomsPC ( iType )% lMax ! irc = atomsPC ( iType )% iRc ! atomsPC ( iType )% F ( 1 : irc , j ) = ( atomsPC ( iType )% wae ( 1 : irc , j ) - atomsPC ( iType )% wps ( 1 : irc , j )) * & atomsPC ( iType )% r ( 1 : irc ) * atomsPC ( iType )% rab ( 1 : irc ) ! do i = 1 , atomsPC ( iType )% lMax atomsPC ( iType )% F1 ( 1 : irc , i , j ) = ( atomsPC ( iType )% wps ( 1 : irc , i ) * atomsPC ( iType )% wae ( 1 : irc , j ) - & & atomsPC ( iType )% wps ( 1 : irc , i ) * atomsPC ( iType )% wps ( 1 : irc , j )) * atomsPC ( iType )% rab ( 1 : irc ) ! atomsPC ( iType )% F2 ( 1 : irc , i , j ) = ( atomsPC ( iType )% wae ( 1 : irc , i ) * atomsPC ( iType )% wae ( 1 : irc , j ) - & atomsPC ( iType )% wae ( 1 : irc , i ) * atomsPC ( iType )% wps ( 1 : irc , j ) - & atomsPC ( iType )% wps ( 1 : irc , i ) * atomsPC ( iType )% wae ( 1 : irc , j ) + & & atomsPC ( iType )% wps ( 1 : irc , i ) * atomsPC ( iType )% wps ( 1 : irc , j )) * atomsPC ( iType )% rab ( 1 : irc ) enddo enddo ! nProjsPC = nProjsPC + atomsPC ( iType )% numOfAtoms * atomsPC ( iType )% lmMax ! !      deallocate ( atomsPC(iType)%wae, atomsPC(iType)%wps ) ! enddo ! !............................................................................................... ! close ( 50 ) !! * Close the input file ! !> * Go through the `lps` values for each projector for each atom !> and find the max to store in `JMAX` JMAX = 0 do iType = 1 , numOfTypesPC ! do i = 1 , atomsPC ( iType )% lMax ! if ( atomsPC ( iType )% lps ( i ) > JMAX ) JMAX = atomsPC ( iType )% lps ( i ) ! enddo ! enddo ! maxL = JMAX JMAX = 2 * JMAX + 1 ! do iType = 1 , numOfTypesPC ! allocate ( atomsPC ( iType )% bes_J_qr ( 0 : JMAX , atomsPC ( iType )% iRc ) ) atomsPC ( iType )% bes_J_qr (:,:) = 0.0_dp ! enddo ! !> * End the local timer and write out the total time to read the inputs !> to the output file call cpu_time ( t2 ) write ( iostd , '(\" Reading input files done in:                \", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) flush ( iostd ) ! return ! end subroutine readInputPC ! ! subroutine distributePWsToProcs ( nOfPWs , nOfBlocks ) ! implicit none ! integer , intent ( in ) :: nOfPWs , nOfBlocks ! integer :: iStep , iModu ! iStep = int ( nOfPWs / nOfBlocks ) iModu = mod ( nOfPWs , nOfBlocks ) ! do i = 0 , nOfBlocks - 1 counts ( i ) = iStep if ( iModu > 0 ) then counts ( i ) = counts ( i ) + 1 iModu = iModu - 1 endif enddo ! displmnt ( 0 ) = 0 do i = 1 , nOfBlocks - 1 displmnt ( i ) = displmnt ( i - 1 ) + counts ( i ) enddo ! return ! end subroutine distributePWsToProcs ! ! subroutine int2str ( integ , string ) ! implicit none integer :: integ character ( len = 300 ) :: string ! if ( integ < 10 ) then write ( string , '(i1)' ) integ else if ( integ < 100 ) then write ( string , '(i2)' ) integ else if ( integ < 1000 ) then write ( string , '(i3)' ) integ else if ( integ < 10000 ) then write ( string , '(i4)' ) integ endif ! string = trim ( string ) ! return ! end subroutine int2str ! ! subroutine finalizeCalculation () ! implicit none ! write ( iostd , '(\"-----------------------------------------------------------------\")' ) ! call cpu_time ( tf ) write ( iostd , '(\" Total time needed:                         \", f10.2, \" secs.\")' ) tf - t0 ! close ( iostd ) ! return ! end subroutine finalizeCalculation ! ! subroutine readPWsSet () ! implicit none ! integer :: ig , iDum , iGx , iGy , iGz ! open ( 72 , file = trim ( exportDirSD ) // \"/mgrid\" ) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( gvecs ( 3 , numOfGvecs ) ) ! gvecs (:,:) = 0.0_dp ! do ig = 1 , numOfGvecs read ( 72 , '(4i10)' ) iDum , iGx , iGy , iGz gvecs ( 1 , ig ) = dble ( iGx ) * bg ( 1 , 1 ) + dble ( iGy ) * bg ( 1 , 2 ) + dble ( iGz ) * bg ( 1 , 3 ) gvecs ( 2 , ig ) = dble ( iGx ) * bg ( 2 , 1 ) + dble ( iGy ) * bg ( 2 , 2 ) + dble ( iGz ) * bg ( 2 , 3 ) gvecs ( 3 , ig ) = dble ( iGx ) * bg ( 3 , 1 ) + dble ( iGy ) * bg ( 3 , 2 ) + dble ( iGz ) * bg ( 3 , 3 ) enddo ! close ( 72 ) ! return ! end subroutine readPWsSet ! ! subroutine readWfcPC ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ib , ig , iDumV ( 3 ) ! complex ( kind = dp ) :: wfc ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! open ( 72 , file = trim ( exportDirPC ) // \"/grid.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGindPC ( npwsPC ( ik )) ) ! do ig = 1 , npwsPC ( ik ) read ( 72 , '(4i10)' ) pwGindPC ( ig ), iDumV ( 1 : 3 ) enddo ! close ( 72 ) ! open ( 72 , file = trim ( exportDirPC ) // \"/wfc.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandIinit - 1 do ig = 1 , npwsPC ( ik ) read ( 72 , * ) enddo enddo ! wfcPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ib = iBandIinit , iBandIfinal do ig = 1 , npwsPC ( ik ) read ( 72 , '(2ES24.15E3)' ) wfc wfcPC ( pwGindPC ( ig ), ib ) = wfc enddo enddo ! close ( 72 ) ! deallocate ( pwGindPC ) ! return ! end subroutine readWfcPC ! ! subroutine projectBetaPCwfcSD ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ig , iDumV ( 3 ) ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! ! Reading PC projectors ! open ( 72 , file = trim ( exportDirPC ) // \"/grid.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGindPC ( npwsPC ( ik )) ) ! do ig = 1 , npwsPC ( ik ) read ( 72 , '(4i10)' ) pwGindPC ( ig ), iDumV ( 1 : 3 ) enddo ! close ( 72 ) ! allocate ( betaPC ( numOfPWs , nProjsPC ) ) ! betaPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! open ( 73 , file = trim ( exportDirPC ) // \"/projectors.\" // trim ( iks )) ! read ( 73 , '(a)' ) textDum read ( 73 , '(2i10)' ) nProjsPC , npw ! do j = 1 , nProjsPC do i = 1 , npw read ( 73 , '(2ES24.15E3)' ) betaPC ( pwGindPC ( i ), j ) enddo enddo ! close ( 73 ) ! deallocate ( pwGindPC ) ! do j = iBandFinit , iBandFfinal do i = 1 , nProjsPC cProjBetaPCPsiSD ( i , j , 1 ) = sum ( conjg ( betaPC (:, i )) * wfcSD (:, j )) !write(65,'(2f17.12)') cProjPC(i,j,1) - cProjBetaPCPsiSD(i,j,1) enddo enddo ! !close(65) ! deallocate ( betaPC ) ! return ! end subroutine projectBetaPCwfcSD ! ! subroutine readWfcSD ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ib , ig , iDumV ( 3 ) ! complex ( kind = dp ) :: wfc ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! open ( 72 , file = trim ( exportDirSD ) // \"/grid.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGindSD ( npwsSD ( ik )) ) ! do ig = 1 , npwsSD ( ik ) read ( 72 , '(4i10)' ) pwGindSD ( ig ), iDumV ( 1 : 3 ) enddo ! close ( 72 ) ! open ( 72 , file = trim ( exportDirSD ) // \"/wfc.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandFinit - 1 do ig = 1 , npwsSD ( ik ) read ( 72 , * ) enddo enddo ! wfcSD (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ib = iBandFinit , iBandFfinal do ig = 1 , npwsSD ( ik ) read ( 72 , '(2ES24.15E3)' ) wfc wfcSD ( pwGindSD ( ig ), ib ) = wfc enddo enddo ! close ( 72 ) ! deallocate ( pwGindSD ) ! return ! end subroutine readWfcSD ! ! subroutine readInputSD () ! implicit none ! integer :: i , j , l , ind , ik , iDum , iType , ni , irc ! real ( kind = dp ) :: t1 , t2 real ( kind = dp ) :: ef ! character ( len = 300 ) :: textDum ! logical :: file_exists ! call cpu_time ( t1 ) ! write ( iostd , * ) write ( iostd , '(\" Reading solid defect inputs.\")' ) write ( iostd , * ) ! input = trim ( trim ( exportDirSD ) // '/input' ) ! inquire ( file = trim ( input ), exist = file_exists ) ! if ( file_exists . eqv . . false . ) then write ( iostd , '(\" File : \", a, \" , does not exist!\")' ) trim ( input ) write ( iostd , '(\" Please make sure that folder : \", a, \" has been created successfully !\")' ) trim ( exportDirSD ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) endif ! open ( 50 , file = trim ( input ), status = 'old' ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(ES24.15E3)' ) omega ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nKpts ! read ( 50 , '(a)' ) textDum ! allocate ( groundState ( nKpts ), npwsSD ( nKpts ), wk ( nKpts ), xk ( 3 , nKpts ) ) ! do ik = 1 , nKpts ! read ( 50 , '(3i10,4ES24.15E3)' ) iDum , groundState ( ik ), npwsSD ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfGvecs ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfPWsSD ! read ( 50 , '(a)' ) textDum read ( 50 , '(6i10)' ) fftxMin , fftxMax , fftyMin , fftyMax , fftzMin , fftzMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(a5, 3ES24.15E3)' ) textDum , at ( 1 : 3 , 1 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , at ( 1 : 3 , 2 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , at ( 1 : 3 , 3 ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(a5, 3ES24.15E3)' ) textDum , bg ( 1 : 3 , 1 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , bg ( 1 : 3 , 2 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , bg ( 1 : 3 , 3 ) ! ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nIonsSD ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfTypes ! allocate ( posIonSD ( 3 , nIonsSD ), TYPNISD ( nIonsSD ) ) ! read ( 50 , '(a)' ) textDum do ni = 1 , nIonsSD read ( 50 , '(i10, 3ES24.15E3)' ) TYPNISD ( ni ), ( posIonSD ( j , ni ), j = 1 , 3 ) enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nBands ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nSpins ! allocate ( atoms ( numOfTypes ) ) ! nProjsSD = 0 do iType = 1 , numOfTypes ! read ( 50 , '(a)' ) textDum read ( 50 , * ) atoms ( iType )% symbol ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atoms ( iType )% numOfAtoms ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atoms ( iType )% lMax ! number of projectors ! allocate ( atoms ( iType )% lps ( atoms ( iType )% lMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , atoms ( iType )% lMax read ( 50 , '(2i10)' ) l , ind atoms ( iType )% lps ( ind ) = l enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atoms ( iType )% lmMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(2i10)' ) atoms ( iType )% nMax , atoms ( iType )% iRc ! allocate ( atoms ( iType )% r ( atoms ( iType )% nMax ), atoms ( iType )% rab ( atoms ( iType )% nMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , atoms ( iType )% nMax read ( 50 , '(2ES24.15E3)' ) atoms ( iType )% r ( i ), atoms ( iType )% rab ( i ) enddo ! allocate ( atoms ( iType )% wae ( atoms ( iType )% nMax , atoms ( iType )% lMax ) ) allocate ( atoms ( iType )% wps ( atoms ( iType )% nMax , atoms ( iType )% lMax ) ) ! read ( 50 , '(a)' ) textDum do j = 1 , atoms ( iType )% lMax do i = 1 , atoms ( iType )% nMax read ( 50 , '(2ES24.15E3)' ) atoms ( iType )% wae ( i , j ), atoms ( iType )% wps ( i , j ) enddo enddo ! allocate ( atoms ( iType )% F ( atoms ( iType )% iRc , atoms ( iType )% lMax ) ) allocate ( atoms ( iType )% F1 ( atoms ( iType )% iRc , atoms ( iType )% lMax , atoms ( iType )% lMax ) ) allocate ( atoms ( iType )% F2 ( atoms ( iType )% iRc , atoms ( iType )% lMax , atoms ( iType )% lMax ) ) ! atoms ( iType )% F = 0.0_dp atoms ( iType )% F1 = 0.0_dp atoms ( iType )% F2 = 0.0_dp ! do j = 1 , atoms ( iType )% lMax ! irc = atoms ( iType )% iRc atoms ( iType )% F ( 1 : irc , j ) = ( atoms ( iType )% wae ( 1 : irc , j ) - atoms ( iType )% wps ( 1 : irc , j )) * atoms ( iType )% r ( 1 : irc ) * & atoms ( iType )% rab ( 1 : irc ) ! do i = 1 , atoms ( iType )% lMax ! atoms ( iType )% F1 ( 1 : irc , i , j ) = ( atoms ( iType )% wae ( 1 : irc , i ) * atoms ( iType )% wps ( 1 : irc , j ) - & atoms ( iType )% wps ( 1 : irc , i ) * atoms ( iType )% wps ( 1 : irc , j )) * atoms ( iType )% rab ( 1 : irc ) ! atoms ( iType )% F2 ( 1 : irc , i , j ) = ( atoms ( iType )% wae ( 1 : irc , i ) * atoms ( iType )% wae ( 1 : irc , j ) - & atoms ( iType )% wae ( 1 : irc , i ) * atoms ( iType )% wps ( 1 : irc , j ) - & atoms ( iType )% wps ( 1 : irc , i ) * atoms ( iType )% wae ( 1 : irc , j ) + & atoms ( iType )% wps ( 1 : irc , i ) * atoms ( iType )% wps ( 1 : irc , j )) * atoms ( iType )% rab ( 1 : irc ) enddo enddo ! nProjsSD = nProjsSD + atoms ( iType )% numOfAtoms * atoms ( iType )% lmMax ! deallocate ( atoms ( iType )% wae , atoms ( iType )% wps ) ! enddo ! JMAX = 0 do iType = 1 , numOfTypes do i = 1 , atoms ( iType )% lMax if ( atoms ( iType )% lps ( i ) > JMAX ) JMAX = atoms ( iType )% lps ( i ) enddo enddo ! maxL = JMAX JMAX = 2 * JMAX + 1 ! do iType = 1 , numOfTypes allocate ( atoms ( iType )% bes_J_qr ( 0 : JMAX , atoms ( iType )% iRc ) ) atoms ( iType )% bes_J_qr (:,:) = 0.0_dp ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(ES24.15E3)' ) ef ! close ( 50 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Reading solid defect inputs done in:                \", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) flush ( iostd ) ! return ! end subroutine readInputSD ! ! subroutine calculatePWsOverlap ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ibi , ibf ! call readWfcPC ( ik ) ! call readWfcSD ( ik ) ! Ufi (:,:, ik ) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal Ufi ( ibf , ibi , ik ) = sum ( conjg ( wfcSD (:, ibf )) * wfcPC (:, ibi )) !if ( ibi == ibf ) write(iostd,'(2i4,3ES24.15E3)') ibf, ibi, Ufi(ibf, ibi, ik), abs(Ufi(ibf, ibi, ik))**2 flush ( iostd ) enddo ! enddo ! return ! end subroutine calculatePWsOverlap ! ! subroutine readProjectionsPC ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: i , j ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! cProjPC (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! ! Reading projections ! open ( 72 , file = trim ( exportDirPC ) // \"/projections.\" // trim ( iks )) ! read ( 72 , * ) ! do j = 1 , nBands ! number of bands do i = 1 , nProjsPC ! number of projections read ( 72 , '(2ES24.15E3)' ) cProjPC ( i , j , 1 ) enddo enddo ! close ( 72 ) ! return ! end subroutine readProjectionsPC ! ! subroutine readProjectionsSD ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: i , j ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! cProjSD (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! ! Reading projections ! open ( 72 , file = trim ( exportDirSD ) // \"/projections.\" // trim ( iks )) ! read ( 72 , * ) ! do j = 1 , nBands ! number of bands do i = 1 , nProjsSD ! number of projections read ( 72 , '(2ES24.15E3)' ) cProjSD ( i , j , 1 ) enddo enddo ! close ( 72 ) ! return ! end subroutine readProjectionsSD ! ! subroutine projectBetaSDwfcPC ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ig , iDumV ( 3 ) ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! ! Reading SD projectors ! open ( 72 , file = trim ( exportDirSD ) // \"/grid.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGindSD ( npwsSD ( ik )) ) ! do ig = 1 , npwsSD ( ik ) read ( 72 , '(4i10)' ) pwGindSD ( ig ), iDumV ( 1 : 3 ) enddo ! close ( 72 ) ! allocate ( betaSD ( numOfPWs , nProjsSD ) ) ! betaSD (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! open ( 73 , file = trim ( exportDirSD ) // \"/projectors.\" // trim ( iks )) ! read ( 73 , '(a)' ) textDum read ( 73 , '(2i10)' ) nProjsSD , npw ! do j = 1 , nProjsSD do i = 1 , npw read ( 73 , '(2ES24.15E3)' ) betaSD ( pwGindSD ( i ), j ) enddo enddo ! close ( 73 ) ! deallocate ( pwGindSD ) ! do j = iBandIinit , iBandIfinal do i = 1 , nProjsSD cProjBetaSDPhiPC ( i , j , 1 ) = sum ( conjg ( betaSD (:, i )) * wfcPC (:, j )) !write(66,'(2f17.12)') cProjSD(i,j,1) - cProjBetaSDPhiPC(i,j,1) enddo enddo ! !close(66) ! deallocate ( betaSD ) ! return ! end subroutine projectBetaSDwfcPC ! ! subroutine pawCorrectionKPC () ! implicit none ! !integer, intent(in) :: ik ! integer :: ibi , ibf , ispin , ig integer :: LL , I , NI , LMBASE , LM integer :: L , M , ind , iT real ( kind = dp ) :: q , qDotR , FI , t1 , t2 ! real ( kind = dp ) :: JL ( 0 : JMAX ), v_in ( 3 ) complex ( kind = dp ) :: Y ( ( JMAX + 1 ) ** 2 ) complex ( kind = dp ) :: VifQ_aug , ATOMIC_CENTER ! ispin = 1 ! call cpu_time ( t1 ) ! pawKPC (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ig = nPWsI ( myid ), nPWsF ( myid ) ! 1, numOfGvecs ! if ( myid == root ) then if ( ( ig == nPWsI ( myid ) + 1000 ) . or . ( mod ( ig , 25000 ) == 0 ) . or . ( ig == nPWsF ( myid )) ) then call cpu_time ( t2 ) write ( iostd , '(\"        Done \", i10, \" of\", i10, \" k-vecs. ETR : \", f10.2, \" secs.\")' ) & ig , nPWsF ( myid ) - nPWsI ( myid ) + 1 , ( t2 - t1 ) * ( nPWsF ( myid ) - nPWsI ( myid ) + 1 - ig ) / ig flush ( iostd ) !call cpu_time(t1) endif endif ! q = sqrt ( sum ( gvecs (:, ig ) * gvecs (:, ig ))) ! v_in (:) = gvecs (:, ig ) if ( abs ( q ) > 1.0e-6_dp ) v_in = v_in / q ! i have to determine v_in = q Y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) CALL ylm ( v_in , JMAX , Y ) ! calculates all the needed spherical harmonics once ! LMBASE = 0 ! do iT = 1 , numOfTypesPC ! DO I = 1 , atomsPC ( iT )% iRc ! nMax - 1 ! JL = 0.0_dp CALL bessel_j ( q * atoms ( iT )% r ( I ), JMAX , JL ) ! returns the spherical bessel at qr point atomsPC ( iT )% bes_J_qr (:, I ) = JL (:) ! ENDDO ! enddo ! do ni = 1 , nIonsPC ! LOOP OVER THE IONS ! qDotR = sum ( gvecs (:, ig ) * posIonPC (:, ni )) ! ATOMIC_CENTER = exp ( - ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! iT = TYPNIPC ( ni ) LM = 0 DO LL = 1 , atomsPC ( iT )% lMax L = atomsPC ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! FI = 0.0_dp ! FI = sum ( atomsPC ( iT )% bes_J_qr ( L ,:) * atomsPC ( iT )% F (:, LL )) ! radial part integration F contains rab ! ind = L * ( L + 1 ) + M + 1 ! index for spherical harmonics VifQ_aug = ATOMIC_CENTER * Y ( ind ) * ( - II ) ** L * FI ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! pawKPC ( ibf , ibi , ig ) = pawKPC ( ibf , ibi , ig ) + VifQ_aug * cProjPC ( LM + LMBASE , ibi , ISPIN ) ! enddo ! enddo ! ENDDO ENDDO LMBASE = LMBASE + atomsPC ( iT )% lmMax ENDDO ! enddo ! !pawKPC(:,:,:) = pawKPC(:,:,:)*4.0_dp*pi/sqrt(omega) ! return ! end subroutine pawCorrectionKPC ! ! subroutine pawCorrectionSDK () ! implicit none ! !integer, intent(in) :: ik ! integer :: ibi , ibf , ispin , ig integer :: LL , I , NI , LMBASE , LM integer :: L , M , ind , iT real ( kind = dp ) :: q , qDotR , FI , t1 , t2 ! real ( kind = dp ) :: JL ( 0 : JMAX ), v_in ( 3 ) complex ( kind = dp ) :: Y ( ( JMAX + 1 ) ** 2 ) complex ( kind = dp ) :: VifQ_aug , ATOMIC_CENTER ! ispin = 1 ! call cpu_time ( t1 ) ! pawSDK (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ig = nPWsI ( myid ), nPWsF ( myid ) ! 1, numOfGvecs ! if ( myid == root ) then if ( ( ig == nPWsI ( myid ) + 1000 ) . or . ( mod ( ig , 25000 ) == 0 ) . or . ( ig == nPWsF ( myid )) ) then call cpu_time ( t2 ) write ( iostd , '(\"        Done \", i10, \" of\", i10, \" k-vecs. ETR : \", f10.2, \" secs.\")' ) & ig , nPWsF ( myid ) - nPWsI ( myid ) + 1 , ( t2 - t1 ) * ( nPWsF ( myid ) - nPWsI ( myid ) + 1 - ig ) / ig flush ( iostd ) call cpu_time ( t1 ) endif endif q = sqrt ( sum ( gvecs (:, ig ) * gvecs (:, ig ))) ! v_in (:) = gvecs (:, ig ) if ( abs ( q ) > 1.0e-6_dp ) v_in = v_in / q ! i have to determine v_in = q Y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) CALL ylm ( v_in , JMAX , Y ) ! calculates all the needed spherical harmonics once ! LMBASE = 0 ! do iT = 1 , numOfTypes ! DO I = 1 , atoms ( iT )% iRc ! nMax - 1 ! JL = 0.0_dp CALL bessel_j ( q * atoms ( iT )% r ( I ), JMAX , JL ) ! returns the spherical bessel at qr point atoms ( iT )% bes_J_qr (:, I ) = JL (:) ! ENDDO enddo ! do ni = 1 , nIonsSD ! LOOP OVER THE IONS ! qDotR = sum ( gvecs (:, ig ) * posIonSD (:, ni )) ! ATOMIC_CENTER = exp ( ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! iT = TYPNISD ( ni ) LM = 0 DO LL = 1 , atoms ( iT )% lMax L = atoms ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! FI = 0.0_dp ! FI = sum ( atoms ( iT )% bes_J_qr ( L ,:) * atoms ( iT )% F (:, LL )) ! radial part integration F contains rab ! ind = L * ( L + 1 ) + M + 1 ! index for spherical harmonics VifQ_aug = ATOMIC_CENTER * conjg ( Y ( ind )) * ( II ) ** L * FI ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! pawSDK ( ibf , ibi , ig ) = pawSDK ( ibf , ibi , ig ) + VifQ_aug * conjg ( cProjSD ( LM + LMBASE , ibf , ISPIN )) ! enddo ! enddo ! ENDDO ENDDO LMBASE = LMBASE + atoms ( iT )% lmMax ENDDO ! enddo ! !pawSDK(:,:,:) = pawSDK(:,:,:)*4.0_dp*pi/sqrt(omega) ! return ! end subroutine pawCorrectionSDK ! ! subroutine pawCorrectionPsiPC () ! ! calculates the augmentation part of the transition matrix element ! implicit none integer :: ibi , ibf , niPC , ispin integer :: LL , LLP , LMBASE , LM , LMP integer :: L , M , LP , MP , iT real ( kind = dp ) :: atomicOverlap ! complex ( kind = dp ) :: cProjIe , cProjFe ! ispin = 1 ! paw_PsiPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! LMBASE = 0 ! do niPC = 1 , nIonsPC ! LOOP OVER THE IONS ! iT = TYPNIPC ( niPC ) LM = 0 DO LL = 1 , atomsPC ( iT )% lMax L = atomsPC ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! LMP = 0 DO LLP = 1 , atomsPC ( iT )% lMax LP = atomsPC ( iT )% LPS ( LLP ) DO MP = - LP , LP LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp if ( ( L == LP ). and .( M == MP ) ) then atomicOverlap = sum ( atomsPC ( iT )% F1 (:, LL , LLP )) ! do ibi = iBandIinit , iBandIfinal cProjIe = cProjPC ( LMP + LMBASE , ibi , ISPIN ) ! do ibf = iBandFinit , iBandFfinal cProjFe = conjg ( cProjBetaPCPsiSD ( LM + LMBASE , ibf , ISPIN )) ! paw_PsiPC ( ibf , ibi ) = paw_PsiPC ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe !write(iostd,*) LL, LLP, L, M, atomicOverlap flush ( iostd ) ! enddo ! enddo ! endif ! ENDDO ENDDO ENDDO ENDDO LMBASE = LMBASE + atomsPC ( iT )% lmMax ENDDO ! return ! end subroutine pawCorrectionPsiPC ! ! subroutine pawCorrectionSDPhi () ! ! calculates the augmentation part of the transition matrix element ! implicit none integer :: ibi , ibf , ni , ispin integer :: LL , LLP , LMBASE , LM , LMP integer :: L , M , LP , MP , iT real ( kind = dp ) :: atomicOverlap ! complex ( kind = dp ) :: cProjIe , cProjFe ! ispin = 1 ! paw_SDPhi (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! LMBASE = 0 ! do ni = 1 , nIonsSD ! LOOP OVER THE IONS ! iT = TYPNISD ( ni ) LM = 0 DO LL = 1 , atoms ( iT )% lMax L = atoms ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! LMP = 0 DO LLP = 1 , atoms ( iT )% lMax LP = atoms ( iT )% LPS ( LLP ) DO MP = - LP , LP LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp if ( ( L == LP ). and .( M == MP ) ) then atomicOverlap = sum ( atoms ( iT )% F1 (:, LL , LLP )) ! do ibi = iBandIinit , iBandIfinal cProjIe = cProjBetaSDPhiPC ( LMP + LMBASE , ibi , ISPIN ) ! do ibf = iBandFinit , iBandFfinal cProjFe = conjg ( cProjSD ( LM + LMBASE , ibf , ISPIN )) ! paw_SDPhi ( ibf , ibi ) = paw_SDPhi ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe ! enddo ! enddo ! endif ! ENDDO ENDDO ENDDO ENDDO LMBASE = LMBASE + atoms ( iT )% lmMax ENDDO ! return ! end subroutine pawCorrectionSDPhi ! ! subroutine pawCorrection () ! ! calculates the augmentation part of the transition matrix element ! implicit none integer :: ibi , ibf , niPC , ispin integer :: LL , LLP , LMBASE , LM , LMP integer :: L , M , LP , MP , iT real ( kind = dp ) :: atomicOverlap ! !real(kind = dp), allocatable :: Qij(:,:) ! complex ( kind = dp ) :: cProjIe , cProjFe ! ispin = 1 ! !open(52, file=trim(exportDirPC)//\"/Qij\") !read(52,*) !allocate ( Qij (8,8) ) !do LL = 1, 8 !  do LLP = 1, 8 !    read(52,'(3i3,ES24.15E3)') LMBASE, LMBASE, LMBASE, Qij(LL, LLP) !  enddo !enddo !close(52) ! paw_fi (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! LMBASE = 0 ! do niPC = 1 , nIonsPC ! LOOP OVER THE IONS ! iT = TYPNIPC ( niPC ) LM = 0 DO LL = 1 , atomsPC ( iT )% lMax L = atomsPC ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! LMP = 0 DO LLP = 1 , atomsPC ( iT )% lMax LP = atomsPC ( iT )% LPS ( LLP ) DO MP = - LP , LP LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp if ( ( L == LP ). and .( M == MP ) ) atomicOverlap = sum ( atomsPC ( iT )% F2 (:, LL , LLP )) ! do ibi = iBandIinit , iBandIfinal cProjIe = cProjPC ( LMP + LMBASE , ibi , ISPIN ) ! do ibf = iBandFinit , iBandFfinal cProjFe = conjg ( cProjPC ( LM + LMBASE , ibf , ISPIN )) ! paw_fi ( ibf , ibi ) = paw_fi ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe ! enddo ! enddo ! ENDDO ENDDO ENDDO ENDDO LMBASE = LMBASE + atomsPC ( iT )% lmMax ENDDO ! return ! end subroutine pawCorrection ! ! subroutine readEigenvalues ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ib ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! open ( 72 , file = trim ( exportDirSD ) // \"/eigenvalues.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandIinit - 1 read ( 72 , * ) enddo ! do ib = iBandIinit , iBandIfinal read ( 72 , '(ES24.15E3)' ) eigvI ( ib ) enddo ! close ( 72 ) ! open ( 72 , file = trim ( exportDirSD ) // \"/eigenvalues.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandFinit - 1 read ( 72 , * ) enddo ! do ib = iBandFinit , iBandFfinal read ( 72 , '(ES24.15E3)' ) eigvF ( ib ) enddo ! close ( 72 ) ! return ! end subroutine readEigenvalues ! ! subroutine calculateVfiElements () ! implicit none ! integer :: ik , ib , nOfEnergies , iE ! real ( kind = dp ) :: eMin , eMax , E , av , sd , x , EiMinusEf , A , DHifMin ! real ( kind = dp ), allocatable :: sumWk (:), sAbsVfiOfE2 (:), absVfiOfE2 (:) integer , allocatable :: nKsInEbin (:) ! character ( len = 300 ) :: text ! allocate ( DE ( iBandIinit : iBandIfinal , nKptsPC ), absVfi2 ( iBandIinit : iBandIfinal , nKptsPC ) ) ! DE (:,:) = 0.0_dp absVfi2 (:,:) = 0.0_dp ! do ik = 1 , nKptsPC ! eigvI (:) = 0.0_dp eigvF (:) = 0.0_dp ! call readEigenvalues ( ik ) ! do ib = iBandIinit , iBandIfinal ! EiMinusEf = eigvI ( ib ) - eigvF ( iBandFinit ) absVfi2 ( ib , ik ) = EiMinusEf ** 2 * ( abs ( Ufi ( iBandFinit , ib , ik )) ** 2 - abs ( Ufi ( iBandFinit , ib , ik )) ** 4 ) ! DE ( ib , ik ) = sqrt ( EiMinusEf ** 2 - 4.0_dp * absVfi2 ( ib , ik )) ! enddo ! enddo ! eMin = minval ( DE (:,:) ) eMax = maxval ( DE (:,:) ) ! nOfEnergies = int (( eMax - eMin ) / eBin ) + 1 ! allocate ( absVfiOfE2 ( 0 : nOfEnergies ), nKsInEbin ( 0 : nOfEnergies ), sumWk ( 0 : nOfEnergies ) ) ! absVfiOfE2 (:) = 0.0_dp nKsInEbin (:) = 0 sumWk (:) = 0.0_dp ! do ik = 1 , nKptsPC ! do ib = iBandIinit , iBandIfinal ! if ( abs ( eMin - DE ( ib , ik )) < 1.0e-3_dp ) DHifMin = absVfi2 ( ib , ik ) iE = int (( DE ( ib , ik ) - eMin ) / eBin ) if ( absVfi2 ( ib , ik ) > 0.0_dp ) then absVfiOfE2 ( iE ) = absVfiOfE2 ( iE ) + wkPC ( ik ) * absVfi2 ( ib , ik ) sumWk ( iE ) = sumWk ( iE ) + wkPC ( ik ) nKsInEbin ( iE ) = nKsInEbin ( iE ) + 1 else write ( iostd , * ) 'lalala' , absVfi2 ( ib , ik ) endif ! enddo ! enddo ! allocate ( sAbsVfiOfE2 ( 0 : nOfEnergies ) ) ! sAbsVfiOfE2 = 0.0_dp ! open ( 11 , file = trim ( VfisOutput ) // 'ofKpt' , status = 'unknown' ) ! write ( 11 , '(\"# |<f|V|i>|&#94;2 versus energy for all the k-points.\")' ) write ( text , '(\"# Energy (eV) shifted by half eBin, |<f|V|i>|&#94;2 (Hartree)&#94;2,\")' ) write ( 11 , '(a, \" k-point index. Format : ''(2ES24.15E3,i10)''\")' ) trim ( text ) ! do ik = 1 , nKptsPC ! do ib = iBandIinit , iBandIfinal ! iE = int (( DE ( ib , ik ) - eMin ) / eBin ) av = absVfiOfE2 ( iE ) / sumWk ( iE ) x = absVfi2 ( ib , ik ) write ( 11 , '(2ES24.15E3,i10)' ) ( eMin + ( iE + 0.5_dp ) * eBin ) * HartreeToEv , x , ik write ( 12 , '(2ES24.15E3,i10)' ) DE ( ib , ik ) * HartreeToEv , absVfi2 ( ib , ik ), ik !write(11, '(2ES24.15E3,i10)') (eMin + iE*eBin + eBin/2.0_dp), x, ik sAbsVfiOfE2 ( iE ) = sAbsVfiOfE2 ( iE ) + wkPC ( ik ) * ( x - av ) ** 2 / sumWk ( iE ) ! enddo ! enddo ! close ( 11 ) ! open ( 63 , file = trim ( VfisOutput ), status = 'unknown' ) ! write ( 63 , '(\"# Averaged |<f|V|i>|&#94;2 over K-points versus energy.\")' ) write ( 63 , '(\"#                 Cell volume : \", ES24.15E3, \" (a.u.)&#94;3,   Format : ''(ES24.15E3)''\")' ) omega write ( 63 , '(\"#   Minimun transition energy : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eMin write ( 63 , '(\"# |DHif|&#94;2 at minimum Tr. En. : \", ES24.15E3, \" (Hartree&#94;2),Format : ''(ES24.15E3)''\")' ) DHifMin write ( 63 , '(\"#                  Energy bin : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eBin write ( text , '(\"# Energy (Hartree), averaged |<f|V|i>|&#94;2 over K-points (Hartree)&#94;2,\")' ) write ( 63 , '(a, \" standard deviation (Hartree)&#94;2. Format : ''(3ES24.15E3)''\")' ) trim ( text ) ! do iE = 0 , nOfEnergies E = iE * eBin av = 0.0_dp sd = 0.0_dp if ( nKsInEbin ( iE ) > 0 ) then av = absVfiOfE2 ( iE ) / sumWk ( iE ) sd = sqrt ( sAbsVfiOfE2 ( iE )) endif write ( 63 , '(3ES24.15E3)' ) eMin + E , av , sd enddo ! close ( 63 ) ! return ! end subroutine calculateVfiElements ! ! subroutine checkIfCalculated ( ik , tmes_file_exists ) ! implicit none ! integer , intent ( in ) :: ik logical , intent ( out ) :: tmes_file_exists ! character ( len = 300 ) :: Uelements ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! inquire ( file = trim ( elementsPath ) // trim ( Uelements ), exist = tmes_file_exists ) ! return ! end subroutine checkIfCalculated ! ! subroutine readUfis ( ik ) ! implicit none ! integer , intent ( in ) :: ik ! integer :: ibi , ibf , totalNumberOfElements , iDum , i real ( kind = dp ) :: rDum , t1 , t2 complex ( kind = dp ) :: cUfi ! character ( len = 300 ) :: Uelements ! call cpu_time ( t1 ) write ( iostd , '(\" Reading Ufi(:,:) of k-point: \", i4)' ) ik ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) ! read ( 17 , * ) read ( 17 , * ) read ( 17 , '(5i10)' ) totalNumberOfElements , iDum , iDum , iDum , iDum read ( 17 , * ) ! do i = 1 , totalNumberOfElements ! read ( 17 , 1001 ) ibf , ibi , rDum , cUfi , rDum Ufi ( ibf , ibi , ik ) = cUfi ! enddo ! close ( 17 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Reading Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! return ! end subroutine readUfis ! ! subroutine writeResults ( ik ) ! implicit none ! integer , intent ( in ) :: ik ! integer :: ibi , ibf , totalNumberOfElements real ( kind = dp ) :: t1 , t2 ! character ( len = 300 ) :: text , Uelements ! call cpu_time ( t1 ) ! call readEigenvalues ( ik ) ! write ( iostd , '(\" Writing Ufi(:,:).\")' ) ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) ! write ( 17 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(a51, ES24.15E3)'' \", ES24.15E3)' ) omega ! text = \"# Total number of <f|U|i> elements, Initial States (bandI, bandF), Final States (bandI, bandF)\" write ( 17 , '(a, \" Format : ''(5i10)''\")' ) trim ( text ) ! totalNumberOfElements = ( iBandIfinal - iBandIinit + 1 ) * ( iBandFfinal - iBandFinit + 1 ) write ( 17 , '(5i10)' ) totalNumberOfElements , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! write ( 17 , '(\"# Final Band, Initial Band, Delta energy, Complex <f|U|i>, |<f|U|i>|&#94;2 Format : ''(2i10,4ES24.15E3)''\")' ) ! do ibf = iBandFinit , iBandFfinal do ibi = iBandIinit , iBandIfinal ! write ( 17 , 1001 ) ibf , ibi , eigvI ( ibi ) - eigvF ( ibf ), Ufi ( ibf , ibi , ik ), abs ( Ufi ( ibf , ibi , ik )) ** 2 ! enddo enddo ! close ( 17 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Writing Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! return ! end subroutine writeResults ! ! subroutine bessel_j ( x , lmax , jl ) ! ! x is the argument of j, jl(0:lmax) is the output values. implicit none integer , intent ( in ) :: lmax real ( kind = dp ), intent ( in ) :: x real ( kind = dp ), intent ( out ) :: jl ( 0 : lmax ) integer :: l ! if ( x <= 0.0_dp ) then jl = 0.0_dp jl ( 0 ) = 1.0_dp return end if ! jl ( 0 ) = sin ( x ) / x if ( lmax <= 0 ) return jl ( 1 ) = ( jl ( 0 ) - cos ( x )) / x if ( lmax == 1 ) return ! do l = 2 , lmax jl ( l ) = dble ( 2 * l - 1 ) * jl ( l - 1 ) / x - jl ( l - 2 ) enddo ! return ! end subroutine bessel_j ! ! ! subroutine ylm ( v_in , lmax , y ) ! ! lmax   : spherical harmonics are calculated for l = 0 to lmax ! v      : vector, argument of the spherical harmonics (we calculate ! Ylm(v/norm(v)) ! y      : array containing Ylm(v) for several l,m ! ! !DESCRIPTION: !   1.  PURPOSE !        The spherical harmonics (Condon and Shortley convention) !          Y(0,0),Y(1,-1),Y(1,0),Y(1,1),Y(2,-2) ... Y(LMAX,LMAX) !        for vector V (given in Cartesian coordinates) !        are calculated. In the Condon Shortley convention the !        spherical harmonics are defined as !         Y(l,m) = (-1)&#94;m \\sqrt{\\frac{1}{\\pi}} P_{lm}(\\cos{\\theta}) !        \\rm !        e&#94;{\\rm i m \\phi}  ! !        where  $P_{lm}(\\cos{\\theta})$ is the normalized Associated !        Legendre ! !        function. Thus, ! !                       Y(l,-m) = (-1)&#94;m Y&#94;*(l,m)  ! !   2.  USAGE !        DOUBLE PRECISION V(3), Y(5*5) !        V(1) = ... !        V(2) = ... !        V(3) = ... !        CALL YLM(V,4,Y) ! !       ARGUMENT-DESCRIPTION !          V      - DOUBLE PRECISION vector, dimension 3        (input) !                   Must be given in Cartesian coordinates. !                   Conversion of V to polar coordinates gives the !                   angles Theta and Phi necessary for the calculation !                   of the spherical harmonics. !          LMAX   - INTEGER value                               (input) !                   upper bound of L for which spherical harmonics !                   will be calculated !                   constraint: !                      LMAX >= 0 !          Y      - COMPLEX*16 array, dimension (LMAX+1)**2    (output) !                   contains the calculated spherical harmonics !                   Y(1)                   for L .EQ. 0 (M = 0) !                   Y(2), ..., Y(4)        for L .EQ. 1 (M = -1, 0, 1) !                   ... !                   Y(LMAX*LMAX+1), ..., Y((LMAX+1)*(LMAX+1)) !                                          for L .EQ. LMAX !                                              (M = -L,...,L) !                   constraint: !                      Dimension of Y .GE. (LMAX+1)**2 (not checked) !        USED SUBROUTINES (DIRECTLY CALLED) !           none ! !        INDIRECTLY CALLED SUBROUTINES !           none ! !        UTILITY-SUBROUTINES (USE BEFOREHAND OR AFTERWARDS) !           none ! !        INPUT/OUTPUT (READ/WRITE) !           none ! !        MACHINENDEPENDENT PROGRAMPARTS !           Type COMPLEX*16 is used which does not conform to the !           FORTRAN 77 standard. !           Also the non-standard type conversion function DCMPLX() !           is used which combines two double precision values into !           one double complex value. ! !   3.     METHOD !           The basic algorithm used to calculate the spherical !           harmonics for vector V is as follows: ! !           Y(0,0) !           Y(1,0) !           Y(1,1) !           Y(1,-1) = -Y(1,1) !           DO L = 2, LMAX !              Y(L,L)   = f(Y(L-1,L-1)) ... Formula 1 !              Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 !              DO M = L-2, 0, -1 !                 Y(L,M) = f(Y(L-1,M),Y(L-2,M)) ... Formula 2 !                 Y(L,-M)= (-1)**M*Y(L,M) !              ENDDO !           ENDDO ! !           In the following the necessary recursion formulas and !           starting values are given: ! !        Start: !%                        +------+ !%                        |   1 !%           Y(0,0) =  -+ | ----- !%                       \\| 4(Pi) !% !%                                   +------+ !%                                   |   3 !%           Y(1,0) =  cos(Theta) -+ | ----- !%                                  \\| 4(Pi) !% !%                                     +------+ !%                                     |   3    i(Phi) !%           Y(1,1) =  - sin(Theta) -+ | ----- e !%                                    \\| 8(Pi) !% !%        Formula 1: !% !%           Y(l,l) = !%                           +--------+ !%                           | (2l+1)   i(Phi) !%            -sin(Theta) -+ | ------  e       Y(l-1,l-1) !%                          \\|   2l !% !%        Formula 2: !%                                  +---------------+ !%                                  |  (2l-1)(2l+1) !%           Y(l,m) = cos(Theta) -+ | -------------- Y(l-1,m)  - !%                                 \\|   (l-m)(l+m) !% !%                                    +--------------------+ !%                                    |(l-1+m)(l-1-m)(2l+1) !%                              -  -+ |-------------------- Y(l-2,m) !%                                   \\|  (2l-3)(l-m)(l+m) !% !%        Formula 3: (not used in the algorithm because of the division !%                    by sin(Theta) which may be zero) !% !%                                    +--------------+ !%                      cos(Theta)    |  4(m+1)(m+1)   -i(Phi) !%           Y(l,m) = - ---------- -+ | ------------  e       Y(l,m+1) - !%                      sin(Theta)   \\| (l+m+1)(l-m) !% !%                                    +--------------+ !%                                    |(l-m-1)(l+m+2)  -2i(Phi) !%                              -  -+ |-------------- e        Y(l,m+2) !%                                   \\| (l-m)(l+m+1) !% !% ! !REVISION HISTORY: !   26. April 1994                                   Version 1.2 !   Taken 8 1 98 from SRC_lapw2 to SRC_telnes !   Updated November 2004 (Kevin Jorissen) !   cosmetics March 2005 (Kevin Jorissen) ! implicit none ! !   In/Output : ! integer , intent ( in ) :: LMAX real ( kind = dp ), intent ( in ) :: V_in ( 3 ) complex ( kind = dp ), intent ( out ) :: Y ( * ) !   Local variables : real ( kind = dp ), parameter :: pi = 3.1415926535897932384626433_dp ! INTEGER :: I2L , I4L2 , INDEX , INDEX2 , L , M , MSIGN real ( kind = dp ) :: A , B , C , AB , ABC , ABMAX , ABCMAX , V ( 3 ) real ( kind = dp ) :: D4LL1C , D2L13 real ( kind = dp ) :: COSTH , SINTH , COSPH , SINPH real ( kind = dp ) :: TEMP1 , TEMP2 , TEMP3 real ( kind = dp ) :: YLLR , YLL1R , YL1L1R , YLMR real ( kind = dp ) :: YLLI , YLL1I , YL1L1I , YLMI ! ! Y(0,0) ! do INDEX = 1 , 3 V ( INDEX ) = dble ( V_in ( INDEX )) enddo YLLR = 1.0_dp / sqrt ( 4.0_dp * PI ) YLLI = 0.0_dp Y ( 1 ) = CMPLX ( YLLR , YLLI , kind = dp ) ! ! continue only if spherical harmonics for (L .GT. 0) are desired ! IF ( LMAX . LE . 0 ) GOTO 999 ! ! calculate sin(Phi), cos(Phi), sin(Theta), cos(Theta) ! Theta, Phi ... polar angles of vector V ! ABMAX = MAX ( ABS ( V ( 1 )), ABS ( V ( 2 ))) IF ( ABMAX . GT . 0.0_dp ) THEN A = V ( 1 ) / ABMAX B = V ( 2 ) / ABMAX AB = SQRT ( A * A + B * B ) COSPH = A / AB SINPH = B / AB ELSE COSPH = 1.0_dp SINPH = 0.0_dp ENDIF ABCMAX = MAX ( ABMAX , ABS ( V ( 3 ))) IF ( ABCMAX . GT . dble ( 0 )) THEN A = V ( 1 ) / ABCMAX B = V ( 2 ) / ABCMAX C = V ( 3 ) / ABCMAX AB = A * A + B * B ABC = SQRT ( AB + C * C ) COSTH = C / ABC SINTH = SQRT ( AB ) / ABC ELSE COSTH = 1.0_dp SINTH = 0.0_dp ENDIF ! ! Y(1,0) ! Y ( 3 ) = CMPLX ( sqrt ( 3.0_dp ) * YLLR * COSTH , 0.0_dp , kind = dp ) ! ! Y(1,1) ( = -DCONJG(Y(1,-1))) ! TEMP1 = - SQRT ( 1.5_dp ) * YLLR * SINTH Y ( 4 ) = CMPLX ( TEMP1 * COSPH , TEMP1 * SINPH , kind = dp ) Y ( 2 ) = - CONJG ( Y ( 4 )) ! DO L = 2 , LMAX INDEX = L * L + 1 INDEX2 = INDEX + 2 * L MSIGN = 1 - 2 * MOD ( L , 2 ) ! ! YLL = Y(L,L) = f(Y(L-1,L-1)) ... Formula 1 ! YL1L1R = DBLE ( Y ( INDEX - 1 )) YL1L1I = DIMAG ( Y ( INDEX - 1 )) TEMP1 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L )) * SINTH YLLR = TEMP1 * ( COSPH * YL1L1R - SINPH * YL1L1I ) YLLI = TEMP1 * ( COSPH * YL1L1I + SINPH * YL1L1R ) Y ( INDEX2 ) = CMPLX ( YLLR , YLLI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! ! YLL1 = Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 ! (the coefficient for Y(L-2,L-1) in Formula 2 is zero) ! TEMP2 = SQRT ( DBLE ( 2 * L + 1 )) * COSTH YLL1R = TEMP2 * YL1L1R YLL1I = TEMP2 * YL1L1I Y ( INDEX2 ) = CMPLX ( YLL1R , YLL1I , kind = dp ) Y ( INDEX ) = - cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = -dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! I4L2 = INDEX2 - 4 * L + 2 I2L = INDEX2 - 2 * L D4LL1C = COSTH * SQRT ( DBLE ( 4 * L * L - 1 )) D2L13 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L - 3 )) ! DO M = L - 2 , 0 , - 1 ! ! YLM = Y(L,M) = f(Y(L-2,M),Y(L-1,M)) ... Formula 2 ! TEMP1 = 1.0_dp / SQRT ( DBLE (( L + M ) * ( L - M ))) TEMP2 = D4LL1C * TEMP1 TEMP3 = D2L13 * SQRT ( DBLE (( L + M - 1 ) * ( L - M - 1 ))) * TEMP1 YLMR = TEMP2 * DBLE ( Y ( I2L )) + TEMP3 * DBLE ( Y ( I4L2 )) YLMI = TEMP2 * DIMAG ( Y ( I2L )) + TEMP3 * DIMAG ( Y ( I4L2 )) Y ( INDEX2 ) = CMPLX ( YLMR , YLMI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) ! MSIGN = - MSIGN INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 I4L2 = I4L2 - 1 I2L = I2L - 1 ENDDO ENDDO ! 999 RETURN END subroutine ylm ! ! end module TMEModule","tags":"","loc":"sourcefile/tme_module_v28.f90.html","title":"TME_Module_v28.f90 – Carrier Cross Sections"},{"text":"Contents Programs MjME Source Code Mj_Main.f90 Source Code program MjME ! use MjModule ! implicit none ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call displaceAtoms () ! if ( readQEInput ) then call exportQEInput () else call writeNewAtomicPositions () endif ! end program MjME","tags":"","loc":"sourcefile/mj_main.f90.html","title":"Mj_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules MjModule Source Code Mj_Module_v1.f90 Source Code module MjModule ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: iostd = 16 , un = 3 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: THzToHartree = 1.0_dp / 657 9.683920729_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer :: nAtoms , nOfqPoints , nModes ! integer :: ios ! real ( kind = dp ) :: ti , tf , t1 , t2 real ( kind = dp ) :: temperature , kT ! integer , allocatable :: s2L (:) ! real ( kind = dp ), allocatable :: atomD (:,:), atomM (:), phonQ (:,:), phonF (:), genCoord (:) real ( kind = dp ), allocatable :: atomPosition (:,:), newAtomicPosition (:,:) real ( kind = dp ), allocatable :: wby2kT (:), phonD (:,:,:,:), x (:), Sj (:), coth (:), besOrderNofModeM (:,:) ! real ( kind = dp ) :: maxDisplacement ! integer :: modeI , modeF , qPoint ! character ( len = 2 ), allocatable :: elements (:) character ( len = 6 ), parameter :: output = 'status' character ( len = 256 ) :: phononsInput , equilibriumAtomicPositions , newAtomicPositions , QEInput ! logical :: file_exists , readQEInput ! namelist / MjInput / QEInput , phononsInput , temperature , equilibriumAtomicPositions , modeI , modeF , qPoint , maxDisplacement ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if file output exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , MjInput , iostat = ios ) ! call checkAndUpdateInput () ! call readPhonons () ! call readAtomicPositions () ! return ! end subroutine readInputs ! ! subroutine initialize () ! implicit none ! QEInput = '' phononsInput = '' equilibriumAtomicPositions = '' temperature = - 1.0_dp maxDisplacement = - 1.0_dp modeI = - 1 modeF = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () ! implicit none ! logical :: abortExecution = . false . ! write ( iostd , * ) ! if ( equilibriumAtomicPositions == '' ) then write ( iostd , '(\" equilibriumAtomicPositions is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Equilibrium Atomic Positions input : \", a)' ) trim ( equilibriumAtomicPositions ) endif ! if ( phononsInput == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( PhononsInput ) endif ! if ( QEInput == '' ) then write ( iostd , '(\" QEInput is not defined!\")' ) readQEInput = . false . else readQEInput = . true . write ( iostd , '(\" Quantum Espresso input : \", a)' ) trim ( QEInput ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Temperature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324d-5 * eVToHartree endif ! if ( modeI < 0 ) then write ( iostd , '(\" Variable modeI has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Initial mode : \", i5)' ) modeI endif ! if ( modeF < 0 ) then write ( iostd , '(\" Variable modeF has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Final mode : \", i5)' ) modeF endif ! if ( modeF < modeI ) then write ( iostd , '(\" Final mode is set smaller than initial one!\")' ) abortExecution = . true . endif ! if ( maxDisplacement < 0 ) then write ( iostd , '(\" Variable maxDisplacement has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum atomic displacement in each direction : \", f15.10)' ) maxDisplacement endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! return ! end subroutine checkAndUpdateInput ! ! subroutine readPhonons () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! open ( 1 , file = trim ( phononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms ! write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints flush ( iostd ) ! nModes = 3 * nAtoms - 3 ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhonons ! ! subroutine readAtomicPositions () ! implicit none ! integer :: iAtom ! open ( 1 , file = trim ( equilibriumAtomicPositions ), status = \"old\" ) ! allocate ( elements ( nAtoms ), atomPosition ( 3 , nAtoms ) ) ! atomPosition (:,:) = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) elements ( iAtom ), atomPosition ( 1 , iAtom ), atomPosition ( 2 , iAtom ), atomPosition ( 3 , iAtom ) enddo ! close ( 1 ) ! return ! end subroutine readAtomicPositions ! ! subroutine computeGeneralizedDisplacements () ! implicit none ! integer :: iq , iMode , iAtom ! allocate ( genCoord ( nModes ) ) ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) ! enddo ! enddo ! enddo ! deallocate ( atomM , atomD ) ! return ! end subroutine computeGeneralizedDisplacements ! ! subroutine computeVariables () ! implicit none ! integer :: i , j , iMode , nm , nb ! real ( kind = dp ), allocatable :: bi (:), di (:), bk (:), dk (:) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) ! x = 0.0_dp Sj = 0.0_dp coth = 0.0_dp wby2kT = 0.0_dp ! Sj (:) = 0.5_dp * phonF (:) * genCoord (:) * genCoord (:) wby2kT (:) = phonF (:) / ( 2.0_dp * kT ) coth (:) = cosh ( wby2kT (:)) / sinh ( wby2kT (:)) x (:) = Sj (:) / sinh ( wby2kT (:)) ! allocate ( s2L ( nModes ) ) s2L (:) = 0 ! do iMode = 1 , nModes s2L ( iMode ) = iMode enddo ! call arrangeLargerToSmaller () ! open ( 11 , file = 'modes' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2,  Sj/sinh(wby2kT)\")' ) ! do iMode = 1 , nModes ! write ( 11 , '(i4,1x,4E20.10E3)' ) s2L ( iMode ), phonF ( s2L ( iMode )) * 1.0e3_dp * HartreeToEv , & genCoord ( s2L ( iMode )), genCoord ( s2L ( iMode )) ** 2 , x ( s2L ( iMode )) ! enddo ! close ( 11 ) ! deallocate ( genCoord ) ! nb = modeF ! allocate ( besOrderNofModeM ( 0 : nb + 1 , nModes ) ) allocate ( bi ( 0 : nb + 1 ), di ( 0 : nb + 1 ) ) allocate ( bk ( 0 : nb + 1 ), dk ( 0 : nb + 1 ) ) ! do j = 1 , nModes ! bi (:) = 0.0_dp ! nm = nb + 1 call iknb ( nb + 1 , x ( j ), nm , bi ) ! , di, bk, dk) ! do i = 0 , nb + 1 ! besOrderNofModeM ( i , j ) = bi ( i ) ! enddo ! !write(6,*) j, x(j) !, (besOrderNofModeM(i,j), i = 0, 5) ! nb + 1) !, phonF(j) ! enddo ! return ! end subroutine computeVariables ! ! subroutine arrangeLargerToSmaller () ! implicit none ! integer :: i , iMode ! real ( kind = dp ), allocatable :: temp (:) real ( kind = dp ) :: tmpr integer :: tmpi ! allocate ( temp ( nModes ) ) ! temp (:) = 0.0_dp temp (:) = x (:) ! exp(wby2kT(:) - Sj(:)*coth(:))*besOrderNofModeM(1,:) ! x(:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! tmpi = s2L ( i ) s2L ( i ) = s2L ( i + 1 ) s2L ( i + 1 ) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! endif ! enddo ! enddo ! deallocate ( temp ) ! return ! end subroutine arrangeLargerToSmaller ! ! subroutine displaceAtoms () ! implicit none ! integer :: istat , iAtom , iMode , iRand real ( kind = dp ) :: ran , norm ! allocate ( newAtomicPosition ( 3 , nAtoms ) ) ! open ( unit = 12 , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! write ( iostd , * ) ! do iMode = modeI , modeF ! write ( iostd , '(\" Calculating new atomic positions for mode :\", i10)' ) s2L ( iMode ) ! do iAtom = 1 , nAtoms ! norm = sqrt ( sum ( phonD (:, iAtom , s2L ( iMode ), qPoint ) ** 2 )) ! read ( 12 ) iRand ran = mod ( abs ( iRand ), 10000000 ) / 1.0e7_dp ! newAtomicPosition (:, iAtom ) = atomPosition (:, iAtom ) + maxDisplacement * ran * phonD (:, iAtom , s2L ( iMode ), qPoint ) / norm ! enddo ! enddo ! close ( 12 ) ! end subroutine displaceAtoms ! ! subroutine writeNewAtomicPositions () ! implicit none ! integer :: iAtom , iMode ! do iMode = modeI , modeF ! write ( iostd , '(\" Writing new atomic positions for mode :\", i10)' ) s2L ( iMode ) ! if ( s2L ( iMode ) < 10 ) then write ( newAtomicPositions , '(\"newPositionsForMode\", i1)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 100 ) then write ( newAtomicPositions , '(\"newPositionsForMode\", i2)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 1000 ) then write ( newAtomicPositions , '(\"newPositionsForMode\", i3)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 10000 ) then write ( newAtomicPositions , '(\"newPositionsForMode\", i4)' ) s2L ( iMode ) else newAtomicPositions = 'newPositions' endif ! open ( 21 , file = trim ( newAtomicPositions ), status = 'unknown' ) ! do iAtom = 1 , nAtoms ! !write(6, '(i4, f15.12, 3f15.5, \" | \", 3f15.5)') iAtom, maxDisplacement*ran, & !          atomPosition(:,iAtom), atomPosition(:,iAtom) + maxDisplacement*ran*phonD(:,iAtom,s2L(iMode),qPoint)/norm write ( 21 , * ) elements ( iAtom ), newAtomicPosition (:, iAtom ) enddo ! close ( 21 ) ! enddo ! end subroutine writeNewAtomicPositions ! ! subroutine exportQEInput () ! integer :: iAtom , iMode character ( len = 256 ) :: line , fn , modeFolder , mkDir ! do iMode = modeI , modeF ! if ( s2L ( iMode ) < 10 ) then write ( modeFolder , '(\"mode_\", i1)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 100 ) then write ( modeFolder , '(\"mode_\", i2)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 1000 ) then write ( modeFolder , '(\"mode_\", i3)' ) s2L ( iMode ) else if ( s2L ( iMode ) < 10000 ) then write ( modeFolder , '(\"mode_\", i4)' ) s2L ( iMode ) endif ! inquire ( file = trim ( modeFolder ), exist = file_exists ) if ( . not . file_exists ) then write ( mkDir , '(\"mkdir -p \", a)' ) trim ( modeFolder ) call system ( mkDir ) endif ! fn = trim ( QEInput ) fn = fn ( INDEX ( QEInput , '/' , BACK = . TRUE .): INDEX ( QEInput , '.in' ) - 1 ) ! write ( iostd , '(\" Writing new QE input file for mode :\", i10)' ) s2L ( iMode ) ! if ( s2L ( iMode ) < 10 ) then write ( fn , '(a, \"_mode\", i1, \".in\")' ) trim ( fn ), s2L ( iMode ) else if ( s2L ( iMode ) < 100 ) then write ( fn , '(a, \"_mode\", i2, \".in\")' ) trim ( fn ), s2L ( iMode ) else if ( s2L ( iMode ) < 1000 ) then write ( fn , '(a, \"_mode\", i3, \".in\")' ) trim ( fn ), s2L ( iMode ) else if ( s2L ( iMode ) < 10000 ) then write ( fn , '(a, \"_mode\", i4, \".in\")' ) trim ( fn ), s2L ( iMode ) endif ! fn = trim ( modeFolder ) // \"/\" // trim ( fn ) ! open ( 2 , file = trim ( fn ), status = \"unknown\" ) ! open ( 1 , file = trim ( QEInput ), status = \"old\" ) ! do read ( 1 , '(a)' , END = 100 ) line write ( 2 , '(a)' ) trim ( line ) if ( INDEX ( line , 'ATOMIC_POSITIONS' ) /= 0 ) then do iAtom = 1 , nAtoms read ( 1 , '(a)' ) line write ( 2 , * ) elements ( iAtom ), newAtomicPosition (:, iAtom ) enddo endif enddo 100 continue ! close ( 1 ) close ( 2 ) ! enddo ! end subroutine exportQEInput !  subroutine readMjs() !    ! !    implicit none !    ! !    integer :: i, iE0, iE, dummyI, nEMjs !    real(kind = dp) :: dummyD, E, MjsOfE, MjOfE0 !    character :: dummyC !    ! !    open(1, file=trim(MjsInput), status=\"old\") !    ! !    read(1, *) dummyC, nEMjs !    ! !    allocate ( Mjs(-nEnergies:nEnergies) ) !    ! !    Mjs = 1.0_dp !    ! !!    read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, MjsOfE0, dummyD !!    ! !!    E = E*eVToHartree !!    iE = int(E/deltaE) + 1 !!    ! !!    do i = 1, nEMjs - 1 !!      ! !!      iE0 = iE !!      read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, MjsOfE, dummyD !!      E = E*eVToHartree !!      iE = int(E/deltaE) + 1 !!      Mjs(iE0:iE) = MjsOfE0 !!      MjsOfE0 = MjsOfE !!      ! !!    enddo !!    ! !!    close(1) !!    ! !!    !do iE = -nEnergies, nEnergies !!    !  write(44,*) real(iE, dp)*deltaE*HartreeToEv, Mjs(iE) !!    !enddo !!    ! !    return !    ! !  end subroutine readMjs ! ! subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !c*********************************************************************72 !c !cc IKNB compute Bessel function In(x) and Kn(x). !c !c  Discussion: !c !c    Compute modified Bessel functions In(x) and Kn(x), !c    and their derivatives. !c !c  Licensing: !c !c    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !c    they give permission to incorporate this routine into a user program !c    provided that the copyright is acknowledged. !c !c  Modified: !c !c    17 July 2012 !c !c  Author: !c !c    Shanjie Zhang, Jianming Jin !c !c  Reference: !c !c    Shanjie Zhang, Jianming Jin, !c    Computation of Special Functions, !c    Wiley, 1996, !c    ISBN: 0-471-11963-6, !c    LC: QA351.C45. !c !c  Parameters: !c !c    Input, integer N, the order of In(x) and Kn(x). !c !c    Input, double precision X, the argument. !c !c    Output, integer NM, the highest order computed. !c !c    Output, double precision BI(0:N), DI(0:N), BK(0:N), DK(0:N), !c    the values of In(x), In'(x), Kn(x), Kn'(x). !c implicit none integer , intent ( in ) :: n !      double precision :: a0 double precision :: bi ( 0 : n ) !      double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: f0 double precision :: f1 !      double precision :: g !      double precision :: g0 !      double precision :: g1 integer :: k !      integer :: k0 !      integer :: l integer :: m , ik !      integer :: msta1 !      integer :: msta2 integer :: nm double precision :: pi !      double precision :: r double precision :: s0 double precision :: sk0 !      double precision :: vt double precision :: x , ifact pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n if ( x . le . 1.0D-15 ) then do k = 0 , n ifact = 1.0_dp do ik = 2 , k ifact = ifact * ik enddo bi ( k ) = ( 0.5_dp * x ) ** k / ifact end do return end if if ( n . eq . 0 ) then nm = 1 end if m = msta1 ( x , 200 ) if ( m . lt . nm ) then nm = m else m = msta2 ( x , nm , 15 ) end if bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 if ( k . le . nm ) then bi ( k ) = f end if if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then sk0 = sk0 + 4.0D+00 * f / k end if bs = bs + 2.0D+00 * f f0 = f1 f1 = f end do s0 = exp ( x ) / ( bs - f ) do k = 0 , nm bi ( k ) = s0 * bi ( k ) end do return end SUBROUTINE iknb ! ! SUBROUTINE iknb2 ( n , x , nm , bi , di , bk , dk ) ! !    ============================================================ !    Purpose: Compute modified Bessel functions In(x) and Kn(x), !             and their derivatives !    Input:   x --- Argument of In(x) and Kn(x) ( 0 ó x ó 700 ) !             n --- Order of In(x) and Kn(x) !    Output:  BI(n) --- In(x) !             DI(n) --- In'(x) !             BK(n) --- Kn(x) !             DK(n) --- Kn'(x) !             NM --- Highest order computed !    Routines called: !             MSTA1 and MSTA2 for computing the starting point !             for backward recurrence !    =========================================================== ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( OUT ) :: nm REAL ( dp ), INTENT ( OUT ) :: bi ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: di ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: bk ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: dk ( 0 : n ) ! REAL ( dp ), PARAMETER :: pi = 3.141592653589793_dp , el = 0.5772156649015329_dp REAL ( dp ) :: a0 , bkl , bs , f , f0 , f1 , g , g0 , g1 , r , s0 , sk0 , vt INTEGER :: k , k0 , l , m ! nm = n IF ( x <= 1.0D-50 ) THEN DO k = 0 , n bi ( k ) = 0.0D0 di ( k ) = 0.0D0 bk ( k ) = 1.0D+300 dk ( k ) = - 1.0D+300 END DO bi ( 0 ) = 1.0D0 di ( 1 ) = 0.5D0 RETURN END IF IF ( n == 0 ) nm = 1 m = msta1 ( x , 200 ) IF ( m < nm ) THEN nm = m ELSE m = msta2 ( x , nm , 15 ) END IF !write(6,*)'mmmmmmmmm', m bs = 0.0D0 sk0 = 0.0D0 f0 = 0.0D0 f1 = 1.0D-100 DO k = m , 0 , - 1 f = 2 * ( k + 1 ) / x * f1 + f0 IF ( k <= nm ) bi ( k ) = f IF ( k /= 0 . AND . k == 2 * INT ( k / 2 )) sk0 = sk0 + 4.0D0 * f / k bs = bs + 2.0D0 * f f0 = f1 f1 = f END DO !s0 = EXP(x) / (bs-f) !write(6,*) f, f1 s0 = EXP ( x ) / ( bs - f1 ) bi ( 0 : nm ) = s0 * bi ( 0 : nm ) IF ( x <= 8.0D0 ) THEN bk ( 0 ) = - ( LOG ( 0.5D0 * x ) + el ) * bi ( 0 ) + s0 * sk0 bk ( 1 ) = ( 1.0D0 / x - bi ( 1 ) * bk ( 0 )) / bi ( 0 ) ELSE a0 = SQRT ( pi / ( 2.0D0 * x )) * EXP ( - x ) k0 = 16 IF ( x >= 2 5.0 ) k0 = 10 IF ( x >= 8 0.0 ) k0 = 8 IF ( x >= 20 0.0 ) k0 = 6 DO l = 0 , 1 bkl = 1.0D0 vt = 4 * l r = 1.0D0 DO k = 1 , k0 r = 0.125D0 * r * ( vt - ( 2 * k - 1 ) ** 2 ) / ( k * x ) bkl = bkl + r END DO bk ( l ) = a0 * bkl END DO END IF g0 = bk ( 0 ) g1 = bk ( 1 ) DO k = 2 , nm g = 2 * ( k - 1 ) / x * g1 + g0 bk ( k ) = g g0 = g1 g1 = g END DO di ( 0 ) = bi ( 1 ) dk ( 0 ) = - bk ( 1 ) DO k = 1 , nm di ( k ) = bi ( k - 1 ) - k / x * bi ( k ) dk ( k ) = - bk ( k - 1 ) - k / x * bk ( k ) END DO RETURN ! END SUBROUTINE iknb2 ! ! FUNCTION msta1 ( x , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that the magnitude of !                Jn(x) at that point is about 10&#94;(-MP) !       Input :  x     --- Argument of Jn(x) !                MP    --- Value of magnitude !       Output:  MSTA1 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , f , f0 , f1 INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) n0 = INT ( 1.1 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - mp IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn ! RETURN ! END FUNCTION msta1 ! ! FUNCTION msta2 ( x , n , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that all Jn(x) has MP !                significant digits !       Input :  x  --- Argument of Jn(x) !                n  --- Order of Jn(x) !                MP --- Significant digit !       Output:  MSTA2 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) hmp = 0.5_dp * mp ejn = envj ( n , a0 ) IF ( ejn <= hmp ) THEN obj = mp n0 = INT ( 1.1 * a0 ) ELSE obj = hmp + ejn n0 = n END IF !!!!!!!! if ( n0 < 1 ) n0 = 1 !!!!!!!! f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj ! DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - obj IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn + 10 ! RETURN ! END FUNCTION msta2 ! ! FUNCTION envj ( n , x ) RESULT ( fn_val ) ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val ! fn_val = 0.5_dp * LOG10 ( 6.28_dp * n ) - n * LOG10 ( 1.36_dp * x / n ) ! RETURN ! END FUNCTION envj ! ! end module MjModule","tags":"","loc":"sourcefile/mj_module_v1.f90.html","title":"Mj_Module_v1.f90 – Carrier Cross Sections"},{"text":"Contents Programs lineShapeFunction Source Code LSF_zeroth_Main.f90 Source Code program lineShapeFunction ! ! Pull in modules use mpi use lsf ! implicit none ! ! Define an integer for ???? integer :: lll , iPhonon ! character ( len = 2 ) :: charI ! ! Initialize mpi and set up processes call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! ! If root process if ( myid == root ) then ! ! Start a timer call cpu_time ( ti ) ! ! Read input, check all variables needed and initialize the calculation. call readInputs () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call initializeLSF () ! endif ! ! Broadcast calculation parameters to all processes call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! ! For all processes that aren't the root if ( myid /= root ) then ! Allocate space for arrays allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !allocate( Vfis(-nEnergies:nEnergies) ) endif ! ! Broadcast arrays to all processes call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) !call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! ! Allocate space for arrays allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( 3 <= maximumNumberOfPhonons ) then ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! end if ! do iPhonon = minimumNumberOfPhonons , MIN0 ( maximumNumberOfPhonons , 4 ) if ( ( ( iPhonon == 1 . or . iPhonon == 2 ) . and . myid == root ) . or . iPhonon > 2 ) then if ( iPhonon > 2 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! endif ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then call cpu_time ( t1 ) ! call lsfMbyOneBand ( iPhonon ) ! if ( iPhonon > 1 ) then ! call lsfMbyTwoBands ( iPhonon ) ! else if ( iPhonon > 2 ) then ! call parallelIsFsBy3 () ! endif ! endif ! if ( iPhonon > 2 ) then ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( iPhonon ) ! endif ! if ( iPhonon > 3 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfDeterministicFourPhononsByFourBands () ! endif ! if ( iPhonon > 2 ) then ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! endif if ( myid == root ) then ! call cpu_time ( t2 ) ! write ( iostd , '(i2, \" modes, time needed :,\" , f10.2, \" secs.\")' ) iPhonon , t2 - t1 flush ( iostd ) ! if ( iPhonon > 2 ) then ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! else ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByBands , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! endif ! write ( iostd , * ) 'DE' , iPhonon , de flush ( iostd ) ! charI = '' write ( charI , \"(i2.2)\" ) iPhonon ! open ( 1 , file = 'lsfVsEwithUpTo' // trim ( charI ) // 'phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , iPhonon ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! if ( iPhonon < 3 ) then ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de ! else ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de ! endif ! enddo ! close ( 1 ) ! endif ! endif ! enddo ! if ( maximumNumberOfPhonons >= 5 ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then ! if ( istat /= 0 ) then ! write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' ! else ! write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' ! endif ! flush ( iostd ) ! endif ! if ( istat /= 0 ) close ( un ) ! ! allocate ( lsfbyPhononsPerProc(-nEnergies:nEnergies) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC ! do i = numprocs - 1 , 1 , - 1 ! iModeIs ( i ) = i * iMint + 1 ! if ( iMmod > 0 ) then ! iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 ! endif ! iModeFs ( i - 1 ) = iModeIs ( i ) - 1 ! enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 ! do ni = m - 1 , m - l + 1 , - 1 ! times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 ! enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = nModes ! do iMode = 2 , l ! weight = weight * ( nModes - iMode + 1 ) / iMode ! enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m ! elseif ( m < 100 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m ! elseif ( m < 1000 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m ! else ! write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m ! endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de ! enddo ! close ( 5000 ) ! endif ! enddo ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! deallocate ( lsfVsEbyBands , iEbinsByBands , pj ) ! if ( 3 <= maximumNumberOfPhonons ) then ! deallocate ( iModeIs , iModeFs ) ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! end if ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"sourcefile/lsf_zeroth_main.f90.html","title":"LSF_zeroth_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules lsf Source Code LSF_zeroth_Module_v35.f90 Source Code module lsf ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: iostd = 16 , un = 3 integer , parameter :: root = 0 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: THzToHartree = 1.0_dp / 657 9.683920729_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer ( kind = int32 ) :: myid , numprocs , ios , istat , ierr integer :: iMode , l , m , nMC , nProcMax integer :: iMint , iMmod , i , printsteps , iE , ni , mi integer :: nAtoms , nOfqPoints , nModes , minimumNumberOfPhonons , maximumNumberOfPhonons , nEnergies ! real ( kind = dp ) :: ti , tf , t1 , t2 real ( kind = dp ) :: weight , times , de , E ! , vg real ( kind = dp ) :: temperature , maxEnergy , deltaE , kT ! , volume ! integer , allocatable :: iModeIs (:), iModeFs (:) integer , allocatable :: pj (:), pj0s (:,:), pms (:,:), s2L (:) integer , allocatable :: iEbinsByBands (:), iEbinsByPhonons (:) ! real ( kind = dp ), allocatable :: atomD (:,:), atomM (:), phonQ (:,:), phonF (:), genCoord (:) !, Vfis(:) real ( kind = dp ), allocatable :: wby2kT (:), phonD (:,:,:,:), x (:), Sj (:), coth (:), besOrderNofModeM (:,:) real ( kind = dp ), allocatable :: lsfVsEbyBands (:), lsfVsE (:), lsfVsEbyPhonons (:), lsfbyPhononsPerProc (:) ! character ( len = 6 ), parameter :: output = 'status' !  character(len = 256) :: VfisInput, PhononsInput, crossSectionOutput, fn, continueLSFfromFile character ( len = 256 ) :: phononsInputFormat , phononsInput , fn , continueLSFfromFile ! logical :: file_exists ! !  namelist /elphscat/ VfisInput, PhononsInput, temperature, maxEnergy, continueLSFfromFile, volume, & namelist / lsfInput / phononsInput , phononsInputFormat , temperature , & continueLSFfromFile , maximumNumberOfPhonons , nMC ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if file output exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , lsfInput , iostat = ios ) ! call checkAndUpdateInput () ! if ( trim ( phononsInputFormat ) == 'VASP' ) then call readPhononsVASP () else if ( trim ( phononsInputFormat ) == 'QE' ) then call readPhononsQE () else write ( iostd , '(\" Unknown phonons input format : \", (a) )' ) trim ( phononsInputFormat ) write ( iostd , '(\" Phonons input format implemened are : ''VASP'' and ''QE''\")' ) write ( iostd , '(\" Program stops!\")' ) stop endif ! !    call readVfis() ! return ! end subroutine readInputs ! ! subroutine initializeLSF () ! implicit none ! real ( kind = dp ) :: dummyD integer :: dummyI character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! allocate ( lsfVsE ( - nEnergies : nEnergies ) ) ! minimumNumberOfPhonons = 1 lsfVsE (:) = 0.0_dp ! if ( continueLSFfromFile /= '' ) then ! inquire ( file = trim ( continueLSFfromFile ), exist = file_exists ) if ( file_exists ) then ! open ( unit = 11 , file = trim ( continueLSFfromFile ), status = \"old\" ) ! read ( 11 , '(a1, i10, a9, i5, a8)' ) dummyC1 , dummyI , dummyC9 , minimumNumberOfPhonons , dummyC8 ! minimumNumberOfPhonons = minimumNumberOfPhonons + 1 write ( iostd , '(\" Minimum number of phonons : \", i5)' ) minimumNumberOfPhonons ! do iE = - nEnergies , nEnergies read ( 11 , * ) dummyD , lsfVsE ( iE ) enddo close ( 11 ) ! endif endif ! return ! end subroutine initializeLSF ! ! subroutine initialize () ! implicit none ! !    VfisInput = '' phononsInput = '' phononsInputFormat = '' temperature = - 1.0_dp minimumNumberOfPhonons = 1 maximumNumberOfPhonons = - 1 nMC = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () ! implicit none ! logical :: abortExecution = . false . ! if ( trim ( phononsInput ) == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( phononsInput ) endif ! if ( trim ( phononsInputFormat ) == '' ) then write ( iostd , '(\" PhononsInputFormat is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input format : \", a)' ) trim ( phononsInputFormat ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Tempetature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324e-5_dp * eVToHartree endif ! if ( maximumNumberOfPhonons < 0 ) then write ( iostd , '(\" Variable maximumNumberOfPhonons has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum number of phonons : \", i5)' ) maximumNumberOfPhonons endif ! if ( nMC < 0 ) then if ( maximumNumberOfPhonons > 4 ) then write ( iostd , '(\" For calculations with configurations with more than 4 phonon modes \")' ) write ( iostd , '(\" the number of Monte Carlo steps ''nMC'' must be set.\")' ) abortExecution = . true . endif else if ( maximumNumberOfPhonons > 4 ) then write ( iostd , '(\" Number of Monte Carlo steps : \", i15)' ) nMC else write ( iostd , '(\" The number of Monte Carlo steps ''nMC'' is set to : \", i15, \" but\")' ) nMC write ( iostd , '(\" will not be used since the Monte Carlo sheme is used for calculations\")' ) write ( iostd , '(\" with configurations with more that 4 phonon modes.\")' ) endif endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" * Please check the input. * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! maxEnergy = 1 0.0_dp * eVToHartree ! nEnergies = 5040 ! 2520 ! 10080 deltaE = maxEnergy / real ( nEnergies , dp ) ! write ( iostd , '(\" The resolution in energy is :\", f10.2, \" meV.\")' ) deltaE * 100 0.0_dp * HartreeToEv ! flush ( iostd ) ! return ! end subroutine checkAndUpdateInput ! ! subroutine readPhononsVASP () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! !write(6,*) trim(phononsInput) open ( 1 , file = trim ( phononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms ! nModes = 3 * nAtoms - 3 ! write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes : \", i5)' ) nModes flush ( iostd ) ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhononsVASP ! ! subroutine readPhononsQE () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! !write(6,*) trim(phononsInput) open ( 1 , file = trim ( phononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms , nModes ! write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes : \", i5)' ) nModes flush ( iostd ) ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp !The unit is in Bohr do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC read ( 1 , * ) ! do iMode = 1 , nModes ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , freqInTHz phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyC , phonD ( 1 , iAtom , iMode , iq ), dummyD , phonD ( 2 , iAtom , iMode , iq ), dummyD , phonD ( 3 , iAtom , iMode , iq ), dummyC write ( 6 , * ) phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhononsQE ! ! subroutine computeGeneralizedDisplacements () ! implicit none ! integer :: iq , iMode , iAtom ! allocate ( genCoord ( nModes ) ) ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) ! enddo ! enddo ! enddo ! open ( 11 , file = 'generalizedDisplacements' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2\")' ) ! do iMode = 1 , nModes write ( 11 , '(i4,1x,3E20.10E3)' ) iMode , phonF ( iMode ) * 1.0e3_dp * HartreeToEv , genCoord ( iMode ), genCoord ( iMode ) * genCoord ( iMode ) enddo ! close ( 11 ) ! deallocate ( atomM , phonD , atomD ) ! return ! end subroutine computeGeneralizedDisplacements ! ! subroutine computeVariables () ! implicit none ! integer :: i , j , nm , nb ! real ( kind = dp ), allocatable :: bi (:), di (:), bk (:), dk (:) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) ! x = 0.0_dp Sj = 0.0_dp coth = 0.0_dp wby2kT = 0.0_dp ! Sj (:) = 0.5_dp * phonF (:) * genCoord (:) * genCoord (:) wby2kT (:) = phonF (:) / ( 2.0_dp * kT ) coth (:) = cosh ( wby2kT (:)) / sinh ( wby2kT (:)) x (:) = Sj (:) / sinh ( wby2kT (:)) ! allocate ( s2L ( nModes ) ) s2L (:) = 0 ! do iMode = 1 , nModes s2L ( iMode ) = iMode enddo ! call arrangeLargerToSmaller () ! open ( 11 , file = 'modes' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2,  Sj/sinh(wby2kT)\")' ) ! do iMode = 1 , nModes ! write ( 11 , '(i4,1x,4E20.10E3)' ) s2L ( iMode ), phonF ( s2L ( iMode )) * 1.0e3_dp * HartreeToEv , & genCoord ( s2L ( iMode )), genCoord ( s2L ( iMode )) ** 2 , x ( s2L ( iMode )) ! enddo ! close ( 11 ) ! deallocate ( genCoord ) ! !  call arrangeLargerToSmaller() ! nb = maximumNumberOfPhonons allocate ( besOrderNofModeM ( 0 : nb + 1 , nModes ) ) allocate ( bi ( 0 : nb + 1 ), di ( 0 : nb + 1 ) ) allocate ( bk ( 0 : nb + 1 ), dk ( 0 : nb + 1 ) ) ! do j = 1 , nModes ! bi (:) = 0.0_dp ! nm = nb + 1 call iknb ( nb + 1 , x ( j ), nm , bi ) ! , di, bk, dk) ! do i = 0 , nb + 1 ! besOrderNofModeM ( i , j ) = bi ( i ) ! enddo ! write ( 6 , * ) j , x ( j ), ( besOrderNofModeM ( i , j ), i = 0 , 5 ) ! nb + 1) !, phonF(j) ! enddo ! return ! end subroutine computeVariables ! ! subroutine arrangeLargerToSmaller () ! implicit none ! integer :: i , iMode ! real ( kind = dp ), allocatable :: temp (:) real ( kind = dp ) :: tmpr integer :: tmpi ! allocate ( temp ( nModes ) ) ! temp (:) = 0.0_dp temp (:) = x (:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! if ( exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! tmpi = s2L ( i ) s2L ( i ) = s2L ( i + 1 ) s2L ( i + 1 ) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! ! !          tmp = x(i) !          x(i) = x(i+1) !          x(i+1) = tmp !          ! !          tmp = coth(i) !          coth(i) = coth(i+1) !          coth(i+1) = tmp !          ! !          tmp = wby2kT(i) !          wby2kT(i) = wby2kT(i+1) !          wby2kT(i+1) = tmp !          ! !          tmp = phonF(i) !          phonF(i) = phonF(i+1) !          phonF(i+1) = tmp !          ! endif ! enddo ! enddo ! deallocate ( temp ) ! return ! end subroutine arrangeLargerToSmaller ! ! !  subroutine readVfis() !    ! !    implicit none !    ! !    integer :: i, iE0, iE, dummyI, nEVfi !    real(kind = dp) :: dummyD, E, VfiOfE, VfiOfE0 !    character :: dummyC !    ! !    open(1, file=trim(VfisInput), status=\"old\") !    ! !    read(1, *) dummyC, nEVfi !    ! !    allocate ( Vfis(-nEnergies:nEnergies) ) !    ! !    Vfis = 0.0_dp !    ! !    read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, VfiOfE0, dummyD !    ! !    E = E*eVToHartree !    iE = int(E/deltaE) + 1 !    ! !    do i = 1, nEVfi - 1 !      ! !      iE0 = iE !      read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, VfiOfE, dummyD !      E = E*eVToHartree !      iE = int(E/deltaE) + 1 !      Vfis(iE0:iE) = VfiOfE0 !      VfiOfE0 = VfiOfE !      ! !    enddo !    ! !    close(1) !    ! !    !do iE = -nEnergies, nEnergies !    !  write(44,*) real(iE, dp)*deltaE*HartreeToEv, Vfis(iE) !    !enddo !    ! !    return !    ! !  end subroutine readVfis ! ! subroutine lsfDeterministicFourPhononsByFourBands () ! implicit none ! integer :: ic integer :: iMode1 , iMode2 , iMode3 , iMode4 integer :: pm1 , pm2 , pm3 , pm4 ! real ( kind = dp ) :: t1 , t2 ! if ( myid == root ) then write ( iostd , * ) 'Four modes' flush ( iostd ) endif ! ! Four modes ! call cpu_time ( t1 ) ! ic = 0 do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , nModes - 2 !write(iostd, '(\"myID \", i15, \" iMode1 = \", i5, \" / \", i5, \" in each proc. iMode2 =\", i5, \" / \", i5)') myid, & !           iMode1-iModeIs(myid)+1, iModeFs(myid)-iModeIs(myid)+1,iMode2 - iMode1+1 + 1, nModes - 2 - iMode1+1 + 1 do iMode3 = iMode2 + 1 , nModes - 1 do iMode4 = iMode3 + 1 , nModes ! do pm1 = - 1 , 1 , 2 do pm2 = - 1 , 1 , 2 do pm3 = - 1 , 1 , 2 do pm4 = - 1 , 1 , 2 ! pj (:) = 0 pj ( iMode1 ) = pm1 pj ( iMode2 ) = pm2 pj ( iMode3 ) = pm3 pj ( iMode4 ) = pm4 ! call lsfOfConfigurationPj () ! ic = ic + 1 ! enddo enddo enddo enddo ! enddo enddo enddo enddo ! call cpu_time ( t2 ) ! return ! end subroutine lsfDeterministicFourPhononsByFourBands ! ! subroutine lsfOfConfigurationPj () ! implicit none ! integer :: iE , j ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio ! prodFj = 1.0_dp sumOverj = 0.0_dp do j = 1 , nModes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( j )), j ) if ( pj ( j ) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj endif prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( j ) / ( abs ( pj ( j )) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( j )) + 1 , j ) / besPj sumOverj = sumOverj + ( abs ( pj ( j )) + x ( j ) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! return ! end subroutine lsfOfConfigurationPj ! ! subroutine calculatePlusMinusStates ( l ) ! implicit none ! integer , intent ( in ) :: l ! integer :: iDes , other ( 0 : l - 1 ) ! do iDes = 0 , 2 ** l - 1 ! other (:) = 0 ! call decimalToOther ( iDes , l , 2 , other ) ! pms ( iDes ,:) = other (:) ! enddo ! return ! end subroutine calculatePlusMinusStates ! ! subroutine distrubutePhononsInBands ( m , l ) ! implicit none ! integer , intent ( in ) :: m , l ! integer :: i , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 , i11 , i12 ! if ( l == 1 ) then ! pj0s ( 1 , 1 ) = m ! else if ( l == m - 1 ) then ! do i = 1 , l pj0s ( i ,:) = 1 pj0s ( i , i ) = m - ( l - 1 ) enddo ! else if ( l == m ) then ! pj0s ( 1 ,:) = 1 ! else if ( l == 2 ) then ! do i = 1 , m - 1 ! pj0s ( i , 1 ) = i pj0s ( i , 2 ) = m - i ! enddo ! else if ( l == 3 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 ! i = i + 1 ! endif ! enddo enddo enddo ! !write(6,*) 'l = 3, i = ', i - 1 ! else if ( l == 4 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 ! i = i + 1 ! endif ! enddo enddo enddo enddo !write(6,*) 'l = 4, i = ', i - 1 ! else if ( l == 5 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo ! !write(6,*) 'l = 5, i = ', i - 1 ! else if ( l == 6 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 6, i = ', i - 1 ! else if ( l == 7 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 7, i = ', i ! else if ( l == 8 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 8, i = ', i ! else if ( l == 9 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 10 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 11 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 12 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) do i12 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 + i12 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 pj0s ( i , 12 ) = i12 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo endif ! return ! end subroutine distrubutePhononsInBands ! ! subroutine lsfWithMphonons ( m , l , tTimes ) ! implicit none ! integer , intent ( in ) :: m , l , tTimes ! integer :: ii ! integer :: iMC , iM , i , pick , j , picks ( l ), iE , iDes , iRand , steps ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio , randy ! logical :: picked ! if ( myid == root ) then write ( iostd , '(i4,\" phonons by\", i3, \" bands started.\")' ) m , l flush ( iostd ) endif ! printSteps = int ( ( iModeFs ( myid ) - iModeIs ( myid ) + 1.01_dp ) / 10 ) ! do iMC = iModeIs ( myid ), iModeFs ( myid ) ! if ( mod ( iMC - iModeIs ( myid ) + 1 , printSteps ) == 0 ) then if ( myid == root ) then steps = iModeFs ( myid ) - iModeIs ( myid ) + 1 write ( iostd , '(i4,\" phonons by\", i3,\" bands.\", i12,\" over \",i12,\" MC iters per processor done.\")' ) m , l , iMC , steps flush ( iostd ) endif endif ! picks (:) = 0 ! if ( istat == 0 ) then ! do iM = 1 , l picked = . false . 10 read ( un ) iRand iRand = mod ( abs ( iRand ), nModes ) + 1 do i = 1 , iM - 1 if ( picks ( i ) == iRand ) goto 10 enddo picks ( iM ) = iRand ! enddo ! else ! do iM = 1 , l picked = . false . ! 11 CALL RANDOM_NUMBER ( randy ) ! pick = int ( nModes * randy ) + 1 do i = 1 , l if ( pick . eq . picks ( i ) ) picked = . true . enddo if ( picked ) goto 11 picks ( iM ) = pick enddo ! endif ! do ii = 1 , tTimes ! do iDes = 0 , 2 ** l - 1 ! pj (:) = 0 ! do iM = 1 , l pj ( picks ( iM )) = pj0s ( ii , iM ) * ( - 1 ) ** ( pms ( iDes , iM - 1 )) enddo ! if ( abs ( sum ( abs ( pj ( picks (:)))) - m ) > 0 ) then if ( myid == root ) then write ( iostd , * ) 'ERROR' , m , sum ( abs ( pj ( picks (:)))), pj ( picks (:)) do iM = 1 , l if ( abs ( pj ( picks ( iM ))) < 1 ) then write ( iostd , * ) 'ERROR 1' , picks ( iM ) write ( iostd , * ) 'ERROR 2' , pj ( picks ( iM )) flush ( iostd ) endif enddo endif endif ! prodFj = 1.0_dp sumOverj = 0.0_dp ! do j = 1 , nModes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( j )), j ) if ( pj ( j ) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj endif ! prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( j ) / ( abs ( pj ( j )) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( j )) + 1 , j ) / besPj ! sumOverj = sumOverj + ( abs ( pj ( j )) + x ( j ) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) ! iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! enddo ! enddo ! enddo ! if ( myid == root ) then write ( iostd , '(\"---------------------------------------------\")' ) write ( iostd , '(i4,\" phonons by\", i3, \" bands done.\")' ) m , l flush ( iostd ) endif ! return ! end subroutine lsfWithMphonons ! ! subroutine decimalToOther ( iDec , n , iBase , other ) ! implicit none ! integer , intent ( in ) :: n , iBase integer :: iDec , m integer :: other ( 0 : n - 1 ), j ! m = iDec do j = n - 1 , 1 , - 1 other ( j ) = int ( m / ( iBase ** j )) m = mod ( iDec , iBase ** j ) enddo other ( 0 ) = mod ( m , iBase ) ! return ! end subroutine decimalToOther ! ! subroutine calculateDE ( maxM , iEbins , de ) ! implicit none ! integer , intent ( in ) :: maxM , iEbins ( - nEnergies : nEnergies ) real ( dp ), intent ( out ) :: de ! integer :: iE , j , ic , ib , iEmMax , nSteps , jMax , iEstep ! integer , allocatable :: tmpB (:), iEsteps (:) ! logical :: empty ! allocate ( tmpB ( nEnergies ) ) ! ic = 1 do j = 1 , nEnergies if ( mod ( nEnergies , j ) == 0 ) then tmpB ( ic ) = int (( dble ( nEnergies ) + 1.e-8_dp ) / j ) ic = ic + 1 endif enddo ! nSteps = ic - 1 allocate ( iEsteps ( nSteps ) ) iEsteps (:) = tmpB ( nSteps : 1 : - 1 ) deallocate ( tmpB ) ! iEmMax = int ( maxM * maxval ( phonF (:)) / deltaE ) + 1 ! j = 1 do while ( ( iEmMax > iEsteps ( j ) ) . and . ( j < nSteps ) ) j = j + 1 enddo ! jMax = j - 1 if ( jMax > nSteps ) jMax = nSteps ! empty = . true . j = jMax do while ( ( empty . eqv . . true . ) . and . ( j > 1 ) ) ! empty = . true . iEstep = iEsteps ( j ) do iE = 1 , iEmMax - 1 , iEstep ib = sum ( iEbins ( iE : iE + iEstep - 1 ) ) if ( ib < 1 ) then empty = . false . endif enddo j = j - 1 ! enddo ! j = j + 2 ! iEstep = iEsteps ( j ) de = deltaE * real ( iEstep , dp ) ! deallocate ( iEsteps ) ! return ! end subroutine calculateDE ! ! subroutine lsfMbyOneBand ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , pm1 ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do iMode1 = 1 , nModes ! do pm1 = - m , m , 2 * m ! pj (:) = 0 pj ( iMode1 ) = pm1 ! call lsfOfConfigurationPj () ! enddo ! enddo ! call cpu_time ( t2 ) ! write ( iostd , '(\" LSF of: \", i4, \" phonons using one band done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) ! return ! end subroutine lsfMbyOneBand ! ! subroutine lsfMbyTwoBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , iMode2 , pm1 , pm2 , l ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do l = 1 , m - 1 ! do iMode1 = 1 , nModes - 1 do iMode2 = iMode1 + 1 , nModes ! do pm1 = - l , l , 2 * l do pm2 = - ( m - l ), ( m - l ), 2 * ( m - l ) ! pj (:) = 0 pj ( iMode1 ) = pm1 pj ( iMode2 ) = pm2 ! call lsfOfConfigurationPj () ! enddo enddo ! enddo enddo ! enddo ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using two bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyTwoBands ! ! subroutine lsfMbyThreeBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! real ( dp ) :: t1 , t2 , times3 integer :: iMode1 , iMode2 , iMode3 , ni , mi , iDes , ii ! call cpu_time ( t1 ) ! times3 = 1.0_dp mi = 2 do ni = m - 1 , m - 3 + 1 , - 1 times3 = times3 * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times3 + 1.e-3_dp ), 3 ) ) pj0s (:,:) = 0 ! call distrubutePhononsInBands ( m , 3 ) ! allocate ( pms ( 0 : 2 ** 3 - 1 , 0 : 3 - 1 ) ) pms (:,:) = 0 ! call calculatePlusMinusStates ( 3 ) ! do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , nModes - 1 do iMode3 = iMode2 + 1 , nModes ! do ii = 1 , int ( times3 + 1.e-3_dp ) ! do iDes = 0 , 2 ** 3 - 1 ! pj (:) = 0 ! pj ( iMode1 ) = pj0s ( ii , 1 ) * ( - 1 ) ** ( pms ( iDes , 1 - 1 )) pj ( iMode2 ) = pj0s ( ii , 2 ) * ( - 1 ) ** ( pms ( iDes , 2 - 1 )) pj ( iMode3 ) = pj0s ( ii , 3 ) * ( - 1 ) ** ( pms ( iDes , 3 - 1 )) ! call lsfOfConfigurationPj () ! enddo ! enddo ! enddo enddo enddo ! deallocate ( pj0s , pms ) ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using three bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyThreeBands ! ! subroutine writeLSFandCrossSection () ! implicit none ! integer :: iE real ( kind = dp ) :: E !, vg ! open ( 1 , file = 'lsfVsE' , status = 'unknown' ) ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) ! !write(1,'(F16.8,2E18.6e3)') E*HartreeToEv, lsfVsE(iE), twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg write ( 1 , '(F16.8,E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ) !, twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! enddo ! close ( 1 ) ! return ! end subroutine writeLSFandCrossSection ! ! subroutine init_random_seed () ! implicit none ! integer ( kind = int32 ), allocatable :: seed (:) integer ( kind = int32 ) :: n !, i, n, dt(8), pid integer :: t ! call random_seed ( size = n ) ! allocate ( seed ( n )) ! ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. ! call system_clock ( t ) ! seed = 5347 ! !    if (t == 0) then !      call date_and_time(values=dt) !      t = (dt(1) - 1970) * 365 * 24 * 60 * 60 * 1000 & !          + dt(2) * 31 * 24 * 60 * 60 * 1000 & !          + dt(3) * 24 * 60 * 60 * 1000 & !          + dt(5) * 60 * 60 * 1000 & !          + dt(6) * 60 * 1000 + dt(7) * 1000 & !          + dt(8) !    end if !    pid = getpid() !    t = ieor(t, int(pid, kind(t))) !    do i = 1, n !      seed(i) = lcg(t) !    end do !    ! call random_seed ( put = seed ) ! end subroutine init_random_seed ! ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. ! integer function lcg ( s ) ! integer :: s ! if ( s == 0 ) then s = 104729 else !s = mod(s, 4294967296) s = mod ( s , 4294967 ) end if ! !s = mod(s * 279470273, 4294967291) s = mod ( s * 279470273 , 4294967 ) ! lcg = int ( mod ( s , huge ( 0 )), kind ( 0 )) ! end function lcg ! ! subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !c*********************************************************************72 !c !cc IKNB compute Bessel function In(x) and Kn(x). !c !c  Discussion: !c !c    Compute modified Bessel functions In(x) and Kn(x), !c    and their derivatives. !c !c  Licensing: !c !c    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !c    they give permission to incorporate this routine into a user program !c    provided that the copyright is acknowledged. !c !c  Modified: !c !c    17 July 2012 !c !c  Author: !c !c    Shanjie Zhang, Jianming Jin !c !c  Reference: !c !c    Shanjie Zhang, Jianming Jin, !c    Computation of Special Functions, !c    Wiley, 1996, !c    ISBN: 0-471-11963-6, !c    LC: QA351.C45. !c !c  Parameters: !c !c    Input, integer N, the order of In(x) and Kn(x). !c !c    Input, double precision X, the argument. !c !c    Output, integer NM, the highest order computed. !c !c    Output, double precision BI(0:N), DI(0:N), BK(0:N), DK(0:N), !c    the values of In(x), In'(x), Kn(x), Kn'(x). !c implicit none integer , intent ( in ) :: n !      double precision :: a0 double precision :: bi ( 0 : n ) !      double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: f0 double precision :: f1 !      double precision :: g !      double precision :: g0 !      double precision :: g1 integer :: k !      integer :: k0 !      integer :: l integer :: m , ik !      integer :: msta1 !      integer :: msta2 integer :: nm double precision :: pi !      double precision :: r double precision :: s0 double precision :: sk0 !      double precision :: vt double precision :: x , ifact pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n if ( x . le . 1.0D-15 ) then do k = 0 , n ifact = 1.0_dp do ik = 2 , k ifact = ifact * ik enddo bi ( k ) = ( 0.5_dp * x ) ** k / ifact end do return end if if ( n . eq . 0 ) then nm = 1 end if m = msta1 ( x , 200 ) if ( m . lt . nm ) then nm = m else m = msta2 ( x , nm , 15 ) end if bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 if ( k . le . nm ) then bi ( k ) = f end if if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then sk0 = sk0 + 4.0D+00 * f / k end if bs = bs + 2.0D+00 * f f0 = f1 f1 = f end do s0 = exp ( x ) / ( bs - f ) do k = 0 , nm bi ( k ) = s0 * bi ( k ) end do return end SUBROUTINE iknb ! ! SUBROUTINE iknb2 ( n , x , nm , bi , di , bk , dk ) ! !    ============================================================ !    Purpose: Compute modified Bessel functions In(x) and Kn(x), !             and their derivatives !    Input:   x --- Argument of In(x) and Kn(x) ( 0 ó x ó 700 ) !             n --- Order of In(x) and Kn(x) !    Output:  BI(n) --- In(x) !             DI(n) --- In'(x) !             BK(n) --- Kn(x) !             DK(n) --- Kn'(x) !             NM --- Highest order computed !    Routines called: !             MSTA1 and MSTA2 for computing the starting point !             for backward recurrence !    =========================================================== ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( OUT ) :: nm REAL ( dp ), INTENT ( OUT ) :: bi ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: di ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: bk ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: dk ( 0 : n ) ! REAL ( dp ), PARAMETER :: pi = 3.141592653589793_dp , el = 0.5772156649015329_dp REAL ( dp ) :: a0 , bkl , bs , f , f0 , f1 , g , g0 , g1 , r , s0 , sk0 , vt INTEGER :: k , k0 , l , m ! nm = n IF ( x <= 1.0D-50 ) THEN DO k = 0 , n bi ( k ) = 0.0D0 di ( k ) = 0.0D0 bk ( k ) = 1.0D+300 dk ( k ) = - 1.0D+300 END DO bi ( 0 ) = 1.0D0 di ( 1 ) = 0.5D0 RETURN END IF IF ( n == 0 ) nm = 1 m = msta1 ( x , 200 ) IF ( m < nm ) THEN nm = m ELSE m = msta2 ( x , nm , 15 ) END IF !write(6,*)'mmmmmmmmm', m bs = 0.0D0 sk0 = 0.0D0 f0 = 0.0D0 f1 = 1.0D-100 DO k = m , 0 , - 1 f = 2 * ( k + 1 ) / x * f1 + f0 IF ( k <= nm ) bi ( k ) = f IF ( k /= 0 . AND . k == 2 * INT ( k / 2 )) sk0 = sk0 + 4.0D0 * f / k bs = bs + 2.0D0 * f f0 = f1 f1 = f END DO !s0 = EXP(x) / (bs-f) !write(6,*) f, f1 s0 = EXP ( x ) / ( bs - f1 ) bi ( 0 : nm ) = s0 * bi ( 0 : nm ) IF ( x <= 8.0D0 ) THEN bk ( 0 ) = - ( LOG ( 0.5D0 * x ) + el ) * bi ( 0 ) + s0 * sk0 bk ( 1 ) = ( 1.0D0 / x - bi ( 1 ) * bk ( 0 )) / bi ( 0 ) ELSE a0 = SQRT ( pi / ( 2.0D0 * x )) * EXP ( - x ) k0 = 16 IF ( x >= 2 5.0 ) k0 = 10 IF ( x >= 8 0.0 ) k0 = 8 IF ( x >= 20 0.0 ) k0 = 6 DO l = 0 , 1 bkl = 1.0D0 vt = 4 * l r = 1.0D0 DO k = 1 , k0 r = 0.125D0 * r * ( vt - ( 2 * k - 1 ) ** 2 ) / ( k * x ) bkl = bkl + r END DO bk ( l ) = a0 * bkl END DO END IF g0 = bk ( 0 ) g1 = bk ( 1 ) DO k = 2 , nm g = 2 * ( k - 1 ) / x * g1 + g0 bk ( k ) = g g0 = g1 g1 = g END DO di ( 0 ) = bi ( 1 ) dk ( 0 ) = - bk ( 1 ) DO k = 1 , nm di ( k ) = bi ( k - 1 ) - k / x * bi ( k ) dk ( k ) = - bk ( k - 1 ) - k / x * bk ( k ) END DO RETURN ! END SUBROUTINE iknb2 ! ! FUNCTION msta1 ( x , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that the magnitude of !                Jn(x) at that point is about 10&#94;(-MP) !       Input :  x     --- Argument of Jn(x) !                MP    --- Value of magnitude !       Output:  MSTA1 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , f , f0 , f1 INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) n0 = INT ( 1.1 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - mp IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn ! RETURN ! END FUNCTION msta1 ! ! FUNCTION msta2 ( x , n , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that all Jn(x) has MP !                significant digits !       Input :  x  --- Argument of Jn(x) !                n  --- Order of Jn(x) !                MP --- Significant digit !       Output:  MSTA2 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) hmp = 0.5_dp * mp ejn = envj ( n , a0 ) IF ( ejn <= hmp ) THEN obj = mp n0 = INT ( 1.1 * a0 ) ELSE obj = hmp + ejn n0 = n END IF !!!!!!!! if ( n0 < 1 ) n0 = 1 !!!!!!!! f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj ! DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - obj IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn + 10 ! RETURN ! END FUNCTION msta2 ! ! FUNCTION envj ( n , x ) RESULT ( fn_val ) ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val ! fn_val = 0.5_dp * LOG10 ( 6.28_dp * n ) - n * LOG10 ( 1.36_dp * x / n ) ! RETURN ! END FUNCTION envj ! ! subroutine parallelIsFsBy3 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = nModes / 6.0_dp totalStates = totalStates * ( nModes - 1 ) * ( nModes - 2 ) ! !write(iostd, *) 'totalStates', totalStates if ( nModes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = nModes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) / 2.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 2.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = nModes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = nModes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = nModes - 2 ! else ! nProcMax = nModes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy3 ! ! subroutine parallelIsFsBy4 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = nModes / 2 4.0_dp totalStates = totalStates * ( nModes - 1 ) * ( nModes - 2 ) * ( nModes - 3 ) ! !write(iostd, *) 'totalStates', totalStates if ( nModes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = nModes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 6.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) * real ( iState - 4 , dp ) / 6.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = nModes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = nModes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = nModes - 2 ! else ! nProcMax = nModes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy4 ! ! end module lsf","tags":"","loc":"sourcefile/lsf_zeroth_module_v35.f90.html","title":"LSF_zeroth_Module_v35.f90 – Carrier Cross Sections"},{"text":"Contents Programs lineShapeFunction Source Code LSF_linear_Main.f90 Source Code program lineShapeFunction ! use mpi use lsf ! implicit none ! call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! if ( myid == root ) then ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call readPhonons () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call readMjs () ! call initializeLSF () ! endif ! call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( modes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !    allocate( Vfis(-nEnergies:nEnergies) ) endif ! call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( s2L , size ( s2L ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) !  call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( myid == root ) then ! !if ( maximumNumberOfPhonons > 0 ) then if ( ( minimumNumberOfPhonons < 2 ) . and . ( maximumNumberOfPhonons > 0 ) . and . ( modes > 0 ) ) then ! ! One phonon ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call lsfMbyOneBand ( 1 ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 1 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 1 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 1 , file = 'lsfVsEwithUpTo1phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 1 ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 1 ) ! endif ! if ( ( minimumNumberOfPhonons < 3 ) . and . ( maximumNumberOfPhonons > 1 ) . and . ( modes > 1 ) ) then ! ! Two phonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call cpu_time ( t1 ) ! call lsfMbyOneBand ( 2 ) call lsfMbyTwoBands ( 2 ) ! call cpu_time ( t2 ) ! write ( iostd , '(\" 2 modes, time needed :,\" , f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 2 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 2 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 2 , file = 'lsfVsEwithUpTo2phonons' , status = 'unknown' ) ! !      write(2,'(\"# \", i5, \" phonons\")') 2 write ( 2 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 2 do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 2 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 2 ) ! endif ! !   call lsfDeterministicOneAndTwoBands() ! !deallocate ( lsfVsEbyPhonons ) ! endif ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! !if ( maximumNumberOfPhonons > 2 ) then if ( ( minimumNumberOfPhonons < 4 ) . and . ( maximumNumberOfPhonons > 2 ) . and . ( modes > 2 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then ! call lsfMbyOneBand ( 3 ) call lsfMbyTwoBands ( 3 ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 3 ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 3 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 3 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo3phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 3 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 3 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! !if ( maximumNumberOfPhonons > 3 ) then if ( ( minimumNumberOfPhonons < 5 ) . and . ( maximumNumberOfPhonons > 3 ) . and . ( modes > 3 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( 4 ) call lsfMbyTwoBands ( 4 ) ! call parallelIsFsBy3 () ! !write(6,*) '3' !do i = 0, nProcMax - 1 !  write(6,*) i, iModeIs(i), iModeFs(i) !enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 4 ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !if ( myid == root ) then !  write(6,*) '4' !  do i = 0, nProcMax - 1 !    write(6,*) i, iModeIs(i), iModeFs(i) !  enddo !endif ! call lsfDeterministicFourPhononsByFourBands () ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 4 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 4 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo4phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 4 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 4 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! if ( ( maximumNumberOfPhonons > 4 ) . and . ( modes > 4 ) ) then !if ( ( minimumNumberOfPhonons < 6 ) .and. ( maximumNumberOfPhonons > 4 ) ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then if ( istat /= 0 ) then write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' else write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' endif flush ( iostd ) endif ! if ( istat /= 0 ) close ( un ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) allocate ( lsfbyPhononsPerProc ( - nEnergies : nEnergies ) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC do i = numprocs - 1 , 1 , - 1 iModeIs ( i ) = i * iMint + 1 if ( iMmod > 0 ) then iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 endif iModeFs ( i - 1 ) = iModeIs ( i ) - 1 enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 do ni = m - 1 , m - l + 1 , - 1 times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = modes ! do iMode = 2 , l weight = weight * ( modes - iMode + 1 ) / iMode enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m elseif ( m < 100 ) then write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m elseif ( m < 1000 ) then write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m else write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !        write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de enddo close ( 5000 ) ! endif ! enddo ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"sourcefile/lsf_linear_main.f90.html","title":"LSF_linear_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules lsf Source Code LSF_linear_Module_v1.f90 Source Code module lsf ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: iostd = 16 , un = 3 integer , parameter :: root = 0 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: THzToHartree = 1.0_dp / 657 9.683920729_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer ( kind = int32 ) :: myid , numprocs , ios , istat , ierr integer :: iMode , l , m , nMC , nProcMax integer :: iMint , iMmod , i , printsteps , iE , ni , mi integer :: nAtoms , nOfqPoints , nModes , minimumNumberOfPhonons , maximumNumberOfPhonons , nEnergies ! real ( kind = dp ) :: ti , tf , t1 , t2 real ( kind = dp ) :: weight , times , de , E ! , vg real ( kind = dp ) :: temperature , maxEnergy , deltaE , kT ! , volume ! integer , allocatable :: iModeIs (:), iModeFs (:) integer , allocatable :: pj (:), pj0s (:,:), pms (:,:), s2L (:) integer , allocatable :: iEbinsByBands (:), iEbinsByPhonons (:) ! real ( kind = dp ), allocatable :: atomD (:,:), atomM (:), phonQ (:,:), phonF (:), genCoord (:), Mjs (:,:) real ( kind = dp ), allocatable :: wby2kT (:), phonD (:,:,:,:), x (:), Sj (:), coth (:), besOrderNofModeM (:,:) real ( kind = dp ), allocatable :: lsfVsEbyBands (:), lsfVsE (:), lsfVsEbyPhonons (:), lsfbyPhononsPerProc (:) ! integer :: modes ! character ( len = 6 ), parameter :: output = 'status' !  character(len = 256) :: MjsInput, PhononsInput, crossSectionOutput, fn, continueLSFfromFile character ( len = 256 ) :: MjsInput , phononsInput , fn , continueLSFfromFile , equilibriumAtomicPositions ! logical :: file_exists ! !  namelist /elphscat/ MjsInput, PhononsInput, crossSectionOutput, temperature, maxEnergy, continueLSFfromFile, volume, & namelist / lsfInput / MjsInput , equilibriumAtomicPositions , phononsInput , & continueLSFfromFile , maximumNumberOfPhonons , nMC , & temperature , maxEnergy , & modes ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if file output exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , lsfInput , iostat = ios ) ! call checkAndUpdateInput () ! return ! end subroutine readInputs ! ! subroutine initializeLSF () ! implicit none ! real ( kind = dp ) :: dummyD integer :: dummyI character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! allocate ( lsfVsE ( - nEnergies : nEnergies ) ) ! minimumNumberOfPhonons = 1 lsfVsE (:) = 0.0_dp ! if ( continueLSFfromFile /= '' ) then ! inquire ( file = trim ( continueLSFfromFile ), exist = file_exists ) if ( file_exists ) then ! open ( unit = 11 , file = trim ( continueLSFfromFile ), status = \"old\" ) ! read ( 11 , '(a1, i10, a9, i5, a8)' ) dummyC1 , dummyI , dummyC9 , minimumNumberOfPhonons , dummyC8 ! minimumNumberOfPhonons = minimumNumberOfPhonons + 1 write ( iostd , '(\" Minimum number of phonons : \", i5)' ) minimumNumberOfPhonons ! do iE = - nEnergies , nEnergies read ( 11 , * ) dummyD , lsfVsE ( iE ) enddo close ( 11 ) ! endif endif ! return ! end subroutine initializeLSF ! ! subroutine initialize () ! implicit none ! MjsInput = '' phononsInput = '' !crossSectionOutput = '' temperature = - 1.0_dp deltaE = - 1.0_dp minimumNumberOfPhonons = 1 maximumNumberOfPhonons = - 1 nMC = - 1 modes = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () ! implicit none ! logical :: abortExecution = . false . ! if ( MjsInput == '' ) then write ( iostd , '(\" MjsInput is not defined!\")' ) write ( iostd , '(\" A default value will be used. MjsInput = VfisVsE\")' ) MjsInput = 'VfisVsE' else write ( iostd , '(\" Mjs elements input : \", a)' ) trim ( MjsInput ) endif ! if ( phononsInput == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( PhononsInput ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Tempetature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324d-5 * eVToHartree endif ! !    if ( deltaE < 0 ) then !      write(iostd, '(\" Variable deltaE has not been set.\")') !    else !      write(iostd, '(\" DeltaE : \", f10.5, \" eV.\")') deltaE !      deltaE = deltaE*eVToHartree !    endif ! if ( maximumNumberOfPhonons < 0 ) then write ( iostd , '(\" Variable maximumNumberOfPhonons has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum number of phonons : \", i5)' ) maximumNumberOfPhonons endif if ( nMC < 0 ) then write ( iostd , '(\" Variable nMC has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Number of Monte Carlo steps : \", i15)' ) nMC endif ! if ( modes < 0 ) then write ( iostd , '(\" Variable modes has not been set.\")' ) write ( iostd , '(\" All modes will be used.\")' ) endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! maxEnergy = 1 0.0_dp * eVToHartree ! nEnergies = 5040 ! 2520 ! 10080 deltaE = maxEnergy / real ( nEnergies , dp ) ! write ( iostd , * ) 'nEnergies' , nEnergies write ( iostd , * ) 'maxEnergy' , maxEnergy , 'deltaE' , deltaE ! flush ( iostd ) ! return ! end subroutine checkAndUpdateInput ! ! subroutine readPhonons () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! !write(6,*) trim(PhononsInput) open ( 1 , file = trim ( PhononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms ! nModes = 3 * nAtoms - 3 ! write ( iostd , '(\" Number of atoms    : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes    : \", i5)' ) nModes if ( modes < 0 ) then modes = nModes write ( iostd , '(\" Number of modes to be used : \", i5)' ) modes endif flush ( iostd ) ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhonons ! ! subroutine computeGeneralizedDisplacements () ! implicit none ! integer :: iq , iMode , iAtom ! allocate ( genCoord ( nModes ) ) ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) ! enddo ! enddo ! enddo ! !    open(11, file='generalizedDisplacements', status='unknown') !    ! !    write(11, '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2\")') !    ! !    do iMode = 1, nModes !     write(11, '(i4,1x,3E20.10E3)') iMode, phonF(iMode)*1.0e3_dp*HartreeToEv, genCoord(iMode), genCoord(iMode)*genCoord(iMode) !    enddo !    ! !    close(11) ! deallocate ( atomM , phonD , atomD ) ! return ! end subroutine computeGeneralizedDisplacements ! ! subroutine computeVariables () ! implicit none ! integer :: i , j , nm , nb ! real ( kind = dp ), allocatable :: bi (:), di (:), bk (:), dk (:) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) ! x = 0.0_dp Sj = 0.0_dp coth = 0.0_dp wby2kT = 0.0_dp ! Sj (:) = 0.5_dp * phonF (:) * genCoord (:) * genCoord (:) wby2kT (:) = phonF (:) / ( 2.0_dp * kT ) coth (:) = cosh ( wby2kT (:)) / sinh ( wby2kT (:)) x (:) = Sj (:) / sinh ( wby2kT (:)) ! allocate ( s2L ( nModes ) ) s2L (:) = 0 ! do iMode = 1 , nModes s2L ( iMode ) = iMode enddo ! call arrangeLargerToSmaller () ! open ( 11 , file = 'modes' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2,  Sj/sinh(wby2kT)\")' ) ! do iMode = 1 , nModes ! write ( 11 , '(i4,1x,4E20.10E3)' ) s2L ( iMode ), phonF ( s2L ( iMode )) * 1.0e3_dp * HartreeToEv , & genCoord ( s2L ( iMode )), genCoord ( s2L ( iMode )) ** 2 , x ( s2L ( iMode )) ! enddo ! close ( 11 ) ! deallocate ( genCoord ) ! nb = maximumNumberOfPhonons allocate ( besOrderNofModeM ( 0 : nb + 1 , nModes ) ) allocate ( bi ( 0 : nb + 1 ), di ( 0 : nb + 1 ) ) allocate ( bk ( 0 : nb + 1 ), dk ( 0 : nb + 1 ) ) ! do j = 1 , nModes ! bi (:) = 0.0_dp ! nm = nb + 1 call iknb ( nb + 1 , x ( j ), nm , bi ) ! , di, bk, dk) ! do i = 0 , nb + 1 ! besOrderNofModeM ( i , j ) = bi ( i ) ! enddo ! !write(6,*) j, x(j) !, (besOrderNofModeM(i,j), i = 0, 5) ! nb + 1) !, phonF(j) ! enddo ! return ! end subroutine computeVariables ! ! subroutine arrangeLargerToSmaller () ! implicit none ! integer :: i , iMode ! real ( kind = dp ), allocatable :: temp (:) real ( kind = dp ) :: tmpr integer :: tmpi ! allocate ( temp ( nModes ) ) ! temp (:) = 0.0_dp temp (:) = x (:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! if ( exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! !          tmpi = s2L(i) !          s2L(i) = s2L(i+1) !          s2L(i+1) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! tmpr = Sj ( i ) Sj ( i ) = Sj ( i + 1 ) Sj ( i + 1 ) = tmpr ! tmpr = x ( i ) x ( i ) = x ( i + 1 ) x ( i + 1 ) = tmpr ! tmpr = coth ( i ) coth ( i ) = coth ( i + 1 ) coth ( i + 1 ) = tmpr ! tmpr = wby2kT ( i ) wby2kT ( i ) = wby2kT ( i + 1 ) wby2kT ( i + 1 ) = tmpr ! tmpr = phonF ( i ) phonF ( i ) = phonF ( i + 1 ) phonF ( i + 1 ) = tmpr ! endif ! enddo ! enddo ! deallocate ( temp ) ! return ! end subroutine arrangeLargerToSmaller ! ! subroutine readMjs () ! implicit none ! integer :: i , iE0 , iE , numOfMjs real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , MjOfE , MjOfE0 , eBin , DHifMin , eifMin , volume character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 character ( len = 256 ) :: modeFolder ! allocate ( Mjs ( modes , - nEnergies : nEnergies ) ) ! Mjs (:,:) = 0.0_dp ! do iMode = 1 , modes ! if ( s2L ( iMode ) < 10 ) then write ( modeFolder , '(\"mode_\", i1, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 100 ) then write ( modeFolder , '(\"mode_\", i2, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 1000 ) then write ( modeFolder , '(\"mode_\", i3, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 10000 ) then write ( modeFolder , '(\"mode_\", i4, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) endif ! ! inquire ( file = trim ( modeFolder ), exist = file_exists ) if ( . not . file_exists ) then ! write ( iostd , '(\" File : \", a, \" does not exist!\")' ) trim ( modeFolder ) ! else ! write ( iostd , '(\" Reading file : \", a)' ) trim ( modeFolder ) ! open ( 1 , file = trim ( modeFolder ), status = \"old\" ) ! read ( 1 , * ) read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 read ( 1 , * ) ! read ( 1 , '(i10)' ) numOfMjs ! read ( 1 , '(3ES24.15E3)' ) Ee , MjOfE0 , dummyD1 ! Mjs ( iMode , 1 ) = MjOfE0 !energy(1) = Ee ! iE = int ( Ee / de ) + 1 ! do i = 2 , numOfMjs ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE read ( 1 , '(3ES24.15E3)' ) Ee , MjOfE , dummyD2 !          energy(i) = Ee iE = int ( Ee / de ) + 1 !Vfis(iE0:iE) = VfiOfE0 Mjs ( iMode , i ) = MjOfE !VfiOfE0 = VfiOfE ! write ( 6 , * ) iMode , Mjs ( iMode , i ) enddo ! close ( 1 ) ! endif ! enddo ! !do iE = 0, numOfVfis ! -nEnergies, nEnergies !  write(44,*) energy(iE)*HartreeToEv, Vfis(iE), lsf(iE) !enddo ! !close(44) ! return ! end subroutine readMjs ! ! subroutine lsfDeterministicFourPhononsByFourBands () ! implicit none ! integer :: ic integer :: iMode1 , iMode2 , iMode3 , iMode4 integer :: pm1 , pm2 , pm3 , pm4 ! real ( kind = dp ) :: t1 , t2 ! if ( myid == root ) then write ( iostd , * ) 'Four modes' flush ( iostd ) endif ! ! Four modes ! call cpu_time ( t1 ) ! ic = 0 do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , modes - 2 do iMode3 = iMode2 + 1 , modes - 1 do iMode4 = iMode3 + 1 , modes ! do pm1 = - 1 , 1 , 2 do pm2 = - 1 , 1 , 2 do pm3 = - 1 , 1 , 2 do pm4 = - 1 , 1 , 2 ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 pj ( s2L ( iMode2 )) = pm2 pj ( s2L ( iMode3 )) = pm3 pj ( s2L ( iMode4 )) = pm4 ! call lsfOfConfigurationPj () ! ic = ic + 1 ! enddo enddo enddo enddo ! enddo enddo enddo enddo ! call cpu_time ( t2 ) ! return ! end subroutine lsfDeterministicFourPhononsByFourBands ! ! subroutine lsfOfConfigurationPj () ! implicit none ! integer :: iE , j ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio ! prodFj = 1.0_dp sumOverj = 0.0_dp do j = 1 , modes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( s2L ( j ))), s2L ( j )) if ( pj ( s2L ( j )) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj endif prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( s2L ( j )) / ( abs ( pj ( s2L ( j ))) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( s2L ( j ))) + 1 , s2L ( j )) / besPj sumOverj = sumOverj + ( abs ( pj ( s2L ( j ))) + x ( s2L ( j )) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! return ! end subroutine lsfOfConfigurationPj ! ! subroutine calculatePlusMinusStates ( l ) ! implicit none ! integer , intent ( in ) :: l ! integer :: iDes , other ( 0 : l - 1 ) ! do iDes = 0 , 2 ** l - 1 ! other (:) = 0 ! call decimalToOther ( iDes , l , 2 , other ) ! pms ( iDes ,:) = other (:) ! enddo ! return ! end subroutine calculatePlusMinusStates ! ! subroutine distrubutePhononsInBands ( m , l ) ! implicit none ! integer , intent ( in ) :: m , l ! integer :: i , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 , i11 , i12 ! if ( l == 1 ) then ! pj0s ( 1 , 1 ) = m ! else if ( l == m - 1 ) then ! do i = 1 , l pj0s ( i ,:) = 1 pj0s ( i , i ) = m - ( l - 1 ) enddo ! else if ( l == m ) then ! pj0s ( 1 ,:) = 1 ! else if ( l == 2 ) then ! do i = 1 , m - 1 ! pj0s ( i , 1 ) = i pj0s ( i , 2 ) = m - i ! enddo ! else if ( l == 3 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 ! i = i + 1 ! endif ! enddo enddo enddo ! !write(6,*) 'l = 3, i = ', i - 1 ! else if ( l == 4 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 ! i = i + 1 ! endif ! enddo enddo enddo enddo !write(6,*) 'l = 4, i = ', i - 1 ! else if ( l == 5 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo ! !write(6,*) 'l = 5, i = ', i - 1 ! else if ( l == 6 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 6, i = ', i - 1 ! else if ( l == 7 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 7, i = ', i ! else if ( l == 8 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 8, i = ', i ! else if ( l == 9 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 10 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 11 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 12 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) do i12 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 + i12 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 pj0s ( i , 12 ) = i12 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo endif ! return ! end subroutine distrubutePhononsInBands ! ! subroutine lsfWithMphonons ( m , l , tTimes ) ! implicit none ! integer , intent ( in ) :: m , l , tTimes ! integer :: ii ! integer :: iMC , iM , i , pick , j , picks ( l ), iE , iDes , iRand , steps ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio , randy ! logical :: picked ! if ( myid == root ) then write ( iostd , '(i4,\" phonons by\", i3, \" bands started.\")' ) m , l flush ( iostd ) endif ! printSteps = int ( ( iModeFs ( myid ) - iModeIs ( myid ) + 1.01_dp ) / 10 ) ! do iMC = iModeIs ( myid ), iModeFs ( myid ) ! if ( mod ( iMC - iModeIs ( myid ) + 1 , printSteps ) == 0 ) then if ( myid == root ) then steps = iModeFs ( myid ) - iModeIs ( myid ) + 1 write ( iostd , '(i4,\" phonons by\", i3,\" bands.\", i12,\" over \",i12,\" MC iters per processor done.\")' ) m , l , iMC , steps flush ( iostd ) endif endif ! picks (:) = 0 ! if ( istat == 0 ) then ! do iM = 1 , l picked = . false . 10 read ( un ) iRand iRand = mod ( abs ( iRand ), modes ) + 1 do i = 1 , iM - 1 if ( picks ( i ) == iRand ) goto 10 enddo picks ( iM ) = iRand ! enddo ! else ! do iM = 1 , l picked = . false . ! 11 CALL RANDOM_NUMBER ( randy ) ! pick = int ( modes * randy ) + 1 do i = 1 , l if ( pick . eq . picks ( i ) ) picked = . true . enddo if ( picked ) goto 11 picks ( iM ) = pick enddo ! endif ! do ii = 1 , tTimes ! do iDes = 0 , 2 ** l - 1 ! pj (:) = 0 ! do iM = 1 , l pj ( s2L ( picks ( iM ))) = pj0s ( ii , iM ) * ( - 1 ) ** ( pms ( iDes , iM - 1 )) enddo ! if ( abs ( sum ( abs ( pj ( picks (:)))) - m ) > 0 ) then if ( myid == root ) then write ( iostd , * ) 'ERROR' , m , sum ( abs ( pj ( s2L ( picks (:))))), pj ( s2L ( picks (:))) do iM = 1 , l if ( abs ( pj ( picks ( iM ))) < 1 ) then write ( iostd , * ) 'ERROR 1' , picks ( iM ) write ( iostd , * ) 'ERROR 2' , pj ( s2L ( picks ( iM ))) flush ( iostd ) endif enddo endif endif ! prodFj = 1.0_dp sumOverj = 0.0_dp ! do j = 1 , modes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( s2L ( j ))), s2L ( j )) if ( pj ( s2L ( j )) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj endif ! prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( s2L ( j )) / ( abs ( pj ( s2L ( j ))) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( s2L ( j ))) + 1 , s2L ( j )) / besPj ! sumOverj = sumOverj + ( abs ( pj ( s2L ( j ))) + x ( s2L ( j )) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) ! iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! enddo ! enddo ! enddo ! if ( myid == root ) then write ( iostd , '(\"---------------------------------------------\")' ) write ( iostd , '(i4,\" phonons by\", i3, \" bands done.\")' ) m , l flush ( iostd ) endif ! return ! end subroutine lsfWithMphonons ! ! subroutine decimalToOther ( iDec , n , iBase , other ) ! implicit none ! integer , intent ( in ) :: n , iBase integer :: iDec , m integer :: other ( 0 : n - 1 ), j ! m = iDec do j = n - 1 , 1 , - 1 other ( j ) = int ( m / ( iBase ** j )) m = mod ( iDec , iBase ** j ) enddo other ( 0 ) = mod ( m , iBase ) ! return ! end subroutine decimalToOther ! ! subroutine calculateDE ( maxM , iEbins , de ) ! implicit none ! integer , intent ( in ) :: maxM , iEbins ( - nEnergies : nEnergies ) real ( dp ), intent ( out ) :: de ! integer :: iE , j , ic , ib , iEmMax , nSteps , jMax , iEstep ! integer , allocatable :: tmpB (:), iEsteps (:) ! logical :: empty ! allocate ( tmpB ( nEnergies ) ) ! ic = 1 do j = 1 , nEnergies if ( mod ( nEnergies , j ) == 0 ) then tmpB ( ic ) = int (( dble ( nEnergies ) + 1.e-8_dp ) / j ) ic = ic + 1 endif enddo ! nSteps = ic - 1 allocate ( iEsteps ( nSteps ) ) iEsteps (:) = tmpB ( nSteps : 1 : - 1 ) deallocate ( tmpB ) ! iEmMax = int ( maxM * maxval ( phonF (:)) / deltaE ) + 1 ! j = 1 do while ( ( iEmMax > iEsteps ( j ) ) . and . ( j < nSteps ) ) j = j + 1 enddo ! jMax = j - 1 if ( jMax > nSteps ) jMax = nSteps ! empty = . true . j = jMax do while ( ( empty . eqv . . true . ) . and . ( j > 1 ) ) ! empty = . true . iEstep = iEsteps ( j ) do iE = 1 , iEmMax - 1 , iEstep ib = sum ( iEbins ( iE : iE + iEstep - 1 ) ) if ( ib < 1 ) then empty = . false . endif enddo j = j - 1 ! enddo ! j = j + 2 ! iEstep = iEsteps ( j ) de = deltaE * real ( iEstep , dp ) ! deallocate ( iEsteps ) ! return ! end subroutine calculateDE ! ! subroutine lsfMbyOneBand ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , pm1 ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do iMode1 = 1 , modes ! do pm1 = - m , m , 2 * m ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 ! call lsfOfConfigurationPj () ! enddo ! enddo ! call cpu_time ( t2 ) ! write ( iostd , '(\" LSF of: \", i4, \" phonons using one band done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) ! return ! end subroutine lsfMbyOneBand ! ! subroutine lsfMbyTwoBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , iMode2 , pm1 , pm2 , l ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do l = 1 , m - 1 ! do iMode1 = 1 , modes - 1 do iMode2 = iMode1 + 1 , modes ! do pm1 = - l , l , 2 * l do pm2 = - ( m - l ), ( m - l ), 2 * ( m - l ) ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 pj ( s2L ( iMode2 )) = pm2 ! call lsfOfConfigurationPj () ! enddo enddo ! enddo enddo ! enddo ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using two bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyTwoBands ! ! subroutine lsfMbyThreeBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! real ( dp ) :: t1 , t2 , times3 integer :: iMode1 , iMode2 , iMode3 , ni , mi , iDes , ii ! call cpu_time ( t1 ) ! times3 = 1.0_dp mi = 2 do ni = m - 1 , m - 3 + 1 , - 1 times3 = times3 * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times3 + 1.e-3_dp ), 3 ) ) pj0s (:,:) = 0 ! call distrubutePhononsInBands ( m , 3 ) ! allocate ( pms ( 0 : 2 ** 3 - 1 , 0 : 3 - 1 ) ) pms (:,:) = 0 ! call calculatePlusMinusStates ( 3 ) ! do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , modes - 1 do iMode3 = iMode2 + 1 , modes ! do ii = 1 , int ( times3 + 1.e-3_dp ) ! do iDes = 0 , 2 ** 3 - 1 ! pj (:) = 0 ! pj ( s2L ( iMode1 )) = pj0s ( ii , 1 ) * ( - 1 ) ** ( pms ( iDes , 1 - 1 )) pj ( s2L ( iMode2 )) = pj0s ( ii , 2 ) * ( - 1 ) ** ( pms ( iDes , 2 - 1 )) pj ( s2L ( iMode3 )) = pj0s ( ii , 3 ) * ( - 1 ) ** ( pms ( iDes , 3 - 1 )) ! call lsfOfConfigurationPj () ! enddo ! enddo ! enddo enddo enddo ! deallocate ( pj0s , pms ) ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using three bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyThreeBands ! ! subroutine writeLSFandCrossSection () ! implicit none ! integer :: iE real ( kind = dp ) :: E !, vg ! open ( 1 , file = 'lsfVsE' , status = 'unknown' ) ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) ! !write(1,'(F16.8,2E18.6e3)') E*HartreeToEv, lsfVsE(iE), twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg write ( 1 , '(F16.8,E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ) !, twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! enddo ! close ( 1 ) ! return ! end subroutine writeLSFandCrossSection ! ! subroutine init_random_seed () ! implicit none ! integer ( kind = int32 ), allocatable :: seed (:) integer ( kind = int32 ) :: n !, i, n, dt(8), pid integer :: t ! call random_seed ( size = n ) ! allocate ( seed ( n )) ! ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. ! call system_clock ( t ) ! seed = 5347 ! !    if (t == 0) then !      call date_and_time(values=dt) !      t = (dt(1) - 1970) * 365 * 24 * 60 * 60 * 1000 & !          + dt(2) * 31 * 24 * 60 * 60 * 1000 & !          + dt(3) * 24 * 60 * 60 * 1000 & !          + dt(5) * 60 * 60 * 1000 & !          + dt(6) * 60 * 1000 + dt(7) * 1000 & !          + dt(8) !    end if !    pid = getpid() !    t = ieor(t, int(pid, kind(t))) !    do i = 1, n !      seed(i) = lcg(t) !    end do !    ! call random_seed ( put = seed ) ! end subroutine init_random_seed ! ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. ! integer function lcg ( s ) ! integer :: s ! if ( s == 0 ) then s = 104729 else !s = mod(s, 4294967296) s = mod ( s , 4294967 ) end if ! !s = mod(s * 279470273, 4294967291) s = mod ( s * 279470273 , 4294967 ) ! lcg = int ( mod ( s , huge ( 0 )), kind ( 0 )) ! end function lcg ! ! subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !c*********************************************************************72 !c !cc IKNB compute Bessel function In(x) and Kn(x). !c !c  Discussion: !c !c    Compute modified Bessel functions In(x) and Kn(x), !c    and their derivatives. !c !c  Licensing: !c !c    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !c    they give permission to incorporate this routine into a user program !c    provided that the copyright is acknowledged. !c !c  Modified: !c !c    17 July 2012 !c !c  Author: !c !c    Shanjie Zhang, Jianming Jin !c !c  Reference: !c !c    Shanjie Zhang, Jianming Jin, !c    Computation of Special Functions, !c    Wiley, 1996, !c    ISBN: 0-471-11963-6, !c    LC: QA351.C45. !c !c  Parameters: !c !c    Input, integer N, the order of In(x) and Kn(x). !c !c    Input, double precision X, the argument. !c !c    Output, integer NM, the highest order computed. !c !c    Output, double precision BI(0:N), DI(0:N), BK(0:N), DK(0:N), !c    the values of In(x), In'(x), Kn(x), Kn'(x). !c implicit none integer , intent ( in ) :: n !      double precision :: a0 double precision :: bi ( 0 : n ) !      double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: f0 double precision :: f1 !      double precision :: g !      double precision :: g0 !      double precision :: g1 integer :: k !      integer :: k0 !      integer :: l integer :: m , ik !      integer :: msta1 !      integer :: msta2 integer :: nm double precision :: pi !      double precision :: r double precision :: s0 double precision :: sk0 !      double precision :: vt double precision :: x , ifact pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n if ( x . le . 1.0D-15 ) then do k = 0 , n ifact = 1.0_dp do ik = 2 , k ifact = ifact * ik enddo bi ( k ) = ( 0.5_dp * x ) ** k / ifact end do return end if if ( n . eq . 0 ) then nm = 1 end if m = msta1 ( x , 200 ) if ( m . lt . nm ) then nm = m else m = msta2 ( x , nm , 15 ) end if bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 if ( k . le . nm ) then bi ( k ) = f end if if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then sk0 = sk0 + 4.0D+00 * f / k end if bs = bs + 2.0D+00 * f f0 = f1 f1 = f end do s0 = exp ( x ) / ( bs - f ) do k = 0 , nm bi ( k ) = s0 * bi ( k ) end do return end SUBROUTINE iknb ! ! SUBROUTINE iknb2 ( n , x , nm , bi , di , bk , dk ) ! !    ============================================================ !    Purpose: Compute modified Bessel functions In(x) and Kn(x), !             and their derivatives !    Input:   x --- Argument of In(x) and Kn(x) ( 0 ó x ó 700 ) !             n --- Order of In(x) and Kn(x) !    Output:  BI(n) --- In(x) !             DI(n) --- In'(x) !             BK(n) --- Kn(x) !             DK(n) --- Kn'(x) !             NM --- Highest order computed !    Routines called: !             MSTA1 and MSTA2 for computing the starting point !             for backward recurrence !    =========================================================== ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( OUT ) :: nm REAL ( dp ), INTENT ( OUT ) :: bi ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: di ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: bk ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: dk ( 0 : n ) ! REAL ( dp ), PARAMETER :: pi = 3.141592653589793_dp , el = 0.5772156649015329_dp REAL ( dp ) :: a0 , bkl , bs , f , f0 , f1 , g , g0 , g1 , r , s0 , sk0 , vt INTEGER :: k , k0 , l , m ! nm = n IF ( x <= 1.0D-50 ) THEN DO k = 0 , n bi ( k ) = 0.0D0 di ( k ) = 0.0D0 bk ( k ) = 1.0D+300 dk ( k ) = - 1.0D+300 END DO bi ( 0 ) = 1.0D0 di ( 1 ) = 0.5D0 RETURN END IF IF ( n == 0 ) nm = 1 m = msta1 ( x , 200 ) IF ( m < nm ) THEN nm = m ELSE m = msta2 ( x , nm , 15 ) END IF !write(6,*)'mmmmmmmmm', m bs = 0.0D0 sk0 = 0.0D0 f0 = 0.0D0 f1 = 1.0D-100 DO k = m , 0 , - 1 f = 2 * ( k + 1 ) / x * f1 + f0 IF ( k <= nm ) bi ( k ) = f IF ( k /= 0 . AND . k == 2 * INT ( k / 2 )) sk0 = sk0 + 4.0D0 * f / k bs = bs + 2.0D0 * f f0 = f1 f1 = f END DO !s0 = EXP(x) / (bs-f) !write(6,*) f, f1 s0 = EXP ( x ) / ( bs - f1 ) bi ( 0 : nm ) = s0 * bi ( 0 : nm ) IF ( x <= 8.0D0 ) THEN bk ( 0 ) = - ( LOG ( 0.5D0 * x ) + el ) * bi ( 0 ) + s0 * sk0 bk ( 1 ) = ( 1.0D0 / x - bi ( 1 ) * bk ( 0 )) / bi ( 0 ) ELSE a0 = SQRT ( pi / ( 2.0D0 * x )) * EXP ( - x ) k0 = 16 IF ( x >= 2 5.0 ) k0 = 10 IF ( x >= 8 0.0 ) k0 = 8 IF ( x >= 20 0.0 ) k0 = 6 DO l = 0 , 1 bkl = 1.0D0 vt = 4 * l r = 1.0D0 DO k = 1 , k0 r = 0.125D0 * r * ( vt - ( 2 * k - 1 ) ** 2 ) / ( k * x ) bkl = bkl + r END DO bk ( l ) = a0 * bkl END DO END IF g0 = bk ( 0 ) g1 = bk ( 1 ) DO k = 2 , nm g = 2 * ( k - 1 ) / x * g1 + g0 bk ( k ) = g g0 = g1 g1 = g END DO di ( 0 ) = bi ( 1 ) dk ( 0 ) = - bk ( 1 ) DO k = 1 , nm di ( k ) = bi ( k - 1 ) - k / x * bi ( k ) dk ( k ) = - bk ( k - 1 ) - k / x * bk ( k ) END DO RETURN ! END SUBROUTINE iknb2 ! ! FUNCTION msta1 ( x , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that the magnitude of !                Jn(x) at that point is about 10&#94;(-MP) !       Input :  x     --- Argument of Jn(x) !                MP    --- Value of magnitude !       Output:  MSTA1 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , f , f0 , f1 INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) n0 = INT ( 1.1 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - mp IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn ! RETURN ! END FUNCTION msta1 ! ! FUNCTION msta2 ( x , n , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that all Jn(x) has MP !                significant digits !       Input :  x  --- Argument of Jn(x) !                n  --- Order of Jn(x) !                MP --- Significant digit !       Output:  MSTA2 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) hmp = 0.5_dp * mp ejn = envj ( n , a0 ) IF ( ejn <= hmp ) THEN obj = mp n0 = INT ( 1.1 * a0 ) ELSE obj = hmp + ejn n0 = n END IF !!!!!!!! if ( n0 < 1 ) n0 = 1 !!!!!!!! f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj ! DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - obj IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn + 10 ! RETURN ! END FUNCTION msta2 ! ! FUNCTION envj ( n , x ) RESULT ( fn_val ) ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val ! fn_val = 0.5_dp * LOG10 ( 6.28_dp * n ) - n * LOG10 ( 1.36_dp * x / n ) ! RETURN ! END FUNCTION envj ! ! subroutine parallelIsFsBy3 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = modes / 6.0_dp totalStates = totalStates * ( modes - 1 ) * ( modes - 2 ) ! if ( modes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = modes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) / 2.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 2.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = modes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = modes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = modes - 2 ! else ! nProcMax = modes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! write ( 6 , * ) iModeIs (:), iModeFs (:) ! return ! end subroutine parallelIsFsBy3 ! ! subroutine parallelIsFsBy4 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = modes / 2 4.0_dp totalStates = totalStates * ( modes - 1 ) * ( modes - 2 ) * ( modes - 3 ) ! if ( modes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = modes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 6.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) * real ( iState - 4 , dp ) / 6.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = modes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = modes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = modes - 2 ! else ! nProcMax = modes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy4 ! ! end module lsf","tags":"","loc":"sourcefile/lsf_linear_module_v1.f90.html","title":"LSF_linear_Module_v1.f90 – Carrier Cross Sections"},{"text":"Contents Programs crossSection Source Code Sigma_Main.f90 Source Code program crossSection ! use sigma_module ! implicit none ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call calculateSigma () ! call writeSigma () ! end program crossSection","tags":"","loc":"sourcefile/sigma_main.f90.html","title":"Sigma_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules sigma_module Source Code Sigma_Module_v4.f90 Source Code module sigma_module ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: iostd = 16 ! real ( kind = dp ), parameter :: maxEnergy = 1 0.0_dp integer , parameter :: nOfEnergyBins = 5040 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer ( kind = int32 ) :: ios integer :: nEnergies , m , numOfVfis ! real ( kind = dp ) :: volume , de , eifMin , DHifMin ! real ( kind = dp ), allocatable :: E (:), Vfis (:), lsfVsE (:), lsfVsEbyPhonon (:), energy (:), lsf (:) real ( kind = dp ), allocatable :: sigma (:), sigmaByPhonon (:), lorentz (:), lorentzByPhonon (:) ! character ( len = 11 ), parameter :: output = 'sigmaStatus' character ( len = 256 ) :: VfisInput , LSFinput , crossSectionOutput ! logical :: file_exists ! namelist / elphscat / VfisInput , LSFinput , crossSectionOutput ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if an output file exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , elphscat , iostat = ios ) ! call checkInputAndUpdateParameters () ! call readLSF () ! call readVfis () ! return ! end subroutine readInputs ! ! subroutine initialize () ! implicit none ! VfisInput = '' LSFinput = '' crossSectionOutput = '' ! de = maxEnergy * eVToHartree / real ( nOfEnergyBins , dp ) ! return ! end subroutine initialize ! ! subroutine checkInputAndUpdateParameters () ! implicit none ! if ( VfisInput == '' ) then write ( iostd , '(\" Vfi elements input (input variable VfisInput) is not defined!\")' ) else inquire ( file = trim ( VfisInput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" Vfi elements input : \", a)' ) trim ( VfisInput ) else write ( iostd , '(\" Vfi elements input : \", a, \" does not exist!\")' ) trim ( VfisInput ) endif endif ! if ( LSFinput == '' ) then write ( iostd , '(\" LSF input (input variable LSFinput) is not defined!\")' ) else inquire ( file = trim ( LSFinput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" LSF input : \", a)' ) trim ( LSFinput ) else write ( iostd , '(\" LSF input : \", a, \" does not exist!\")' ) trim ( LSFinput ) endif endif ! if ( crossSectionOutput == '' ) then write ( iostd , '(\" crossSectionOutput is not defined! File name : crossSection, will be used.\")' ) crossSectionOutput = 'crossSection' else write ( iostd , '(\" Cross section output file name : \", a)' ) trim ( crossSectionOutput ) endif ! if ( ( VfisInput == '' ) . or . ( LSFinput == '' ) ) then ! write ( iostd , '(\" One or both of the input files is not defined! \")' ) write ( iostd , '(\" ********************************************** \")' ) write ( iostd , '(\" *               Program stops!               * \")' ) write ( iostd , '(\" *       Please check the output file.        * \")' ) write ( iostd , '(\" ********************************************** \")' ) ! stop ! endif ! flush ( iostd ) ! return ! end subroutine checkInputAndUpdateParameters ! ! subroutine readLSF () ! implicit none ! character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! real ( kind = dp ) :: ee ! integer :: iE ! open ( 1 , file = trim ( LSFinput ), status = 'old' ) ! read ( 1 , '(a1, i10, a9, i5, a8)' ) dummyC1 , nEnergies , dummyC9 , m , dummyC8 ! allocate ( E ( - nEnergies : nEnergies ), lsfVsE ( - nEnergies : nEnergies ), lsfVsEbyPhonon ( - nEnergies : nEnergies ) ) ! do iE = - nEnergies , nEnergies ! read ( 1 , '(F16.8,2E18.6e3)' ) ee , lsfVsE ( iE ), lsfVsEbyPhonon ( iE ) E ( iE ) = ee * eVToHartree ! enddo ! close ( 1 ) ! end subroutine readLSF ! ! subroutine readVfis () ! implicit none ! integer :: i , iE0 , iE real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , VfiOfE , VfiOfE0 , eBin character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 ! open ( 1 , file = trim ( VfisInput ), status = \"old\" ) ! !read(1, '(a1, i10, a9, f15.4, a16)') dummyC1, nEVfi, dummyC9, volume, dummyC16 ! read ( 1 , * ) read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 read ( 1 , * ) ! read ( 1 , '(i10)' ) numOfVfis ! allocate ( Vfis ( 0 : numOfVfis ), energy ( 0 : numOfVfis ), lsf ( 0 : numOfVfis ) ) ! Vfis (:) = 0.0_dp energy (:) = 0.0_dp lsf (:) = 0.0_dp ! read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE0 , dummyD1 ! Vfis ( 1 ) = VfiOfE0 energy ( 1 ) = Ee ! iE = int ( Ee / de ) + 1 ! do i = 2 , numOfVfis ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE , dummyD2 energy ( i ) = Ee iE = int ( Ee / de ) + 1 !Vfis(iE0:iE) = VfiOfE0 Vfis ( i ) = VfiOfE !VfiOfE0 = VfiOfE lsf ( i - 1 ) = sum ( lsfVsE ( iE0 : iE )) / ( iE - iE0 + 1 ) write ( 26 , * ) E ( iE0 ), Ee , lsf ( i ) ! sum(lsfVsE(iE0:iE))/(iE-iE0+1) ! enddo ! close ( 1 ) close ( 26 ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies write ( 44 , * ) energy ( iE ) * HartreeToEv , Vfis ( iE ), lsf ( iE ) enddo ! close ( 44 ) ! return ! end subroutine readVfis ! ! subroutine calculateSigma () ! implicit none ! integer :: iE real ( kind = dp ) :: vg , sigma0 ! allocate ( sigma ( numOfVfis ) ) ! , sigmaByPhonon(-nEnergies:nEnergies) ) !allocate( sigma(-nEnergies:nEnergies), sigmaByPhonon(-nEnergies:nEnergies) ) ! iE = int ( eifMin / de ) + 1 write ( 6 , * ) eifMin , eifMin * HartreeToEv , iE sigma0 = twoPi * abCM ** 2 * volume * DHifMin * lsfVsE ( iE ) / sqrt ( 2.0_dp * E ( iE )) ! !do iE = 1, numOfVfis ! -nEnergies, nEnergies - 1 !  if ( (E(iE) < eifMin).and.(E(iE+1) > eifMin) ) sigma0 = twoPi*abCM**2*volume*DHifMin*lsfVsE(iE)/sqrt(2.0_dp*E(iE)) !enddo ! write ( 6 , * ) eifMin * HartreeToEv , sigma0 ! sigma (:) = 0.0_dp ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies vg = 1.0_dp if ( energy ( iE ) > 0.0_dp ) vg = sqrt ( 2.0_dp * energy ( iE )) !write(6,*) iE, energy(iE), vg, Vfis(iE), lsf(iE) sigma ( iE ) = twoPi * abCM ** 2 * volume * Vfis ( iE ) * lsf ( iE ) / vg !sigma(iE)         = twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg !sigmaByPhonon(iE) = twoPi*abCM**2*volume*Vfis(iE)*lsfVsEbyPhonon(iE)/vg enddo ! return ! end subroutine calculateSigma ! ! subroutine writeSigma () ! implicit none ! integer :: iE ! open ( 2 , file = trim ( crossSectionOutput ), status = 'unknown' ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies ! write ( 2 , * ) energy ( iE ) * HartreeToEv , sigma ( iE ) !, sigmaByPhonon(iE) !write(2,*) E(iE), sigma(iE), sigmaByPhonon(iE) ! enddo ! close ( 2 ) ! return ! end subroutine writeSigma ! ! end module sigma_module","tags":"","loc":"sourcefile/sigma_module_v4.f90.html","title":"Sigma_Module_v4.f90 – Carrier Cross Sections"},{"text":"type, public :: atom Define a new type to represent an atom in the structure. \n Each different type of atom in the structure will be another\n variable with the type atom . Contents Variables iRc numOfAtoms lMax lmMax nMax symbol lps bes_J_qr F F1 F2 r rab wae wps Source Code atom Components Type Visibility Attributes Name Initial integer, public :: iRc integer, public :: numOfAtoms Number of atoms of a specific type in the structure integer, public :: lMax integer, public :: lmMax integer, public :: nMax character(len=2), public :: symbol integer, public, allocatable :: lps (:) real(kind=dp), public, allocatable :: bes_J_qr (:,:) real(kind=dp), public, allocatable :: F (:,:) real(kind=dp), public, allocatable :: F1 (:,:,:) real(kind=dp), public, allocatable :: F2 (:,:,:) real(kind=dp), public, allocatable :: r (:) real(kind=dp), public, allocatable :: rab (:) real(kind=dp), public, allocatable :: wae (:,:) real(kind=dp), public, allocatable :: wps (:,:) Source Code type :: atom !! Define a new type to represent an atom in the structure. !! Each different type of atom in the structure will be another !! variable with the type `atom`. ! ! Define scalar integers integer :: iRc integer :: numOfAtoms !! Number of atoms of a specific type in the structure integer :: lMax integer :: lmMax integer :: nMax ! ! Define scalar character character ( len = 2 ) :: symbol ! ! Define matrix/vector integer integer , allocatable :: lps (:) ! ! Define matrix/vector reals real ( kind = dp ), allocatable :: bes_J_qr (:,:) real ( kind = dp ), allocatable :: F (:,:) real ( kind = dp ), allocatable :: F1 (:,:,:) real ( kind = dp ), allocatable :: F2 (:,:,:) real ( kind = dp ), allocatable :: r (:) real ( kind = dp ), allocatable :: rab (:) real ( kind = dp ), allocatable :: wae (:,:) real ( kind = dp ), allocatable :: wps (:,:) ! end type atom","tags":"","loc":"type/atom.html","title":"atom – Carrier Cross Sections "},{"text":"type, public :: vec Contents Variables ind igN igM Source Code vec Components Type Visibility Attributes Name Initial integer, public :: ind integer, public, allocatable :: igN (:) integer, public, allocatable :: igM (:) Source Code type :: vec ! integer :: ind integer , allocatable :: igN (:) integer , allocatable :: igM (:) end type vec","tags":"","loc":"type/vec.html","title":"vec – Carrier Cross Sections "},{"text":"public subroutine write_restart_wfc(iuni, exportDir, ik, nk, kunit, ispin, nspin, scal, wf0, t0, wfm, tm, ngw, gamma_only, nbnd, igl, ngwl) Uses mp_wave mp mp_pools mp_world io_global iotk_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: iuni character(len=256), intent(in) :: exportDir integer, intent(in) :: ik integer, intent(in) :: nk integer, intent(in) :: kunit integer, intent(in) :: ispin integer, intent(in) :: nspin real(kind=DP), intent(in) :: scal complex(kind=DP), intent(in) :: wf0 (:,:) logical, intent(in) :: t0 complex(kind=DP), intent(in) :: wfm (:,:) logical, intent(in) :: tm integer, intent(in) :: ngw logical, intent(in) :: gamma_only integer, intent(in) :: nbnd integer, intent(in) :: igl (:) integer, intent(in) :: ngwl Contents None","tags":"","loc":"proc/write_restart_wfc.html","title":"write_restart_wfc – Carrier Cross Sections"},{"text":"subroutine write_export(pp_file, exportDir, kunit) Uses iotk_module kinds pwcom start_k control_flags global_version becmod uspp wavefunctions_module io_files io_files io_base_export io_global ions_base mp_pools mp mp_world upf_module pseudo_types radial_grids wvfct paw_variables paw_onecenter paw_symmetry uspp_param uspp scf Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: pp_file character(len=256), intent(in) :: exportDir integer, intent(in) :: kunit Contents Source Code write_export Source Code SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export","tags":"","loc":"proc/write_export.html","title":"write_export – Carrier Cross Sections"},{"text":"public subroutine readInput() Delete any previous output, initialize input variables,\n start a timer, and read in the input files Todo Change readInput() to have arguments to make clear that these variables are getting changed Start a timer Check if file output exists,\n and delete it if it does Open new output file Set default values for input variables Read input from command line (or input file if use < TME_Input.md ) Check that all required variables were input and have values that make sense Todo Figure out what the difference in PC and SD is * Read PC inputs\n * Read SD inputs Calculate the number of plane waves as the maximum of the number of PC and SD plane waves Arguments None Contents Source Code readInput Source Code subroutine readInput () !! Delete any previous output, initialize input variables, !! start a timer, and read in the input files !! !! @todo Change `readInput()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! logical :: file_exists !! Whether or not the output file already exists !! @todo Change `file_exists` to `fileExists` in `readInput()` @endtodo ! call cpu_time ( t0 ) !! * Start a timer ! inquire ( file = output , exist = file_exists ) !! * Check if file output exists, if ( file_exists ) then !! and delete it if it does open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! call initialize () !! * Set default values for input variables ! READ ( 5 , TME_Input , iostat = ios ) !! * Read input from command line (or input file if use `< TME_Input.md`) ! call checkInitialization () !! * Check that all required variables were input and have values that make sense ! !> @todo Figure out what the difference in PC and SD is @endtodo call readInputPC () !! * Read PC inputs call readInputSD () !! * Read SD inputs ! numOfPWs = max ( numOfPWsPC , numOfPWsSD ) !! * Calculate the number of plane waves as the maximum of the number of PC and SD plane waves ! return ! end subroutine readInput","tags":"","loc":"proc/readinput.html","title":"readInput – Carrier Cross Sections"},{"text":"public subroutine initialize() Set default values for all of the input variables\n that can easily be tested to see if they were changed Todo Change initialize() to have arguments to make clear that these variables are getting changed Arguments None Contents Source Code initialize Source Code subroutine initialize () !! Set default values for all of the input variables !! that can easily be tested to see if they were changed !! !! @todo Change `initialize()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! exportDirSD = '' exportDirPC = '' elementsPath = '' VfisOutput = '' ! ki = - 1 kf = - 1 nKpts = - 1 ! eBin = - 1.0_dp ! iBandIinit = - 1 iBandIfinal = - 1 iBandFinit = - 1 iBandFfinal = - 1 ! calculateVfis = . false . ! return ! end subroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkInitialization() Check to see if variables from .in file still\n have the values set in initialize or if they have values that aren't allowed Walkthrough Todo Change checkInitialization() to have arguments to make clear that these variables are getting changed Set the default value of abort execution so that the program\n will only abort if there is an issue with the inputs Write out a header to the output file If the SD export directory variable is blank Output an error message and set abortExecution to true Otherwise Check if the SD export directory exists If the SD export directory doesn't exist Output an error message and set abortExecution to true Output the given SD export directory If the PC export directory variable is blank Output an error message and set abortExecution to true Otherwise Check if the PC export directory exists If the PC export directory doesn't exist Output an error message and set abortExecution to true Output the given PC export directory If the elements path is blank Output a warning message and set the default value to ./ Check if the elements path folder exists already If the elements path folder doesn't already exist Create the directory by writing the mkdir command to a string Then execute the command Output the elements path If iBandIinit , iBandIfinal , iBandFinit , or iBandFfinal is still less than zero Output an error message and set abortExecution to true Then output each of their values If calculateVfis is true and iBandFinit and iBandFfinal are not equal Output an error message and set abortExecution to true Output the value of calculateVfis If the VfisOutput file name is blank Output a warning message and set the default value to VfisVsE Output the value of VfisOutput Todo Check if there is any kind of check on ki and kf . Why was this commented out? If the value of eBin is still less than zero Output a warning message and set the default value to 0.01 eV Output the value of eBin Convert eBin from eV to Hartree If abortExecution was ever set to true Output an error message and stop the program Make the output file available for other processes Arguments None Contents Source Code checkInitialization Source Code subroutine checkInitialization () !! Check to see if variables from .in file still !! have the values set in [[TMEModule(module):initialize(subroutine)]] !! or if they have values that aren't allowed !! !! <h2>Walkthrough</h2> !! !! @todo Change `checkInitialization()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! logical :: file_exists !! Whether or not the exported directory from [[pw_export_for_TME(program)]] !! exists !> !> @todo Change `file_exists` to `fileExists` in `checkInitialization()` @endtodo logical :: abortExecution ! abortExecution = . false . !! * Set the default value of abort execution so that the program !! will only abort if there is an issue with the inputs ! write ( iostd , '(\" Inputs : \")' ) !! * Write out a header to the output file ! !> * If the SD export directory variable is blank !>    * Output an error message and set `abortExecution` to true !> * Otherwise !>    * Check if the SD export directory exists !>    * If the SD export directory doesn't exist !>       * Output an error message and set `abortExecution` to true if ( trim ( exportDirSD ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"exportDirSD\"\" is not defined!\")' ) write ( iostd , '(\" usage : exportDirSD = ''./Export/''\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! else ! inquire ( file = trim ( exportDirSD ), exist = file_exists ) ! if ( file_exists . eqv . . false . ) then ! write ( iostd , '(\" exportDirSD :\", a, \" does not exist !\")' ) trim ( exportDirSD ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! endif ! write ( iostd , '(\"exportDirSD = ''\", a, \"''\")' ) trim ( exportDirSD ) !! * Output the given SD export directory ! !> * If the PC export directory variable is blank !>    * Output an error message and set `abortExecution` to true !> * Otherwise !>    * Check if the PC export directory exists !>    * If the PC export directory doesn't exist !>       * Output an error message and set `abortExecution` to true if ( trim ( exportDirPC ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"exportDirPC\"\" is not defined!\")' ) write ( iostd , '(\" usage : exportDirPC = ''./Export/''\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! else ! inquire ( file = trim ( exportDirPC ), exist = file_exists ) ! if ( file_exists . eqv . . false . ) then ! write ( iostd , '(\" exportDir :\", a, \" does not exist !\")' ) trim ( exportDirPC ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! endif ! write ( iostd , '(\"exportDirPC = ''\", a, \"''\")' ) trim ( exportDirPC ) !! * Output the given PC export directory ! !> * If the elements path is blank !>    * Output a warning message and set the default value to `./` if ( trim ( elementsPath ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"elementsPath\"\" is not defined!\")' ) write ( iostd , '(\" usage : elementsPath = ''./''\")' ) write ( iostd , '(\" The current directory will be used as elementsPath.\")' ) elementsPath = './' ! endif ! inquire ( file = trim ( elementsPath ), exist = file_exists ) !! * Check if the elements path folder exists already ! !> * If the elements path folder doesn't already exist !>    * Create the directory by writing the `mkdir` command to a string !>    * Then execute the command if ( . not . file_exists ) then ! write ( mkDir , '(\"mkdir -p \", a)' ) trim ( elementsPath ) ! call system ( mkDir ) ! endif ! write ( iostd , '(\"elementsPath = ''\", a, \"''\")' ) trim ( elementsPath ) !! * Output the elements path ! !............................................................................................... !! * If `iBandIinit`, `iBandIfinal`, `iBandFinit`, or `iBandFfinal` is still less than zero !!    * Output an error message and set `abortExecution` to true !! * Then output each of their values ! if ( iBandIinit < 0 ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"iBandIinit\"\" is not defined!\")' ) write ( iostd , '(\" usage : iBandIinit = 10\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"iBandIinit = \", i4)' ) iBandIinit ! if ( iBandIfinal < 0 ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"iBandIfinal\"\" is not defined!\")' ) write ( iostd , '(\" usage : iBandIfinal = 20\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"iBandIfinal = \", i4)' ) iBandIfinal ! if ( iBandFinit < 0 ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"iBandFinit\"\" is not defined!\")' ) write ( iostd , '(\" usage : iBandFinit = 9\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"iBandFinit = \", i4)' ) iBandFinit ! if ( iBandFfinal < 0 ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"iBandFfinal\"\" is not defined!\")' ) write ( iostd , '(\" usage : iBandFfinal = 9\")' ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"iBandFfinal = \", i4)' ) iBandFfinal ! !............................................................................................... ! !> * If `calculateVfis` is true and `iBandFinit` and `iBandFfinal` are not equal !>    * Output an error message and set `abortExecution` to true if ( ( calculateVfis ) . and . ( iBandFinit /= iBandFfinal ) ) then ! write ( iostd , * ) write ( iostd , '(\" Vfis can be calculated only if the final state is one and only one!\")' ) write ( iostd , '(\" ''iBandFInit'' = \", i10)' ) iBandFinit write ( iostd , '(\" ''iBandFfinal'' = \", i10)' ) iBandFfinal write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"calculateVfis = \", l )' ) calculateVfis !! * Output the value of `calculateVfis` ! !> * If the `VfisOutput` file name is blank !>    * Output a warning message and set the default value to `VfisVsE` if ( trim ( VfisOutput ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"VfisOutput\"\" is not defined!\")' ) write ( iostd , '(\" usage : VfisOutput = ''VfisVsE''\")' ) write ( iostd , '(\" The default value ''VfisVsE'' will be used.\")' ) VfisOutput = 'VfisVsE' ! endif ! write ( iostd , '(\"VfisOutput = ''\", a, \"''\")' ) trim ( VfisOutput ) !! * Output the value of `VfisOutput` !> @todo Check if there is any kind of check on `ki` and `kf`. Why was this commented out? @endtodo ! !if ( ki < 0 ) then !  write(iostd, *) !  write(iostd, '(\" Initial k-point index is not defined!\")') !  write(iostd, '(\" Variable : \"\"ki\"\" is not defined!\")') !  write(iostd, '(\" usage : ki = 1\")') !  !write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  !abortExecution = .true. !  write(iostd, '(\" ki = 1 will be used.\")') !  ki = 1 !endif ! !if ( kf < 0 ) then !  write(iostd, *) !  write(iostd, '(\" Final k-point index is not defined!\")') !  write(iostd, '(\" Variable : \"\"kf\"\" is not defined!\")') !  write(iostd, '(\" usage : kf = 1\")') !  !write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  write(iostd, '(\" kf = total number of k-points will be used.\")') !  !abortExecution = .true. !endif ! !if ( ki /= kf ) then !  write(iostd, *) !  write(iostd, '(\" Initial k-point index ''ki'', should be equal to the Final k-point index ''kf'' !\")') !  write(iostd, '(\" Calculation of transition matrix elements with momentum transfer is not implemented!\")') !  write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  abortExecution = .true. !endif ! !> * If the value of `eBin` is still less than zero !>    * Output a warning message and set the default value to 0.01 eV if ( eBin < 0.0_dp ) then ! write ( iostd , '(\" Variable : \"\"eBin\"\" is not defined!\")' ) write ( iostd , '(\" usage : eBin = 0.01\")' ) write ( iostd , '(\" A default value of 0.01 eV will be used !\")' ) eBin = 0.01_dp ! eV ! endif ! write ( iostd , '(\"eBin = \", f8.4, \" (eV)\")' ) eBin !! * Output the value of eBin ! eBin = eBin * evToHartree !! * Convert `eBin` from eV to Hartree ! !> * If `abortExecution` was ever set to true !>    * Output an error message and stop the program if ( abortExecution ) then write ( iostd , '(\" Program stops!\")' ) stop endif ! flush ( iostd ) !! * Make the output file available for other processes ! return ! end subroutine checkInitialization","tags":"","loc":"proc/checkinitialization.html","title":"checkInitialization – Carrier Cross Sections"},{"text":"public subroutine readInputPC() Read input files in the Export directory created by pw_export_for_TME Walkthrough Todo Change readInputPC() to have arguments so that it is clear that these variables are getting changed Todo Change file_exists to fileExists in readInputPC() * Start a local timer Output header to output file Set the path for the input file from the PC export directory Check if the input file from the PC export directory exists If the input file doesn't exist Output an error message and end the program Open and read the input file Todo Add information about these variables to top Calculate F , F1 , and F2 using the all-electron and psuedowvefunctions Todo Look more into how AE and PS wavefunctions are combined to further understand this Todo Move this behavior to another subroutine for clarity Close the input file Go through the lps values for each projector for each atom\n and find the max to store in JMAX End the local timer and write out the total time to read the inputs\n to the output file Arguments None Contents Source Code readInputPC Source Code subroutine readInputPC () !! Read input files in the Export directory created by !! [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! !! @todo Change `readInputPC()` to have arguments so that it is clear that these variables are getting changed @endtodo ! implicit none ! !integer, intent(in) :: id ! integer :: i , j , l , ind , ik , iDum , iType , ni , irc ! real ( kind = dp ) :: t1 , t2 ! character ( len = 300 ) :: textDum ! logical :: file_exists !! Whether or not the `input` file exists in the given !! Export directory !> @todo Change `file_exists` to `fileExists` in `readInputPC()`@endtodo ! call cpu_time ( t1 ) !! * Start a local timer ! !> * Output header to output file write ( iostd , * ) write ( iostd , '(\" Reading perfect crystal inputs.\")' ) write ( iostd , * ) ! inputPC = trim ( trim ( exportDirPC ) // '/input' ) !! * Set the path for the input file from the PC export directory ! inquire ( file = trim ( inputPC ), exist = file_exists ) !! * Check if the input file from the PC export directory exists ! !> * If the input file doesn't exist !>    * Output an error message and end the program if ( file_exists . eqv . . false . ) then ! write ( iostd , '(\" File : \", a, \" , does not exist!\")' ) trim ( inputPC ) write ( iostd , '(\" Please make sure that folder : \", a, \" has been created successfully !\")' ) trim ( exportDirPC ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! !............................................................................................... !> * Open and read the [input](../../pages/inputOutput/input) file !> @todo Add information about these variables to top @endtodo open ( 50 , file = trim ( inputPC ), status = 'old' ) ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nKptsPC !if ( kf < 0 ) kf = nKptsPC ! read ( 50 , '(a)' ) textDum ! allocate ( npwsPC ( nKptsPC ), wkPC ( nKptsPC ), xkPC ( 3 , nKptsPC ) ) ! do ik = 1 , nKptsPC ! read ( 50 , '(3i10,4ES24.15E3)' ) iDum , iDum , npwsPC ( ik ), wkPC ( ik ), xkPC ( 1 : 3 , ik ) ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! numOfGvecs ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfPWsPC ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! fftxMin, fftxMax, fftyMin, fftyMax, fftzMin, fftzMax !read(50, '(6i10)') fftxMin, fftxMax, fftyMin, fftyMax, fftzMin, fftzMax ! read ( 50 , '(a)' ) textDum read ( 50 , * ) read ( 50 , * ) read ( 50 , * ) ! read ( 50 , '(a)' ) textDum read ( 50 , * ) read ( 50 , * ) read ( 50 , * ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nIonsPC ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfTypesPC ! allocate ( posIonPC ( 3 , nIonsPC ), TYPNIPC ( nIonsPC ) ) ! read ( 50 , '(a)' ) textDum ! do ni = 1 , nIonsPC ! read ( 50 , '(i10, 3ES24.15E3)' ) TYPNIPC ( ni ), ( posIonPC ( j , ni ) , j = 1 , 3 ) ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! read ( 50 , '(a)' ) textDum read ( 50 , * ) ! allocate ( atomsPC ( numOfTypesPC ) ) ! nProjsPC = 0 ! do iType = 1 , numOfTypesPC ! read ( 50 , '(a)' ) textDum read ( 50 , * ) atomsPC ( iType )% symbol ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atomsPC ( iType )% numOfAtoms ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atomsPC ( iType )% lMax ! number of projectors ! allocate ( atomsPC ( iType )% lps ( atomsPC ( iType )% lMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , atomsPC ( iType )% lMax ! read ( 50 , '(2i10)' ) l , ind atomsPC ( iType )% lps ( ind ) = l ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atomsPC ( iType )% lmMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(2i10)' ) atomsPC ( iType )% nMax , atomsPC ( iType )% iRc ! allocate ( atomsPC ( iType )% r ( atomsPC ( iType )% nMax ), atomsPC ( iType )% rab ( atomsPC ( iType )% nMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , atomsPC ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) atomsPC ( iType )% r ( i ), atomsPC ( iType )% rab ( i ) ! enddo ! allocate ( atomsPC ( iType )% wae ( atomsPC ( iType )% nMax , atomsPC ( iType )% lMax ) ) allocate ( atomsPC ( iType )% wps ( atomsPC ( iType )% nMax , atomsPC ( iType )% lMax ) ) ! read ( 50 , '(a)' ) textDum do j = 1 , atomsPC ( iType )% lMax do i = 1 , atomsPC ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) atomsPC ( iType )% wae ( i , j ), atomsPC ( iType )% wps ( i , j ) ! write(iostd, '(2i5, ES24.15E3)') j, i, abs(atomsPC(iType)%wae(i, j)-atomsPC(iType)%wps(i, j)) ! enddo enddo ! allocate ( atomsPC ( iType )% F ( atomsPC ( iType )% iRc , atomsPC ( iType )% lMax ) ) !, atomsPC(iType)%lMax) ) allocate ( atomsPC ( iType )% F1 ( atomsPC ( iType )% iRc , atomsPC ( iType )% lMax , atomsPC ( iType )% lMax ) ) allocate ( atomsPC ( iType )% F2 ( atomsPC ( iType )% iRc , atomsPC ( iType )% lMax , atomsPC ( iType )% lMax ) ) ! atomsPC ( iType )% F = 0.0_dp atomsPC ( iType )% F1 = 0.0_dp atomsPC ( iType )% F2 = 0.0_dp ! !> * Calculate `F`, `F1`, and `F2` using the all-electron and psuedowvefunctions !> @todo Look more into how AE and PS wavefunctions are combined to further understand this @endtodo !> @todo Move this behavior to another subroutine for clarity @endtodo do j = 1 , atomsPC ( iType )% lMax ! irc = atomsPC ( iType )% iRc ! atomsPC ( iType )% F ( 1 : irc , j ) = ( atomsPC ( iType )% wae ( 1 : irc , j ) - atomsPC ( iType )% wps ( 1 : irc , j )) * & atomsPC ( iType )% r ( 1 : irc ) * atomsPC ( iType )% rab ( 1 : irc ) ! do i = 1 , atomsPC ( iType )% lMax atomsPC ( iType )% F1 ( 1 : irc , i , j ) = ( atomsPC ( iType )% wps ( 1 : irc , i ) * atomsPC ( iType )% wae ( 1 : irc , j ) - & & atomsPC ( iType )% wps ( 1 : irc , i ) * atomsPC ( iType )% wps ( 1 : irc , j )) * atomsPC ( iType )% rab ( 1 : irc ) ! atomsPC ( iType )% F2 ( 1 : irc , i , j ) = ( atomsPC ( iType )% wae ( 1 : irc , i ) * atomsPC ( iType )% wae ( 1 : irc , j ) - & atomsPC ( iType )% wae ( 1 : irc , i ) * atomsPC ( iType )% wps ( 1 : irc , j ) - & atomsPC ( iType )% wps ( 1 : irc , i ) * atomsPC ( iType )% wae ( 1 : irc , j ) + & & atomsPC ( iType )% wps ( 1 : irc , i ) * atomsPC ( iType )% wps ( 1 : irc , j )) * atomsPC ( iType )% rab ( 1 : irc ) enddo enddo ! nProjsPC = nProjsPC + atomsPC ( iType )% numOfAtoms * atomsPC ( iType )% lmMax ! !      deallocate ( atomsPC(iType)%wae, atomsPC(iType)%wps ) ! enddo ! !............................................................................................... ! close ( 50 ) !! * Close the input file ! !> * Go through the `lps` values for each projector for each atom !> and find the max to store in `JMAX` JMAX = 0 do iType = 1 , numOfTypesPC ! do i = 1 , atomsPC ( iType )% lMax ! if ( atomsPC ( iType )% lps ( i ) > JMAX ) JMAX = atomsPC ( iType )% lps ( i ) ! enddo ! enddo ! maxL = JMAX JMAX = 2 * JMAX + 1 ! do iType = 1 , numOfTypesPC ! allocate ( atomsPC ( iType )% bes_J_qr ( 0 : JMAX , atomsPC ( iType )% iRc ) ) atomsPC ( iType )% bes_J_qr (:,:) = 0.0_dp ! enddo ! !> * End the local timer and write out the total time to read the inputs !> to the output file call cpu_time ( t2 ) write ( iostd , '(\" Reading input files done in:                \", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) flush ( iostd ) ! return ! end subroutine readInputPC","tags":"","loc":"proc/readinputpc.html","title":"readInputPC – Carrier Cross Sections"},{"text":"public subroutine distributePWsToProcs(nOfPWs, nOfBlocks) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nOfPWs integer, intent(in) :: nOfBlocks Contents Source Code distributePWsToProcs Source Code subroutine distributePWsToProcs ( nOfPWs , nOfBlocks ) ! implicit none ! integer , intent ( in ) :: nOfPWs , nOfBlocks ! integer :: iStep , iModu ! iStep = int ( nOfPWs / nOfBlocks ) iModu = mod ( nOfPWs , nOfBlocks ) ! do i = 0 , nOfBlocks - 1 counts ( i ) = iStep if ( iModu > 0 ) then counts ( i ) = counts ( i ) + 1 iModu = iModu - 1 endif enddo ! displmnt ( 0 ) = 0 do i = 1 , nOfBlocks - 1 displmnt ( i ) = displmnt ( i - 1 ) + counts ( i ) enddo ! return ! end subroutine distributePWsToProcs","tags":"","loc":"proc/distributepwstoprocs.html","title":"distributePWsToProcs – Carrier Cross Sections"},{"text":"public subroutine int2str(integ, string) Arguments Type Intent Optional Attributes Name integer :: integ character(len=300) :: string Contents Source Code int2str Source Code subroutine int2str ( integ , string ) ! implicit none integer :: integ character ( len = 300 ) :: string ! if ( integ < 10 ) then write ( string , '(i1)' ) integ else if ( integ < 100 ) then write ( string , '(i2)' ) integ else if ( integ < 1000 ) then write ( string , '(i3)' ) integ else if ( integ < 10000 ) then write ( string , '(i4)' ) integ endif ! string = trim ( string ) ! return ! end subroutine int2str","tags":"","loc":"proc/int2str.html","title":"int2str – Carrier Cross Sections"},{"text":"public subroutine finalizeCalculation() Arguments None Contents Source Code finalizeCalculation Source Code subroutine finalizeCalculation () ! implicit none ! write ( iostd , '(\"-----------------------------------------------------------------\")' ) ! call cpu_time ( tf ) write ( iostd , '(\" Total time needed:                         \", f10.2, \" secs.\")' ) tf - t0 ! close ( iostd ) ! return ! end subroutine finalizeCalculation","tags":"","loc":"proc/finalizecalculation.html","title":"finalizeCalculation – Carrier Cross Sections"},{"text":"public subroutine readPWsSet() Arguments None Contents Source Code readPWsSet Source Code subroutine readPWsSet () ! implicit none ! integer :: ig , iDum , iGx , iGy , iGz ! open ( 72 , file = trim ( exportDirSD ) // \"/mgrid\" ) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( gvecs ( 3 , numOfGvecs ) ) ! gvecs (:,:) = 0.0_dp ! do ig = 1 , numOfGvecs read ( 72 , '(4i10)' ) iDum , iGx , iGy , iGz gvecs ( 1 , ig ) = dble ( iGx ) * bg ( 1 , 1 ) + dble ( iGy ) * bg ( 1 , 2 ) + dble ( iGz ) * bg ( 1 , 3 ) gvecs ( 2 , ig ) = dble ( iGx ) * bg ( 2 , 1 ) + dble ( iGy ) * bg ( 2 , 2 ) + dble ( iGz ) * bg ( 2 , 3 ) gvecs ( 3 , ig ) = dble ( iGx ) * bg ( 3 , 1 ) + dble ( iGy ) * bg ( 3 , 2 ) + dble ( iGz ) * bg ( 3 , 3 ) enddo ! close ( 72 ) ! return ! end subroutine readPWsSet","tags":"","loc":"proc/readpwsset.html","title":"readPWsSet – Carrier Cross Sections"},{"text":"public subroutine readWfcPC(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code readWfcPC Source Code subroutine readWfcPC ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ib , ig , iDumV ( 3 ) ! complex ( kind = dp ) :: wfc ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! open ( 72 , file = trim ( exportDirPC ) // \"/grid.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGindPC ( npwsPC ( ik )) ) ! do ig = 1 , npwsPC ( ik ) read ( 72 , '(4i10)' ) pwGindPC ( ig ), iDumV ( 1 : 3 ) enddo ! close ( 72 ) ! open ( 72 , file = trim ( exportDirPC ) // \"/wfc.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandIinit - 1 do ig = 1 , npwsPC ( ik ) read ( 72 , * ) enddo enddo ! wfcPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ib = iBandIinit , iBandIfinal do ig = 1 , npwsPC ( ik ) read ( 72 , '(2ES24.15E3)' ) wfc wfcPC ( pwGindPC ( ig ), ib ) = wfc enddo enddo ! close ( 72 ) ! deallocate ( pwGindPC ) ! return ! end subroutine readWfcPC","tags":"","loc":"proc/readwfcpc.html","title":"readWfcPC – Carrier Cross Sections"},{"text":"public subroutine projectBetaPCwfcSD(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code projectBetaPCwfcSD Source Code subroutine projectBetaPCwfcSD ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ig , iDumV ( 3 ) ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! ! Reading PC projectors ! open ( 72 , file = trim ( exportDirPC ) // \"/grid.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGindPC ( npwsPC ( ik )) ) ! do ig = 1 , npwsPC ( ik ) read ( 72 , '(4i10)' ) pwGindPC ( ig ), iDumV ( 1 : 3 ) enddo ! close ( 72 ) ! allocate ( betaPC ( numOfPWs , nProjsPC ) ) ! betaPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! open ( 73 , file = trim ( exportDirPC ) // \"/projectors.\" // trim ( iks )) ! read ( 73 , '(a)' ) textDum read ( 73 , '(2i10)' ) nProjsPC , npw ! do j = 1 , nProjsPC do i = 1 , npw read ( 73 , '(2ES24.15E3)' ) betaPC ( pwGindPC ( i ), j ) enddo enddo ! close ( 73 ) ! deallocate ( pwGindPC ) ! do j = iBandFinit , iBandFfinal do i = 1 , nProjsPC cProjBetaPCPsiSD ( i , j , 1 ) = sum ( conjg ( betaPC (:, i )) * wfcSD (:, j )) !write(65,'(2f17.12)') cProjPC(i,j,1) - cProjBetaPCPsiSD(i,j,1) enddo enddo ! !close(65) ! deallocate ( betaPC ) ! return ! end subroutine projectBetaPCwfcSD","tags":"","loc":"proc/projectbetapcwfcsd.html","title":"projectBetaPCwfcSD – Carrier Cross Sections"},{"text":"public subroutine readWfcSD(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code readWfcSD Source Code subroutine readWfcSD ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ib , ig , iDumV ( 3 ) ! complex ( kind = dp ) :: wfc ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! open ( 72 , file = trim ( exportDirSD ) // \"/grid.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGindSD ( npwsSD ( ik )) ) ! do ig = 1 , npwsSD ( ik ) read ( 72 , '(4i10)' ) pwGindSD ( ig ), iDumV ( 1 : 3 ) enddo ! close ( 72 ) ! open ( 72 , file = trim ( exportDirSD ) // \"/wfc.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandFinit - 1 do ig = 1 , npwsSD ( ik ) read ( 72 , * ) enddo enddo ! wfcSD (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ib = iBandFinit , iBandFfinal do ig = 1 , npwsSD ( ik ) read ( 72 , '(2ES24.15E3)' ) wfc wfcSD ( pwGindSD ( ig ), ib ) = wfc enddo enddo ! close ( 72 ) ! deallocate ( pwGindSD ) ! return ! end subroutine readWfcSD","tags":"","loc":"proc/readwfcsd.html","title":"readWfcSD – Carrier Cross Sections"},{"text":"public subroutine readInputSD() Arguments None Contents Source Code readInputSD Source Code subroutine readInputSD () ! implicit none ! integer :: i , j , l , ind , ik , iDum , iType , ni , irc ! real ( kind = dp ) :: t1 , t2 real ( kind = dp ) :: ef ! character ( len = 300 ) :: textDum ! logical :: file_exists ! call cpu_time ( t1 ) ! write ( iostd , * ) write ( iostd , '(\" Reading solid defect inputs.\")' ) write ( iostd , * ) ! input = trim ( trim ( exportDirSD ) // '/input' ) ! inquire ( file = trim ( input ), exist = file_exists ) ! if ( file_exists . eqv . . false . ) then write ( iostd , '(\" File : \", a, \" , does not exist!\")' ) trim ( input ) write ( iostd , '(\" Please make sure that folder : \", a, \" has been created successfully !\")' ) trim ( exportDirSD ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) endif ! open ( 50 , file = trim ( input ), status = 'old' ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(ES24.15E3)' ) omega ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nKpts ! read ( 50 , '(a)' ) textDum ! allocate ( groundState ( nKpts ), npwsSD ( nKpts ), wk ( nKpts ), xk ( 3 , nKpts ) ) ! do ik = 1 , nKpts ! read ( 50 , '(3i10,4ES24.15E3)' ) iDum , groundState ( ik ), npwsSD ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfGvecs ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfPWsSD ! read ( 50 , '(a)' ) textDum read ( 50 , '(6i10)' ) fftxMin , fftxMax , fftyMin , fftyMax , fftzMin , fftzMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(a5, 3ES24.15E3)' ) textDum , at ( 1 : 3 , 1 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , at ( 1 : 3 , 2 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , at ( 1 : 3 , 3 ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(a5, 3ES24.15E3)' ) textDum , bg ( 1 : 3 , 1 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , bg ( 1 : 3 , 2 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , bg ( 1 : 3 , 3 ) ! ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nIonsSD ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) numOfTypes ! allocate ( posIonSD ( 3 , nIonsSD ), TYPNISD ( nIonsSD ) ) ! read ( 50 , '(a)' ) textDum do ni = 1 , nIonsSD read ( 50 , '(i10, 3ES24.15E3)' ) TYPNISD ( ni ), ( posIonSD ( j , ni ), j = 1 , 3 ) enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nBands ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) nSpins ! allocate ( atoms ( numOfTypes ) ) ! nProjsSD = 0 do iType = 1 , numOfTypes ! read ( 50 , '(a)' ) textDum read ( 50 , * ) atoms ( iType )% symbol ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atoms ( iType )% numOfAtoms ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atoms ( iType )% lMax ! number of projectors ! allocate ( atoms ( iType )% lps ( atoms ( iType )% lMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , atoms ( iType )% lMax read ( 50 , '(2i10)' ) l , ind atoms ( iType )% lps ( ind ) = l enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) atoms ( iType )% lmMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(2i10)' ) atoms ( iType )% nMax , atoms ( iType )% iRc ! allocate ( atoms ( iType )% r ( atoms ( iType )% nMax ), atoms ( iType )% rab ( atoms ( iType )% nMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , atoms ( iType )% nMax read ( 50 , '(2ES24.15E3)' ) atoms ( iType )% r ( i ), atoms ( iType )% rab ( i ) enddo ! allocate ( atoms ( iType )% wae ( atoms ( iType )% nMax , atoms ( iType )% lMax ) ) allocate ( atoms ( iType )% wps ( atoms ( iType )% nMax , atoms ( iType )% lMax ) ) ! read ( 50 , '(a)' ) textDum do j = 1 , atoms ( iType )% lMax do i = 1 , atoms ( iType )% nMax read ( 50 , '(2ES24.15E3)' ) atoms ( iType )% wae ( i , j ), atoms ( iType )% wps ( i , j ) enddo enddo ! allocate ( atoms ( iType )% F ( atoms ( iType )% iRc , atoms ( iType )% lMax ) ) allocate ( atoms ( iType )% F1 ( atoms ( iType )% iRc , atoms ( iType )% lMax , atoms ( iType )% lMax ) ) allocate ( atoms ( iType )% F2 ( atoms ( iType )% iRc , atoms ( iType )% lMax , atoms ( iType )% lMax ) ) ! atoms ( iType )% F = 0.0_dp atoms ( iType )% F1 = 0.0_dp atoms ( iType )% F2 = 0.0_dp ! do j = 1 , atoms ( iType )% lMax ! irc = atoms ( iType )% iRc atoms ( iType )% F ( 1 : irc , j ) = ( atoms ( iType )% wae ( 1 : irc , j ) - atoms ( iType )% wps ( 1 : irc , j )) * atoms ( iType )% r ( 1 : irc ) * & atoms ( iType )% rab ( 1 : irc ) ! do i = 1 , atoms ( iType )% lMax ! atoms ( iType )% F1 ( 1 : irc , i , j ) = ( atoms ( iType )% wae ( 1 : irc , i ) * atoms ( iType )% wps ( 1 : irc , j ) - & atoms ( iType )% wps ( 1 : irc , i ) * atoms ( iType )% wps ( 1 : irc , j )) * atoms ( iType )% rab ( 1 : irc ) ! atoms ( iType )% F2 ( 1 : irc , i , j ) = ( atoms ( iType )% wae ( 1 : irc , i ) * atoms ( iType )% wae ( 1 : irc , j ) - & atoms ( iType )% wae ( 1 : irc , i ) * atoms ( iType )% wps ( 1 : irc , j ) - & atoms ( iType )% wps ( 1 : irc , i ) * atoms ( iType )% wae ( 1 : irc , j ) + & atoms ( iType )% wps ( 1 : irc , i ) * atoms ( iType )% wps ( 1 : irc , j )) * atoms ( iType )% rab ( 1 : irc ) enddo enddo ! nProjsSD = nProjsSD + atoms ( iType )% numOfAtoms * atoms ( iType )% lmMax ! deallocate ( atoms ( iType )% wae , atoms ( iType )% wps ) ! enddo ! JMAX = 0 do iType = 1 , numOfTypes do i = 1 , atoms ( iType )% lMax if ( atoms ( iType )% lps ( i ) > JMAX ) JMAX = atoms ( iType )% lps ( i ) enddo enddo ! maxL = JMAX JMAX = 2 * JMAX + 1 ! do iType = 1 , numOfTypes allocate ( atoms ( iType )% bes_J_qr ( 0 : JMAX , atoms ( iType )% iRc ) ) atoms ( iType )% bes_J_qr (:,:) = 0.0_dp ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(ES24.15E3)' ) ef ! close ( 50 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Reading solid defect inputs done in:                \", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) flush ( iostd ) ! return ! end subroutine readInputSD","tags":"","loc":"proc/readinputsd.html","title":"readInputSD – Carrier Cross Sections"},{"text":"public subroutine calculatePWsOverlap(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code calculatePWsOverlap Source Code subroutine calculatePWsOverlap ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ibi , ibf ! call readWfcPC ( ik ) ! call readWfcSD ( ik ) ! Ufi (:,:, ik ) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal Ufi ( ibf , ibi , ik ) = sum ( conjg ( wfcSD (:, ibf )) * wfcPC (:, ibi )) !if ( ibi == ibf ) write(iostd,'(2i4,3ES24.15E3)') ibf, ibi, Ufi(ibf, ibi, ik), abs(Ufi(ibf, ibi, ik))**2 flush ( iostd ) enddo ! enddo ! return ! end subroutine calculatePWsOverlap","tags":"","loc":"proc/calculatepwsoverlap.html","title":"calculatePWsOverlap – Carrier Cross Sections"},{"text":"public subroutine readProjectionsPC(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code readProjectionsPC Source Code subroutine readProjectionsPC ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: i , j ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! cProjPC (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! ! Reading projections ! open ( 72 , file = trim ( exportDirPC ) // \"/projections.\" // trim ( iks )) ! read ( 72 , * ) ! do j = 1 , nBands ! number of bands do i = 1 , nProjsPC ! number of projections read ( 72 , '(2ES24.15E3)' ) cProjPC ( i , j , 1 ) enddo enddo ! close ( 72 ) ! return ! end subroutine readProjectionsPC","tags":"","loc":"proc/readprojectionspc.html","title":"readProjectionsPC – Carrier Cross Sections"},{"text":"public subroutine readProjectionsSD(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code readProjectionsSD Source Code subroutine readProjectionsSD ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: i , j ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! cProjSD (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! ! Reading projections ! open ( 72 , file = trim ( exportDirSD ) // \"/projections.\" // trim ( iks )) ! read ( 72 , * ) ! do j = 1 , nBands ! number of bands do i = 1 , nProjsSD ! number of projections read ( 72 , '(2ES24.15E3)' ) cProjSD ( i , j , 1 ) enddo enddo ! close ( 72 ) ! return ! end subroutine readProjectionsSD","tags":"","loc":"proc/readprojectionssd.html","title":"readProjectionsSD – Carrier Cross Sections"},{"text":"public subroutine projectBetaSDwfcPC(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code projectBetaSDwfcPC Source Code subroutine projectBetaSDwfcPC ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ig , iDumV ( 3 ) ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! ! Reading SD projectors ! open ( 72 , file = trim ( exportDirSD ) // \"/grid.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGindSD ( npwsSD ( ik )) ) ! do ig = 1 , npwsSD ( ik ) read ( 72 , '(4i10)' ) pwGindSD ( ig ), iDumV ( 1 : 3 ) enddo ! close ( 72 ) ! allocate ( betaSD ( numOfPWs , nProjsSD ) ) ! betaSD (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! open ( 73 , file = trim ( exportDirSD ) // \"/projectors.\" // trim ( iks )) ! read ( 73 , '(a)' ) textDum read ( 73 , '(2i10)' ) nProjsSD , npw ! do j = 1 , nProjsSD do i = 1 , npw read ( 73 , '(2ES24.15E3)' ) betaSD ( pwGindSD ( i ), j ) enddo enddo ! close ( 73 ) ! deallocate ( pwGindSD ) ! do j = iBandIinit , iBandIfinal do i = 1 , nProjsSD cProjBetaSDPhiPC ( i , j , 1 ) = sum ( conjg ( betaSD (:, i )) * wfcPC (:, j )) !write(66,'(2f17.12)') cProjSD(i,j,1) - cProjBetaSDPhiPC(i,j,1) enddo enddo ! !close(66) ! deallocate ( betaSD ) ! return ! end subroutine projectBetaSDwfcPC","tags":"","loc":"proc/projectbetasdwfcpc.html","title":"projectBetaSDwfcPC – Carrier Cross Sections"},{"text":"public subroutine pawCorrectionKPC() Arguments None Contents Source Code pawCorrectionKPC Source Code subroutine pawCorrectionKPC () ! implicit none ! !integer, intent(in) :: ik ! integer :: ibi , ibf , ispin , ig integer :: LL , I , NI , LMBASE , LM integer :: L , M , ind , iT real ( kind = dp ) :: q , qDotR , FI , t1 , t2 ! real ( kind = dp ) :: JL ( 0 : JMAX ), v_in ( 3 ) complex ( kind = dp ) :: Y ( ( JMAX + 1 ) ** 2 ) complex ( kind = dp ) :: VifQ_aug , ATOMIC_CENTER ! ispin = 1 ! call cpu_time ( t1 ) ! pawKPC (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ig = nPWsI ( myid ), nPWsF ( myid ) ! 1, numOfGvecs ! if ( myid == root ) then if ( ( ig == nPWsI ( myid ) + 1000 ) . or . ( mod ( ig , 25000 ) == 0 ) . or . ( ig == nPWsF ( myid )) ) then call cpu_time ( t2 ) write ( iostd , '(\"        Done \", i10, \" of\", i10, \" k-vecs. ETR : \", f10.2, \" secs.\")' ) & ig , nPWsF ( myid ) - nPWsI ( myid ) + 1 , ( t2 - t1 ) * ( nPWsF ( myid ) - nPWsI ( myid ) + 1 - ig ) / ig flush ( iostd ) !call cpu_time(t1) endif endif ! q = sqrt ( sum ( gvecs (:, ig ) * gvecs (:, ig ))) ! v_in (:) = gvecs (:, ig ) if ( abs ( q ) > 1.0e-6_dp ) v_in = v_in / q ! i have to determine v_in = q Y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) CALL ylm ( v_in , JMAX , Y ) ! calculates all the needed spherical harmonics once ! LMBASE = 0 ! do iT = 1 , numOfTypesPC ! DO I = 1 , atomsPC ( iT )% iRc ! nMax - 1 ! JL = 0.0_dp CALL bessel_j ( q * atoms ( iT )% r ( I ), JMAX , JL ) ! returns the spherical bessel at qr point atomsPC ( iT )% bes_J_qr (:, I ) = JL (:) ! ENDDO ! enddo ! do ni = 1 , nIonsPC ! LOOP OVER THE IONS ! qDotR = sum ( gvecs (:, ig ) * posIonPC (:, ni )) ! ATOMIC_CENTER = exp ( - ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! iT = TYPNIPC ( ni ) LM = 0 DO LL = 1 , atomsPC ( iT )% lMax L = atomsPC ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! FI = 0.0_dp ! FI = sum ( atomsPC ( iT )% bes_J_qr ( L ,:) * atomsPC ( iT )% F (:, LL )) ! radial part integration F contains rab ! ind = L * ( L + 1 ) + M + 1 ! index for spherical harmonics VifQ_aug = ATOMIC_CENTER * Y ( ind ) * ( - II ) ** L * FI ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! pawKPC ( ibf , ibi , ig ) = pawKPC ( ibf , ibi , ig ) + VifQ_aug * cProjPC ( LM + LMBASE , ibi , ISPIN ) ! enddo ! enddo ! ENDDO ENDDO LMBASE = LMBASE + atomsPC ( iT )% lmMax ENDDO ! enddo ! !pawKPC(:,:,:) = pawKPC(:,:,:)*4.0_dp*pi/sqrt(omega) ! return ! end subroutine pawCorrectionKPC","tags":"","loc":"proc/pawcorrectionkpc.html","title":"pawCorrectionKPC – Carrier Cross Sections"},{"text":"public subroutine pawCorrectionSDK() Arguments None Contents Source Code pawCorrectionSDK Source Code subroutine pawCorrectionSDK () ! implicit none ! !integer, intent(in) :: ik ! integer :: ibi , ibf , ispin , ig integer :: LL , I , NI , LMBASE , LM integer :: L , M , ind , iT real ( kind = dp ) :: q , qDotR , FI , t1 , t2 ! real ( kind = dp ) :: JL ( 0 : JMAX ), v_in ( 3 ) complex ( kind = dp ) :: Y ( ( JMAX + 1 ) ** 2 ) complex ( kind = dp ) :: VifQ_aug , ATOMIC_CENTER ! ispin = 1 ! call cpu_time ( t1 ) ! pawSDK (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ig = nPWsI ( myid ), nPWsF ( myid ) ! 1, numOfGvecs ! if ( myid == root ) then if ( ( ig == nPWsI ( myid ) + 1000 ) . or . ( mod ( ig , 25000 ) == 0 ) . or . ( ig == nPWsF ( myid )) ) then call cpu_time ( t2 ) write ( iostd , '(\"        Done \", i10, \" of\", i10, \" k-vecs. ETR : \", f10.2, \" secs.\")' ) & ig , nPWsF ( myid ) - nPWsI ( myid ) + 1 , ( t2 - t1 ) * ( nPWsF ( myid ) - nPWsI ( myid ) + 1 - ig ) / ig flush ( iostd ) call cpu_time ( t1 ) endif endif q = sqrt ( sum ( gvecs (:, ig ) * gvecs (:, ig ))) ! v_in (:) = gvecs (:, ig ) if ( abs ( q ) > 1.0e-6_dp ) v_in = v_in / q ! i have to determine v_in = q Y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) CALL ylm ( v_in , JMAX , Y ) ! calculates all the needed spherical harmonics once ! LMBASE = 0 ! do iT = 1 , numOfTypes ! DO I = 1 , atoms ( iT )% iRc ! nMax - 1 ! JL = 0.0_dp CALL bessel_j ( q * atoms ( iT )% r ( I ), JMAX , JL ) ! returns the spherical bessel at qr point atoms ( iT )% bes_J_qr (:, I ) = JL (:) ! ENDDO enddo ! do ni = 1 , nIonsSD ! LOOP OVER THE IONS ! qDotR = sum ( gvecs (:, ig ) * posIonSD (:, ni )) ! ATOMIC_CENTER = exp ( ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! iT = TYPNISD ( ni ) LM = 0 DO LL = 1 , atoms ( iT )% lMax L = atoms ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! FI = 0.0_dp ! FI = sum ( atoms ( iT )% bes_J_qr ( L ,:) * atoms ( iT )% F (:, LL )) ! radial part integration F contains rab ! ind = L * ( L + 1 ) + M + 1 ! index for spherical harmonics VifQ_aug = ATOMIC_CENTER * conjg ( Y ( ind )) * ( II ) ** L * FI ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! pawSDK ( ibf , ibi , ig ) = pawSDK ( ibf , ibi , ig ) + VifQ_aug * conjg ( cProjSD ( LM + LMBASE , ibf , ISPIN )) ! enddo ! enddo ! ENDDO ENDDO LMBASE = LMBASE + atoms ( iT )% lmMax ENDDO ! enddo ! !pawSDK(:,:,:) = pawSDK(:,:,:)*4.0_dp*pi/sqrt(omega) ! return ! end subroutine pawCorrectionSDK","tags":"","loc":"proc/pawcorrectionsdk.html","title":"pawCorrectionSDK – Carrier Cross Sections"},{"text":"public subroutine pawCorrectionPsiPC() Arguments None Contents Source Code pawCorrectionPsiPC Source Code subroutine pawCorrectionPsiPC () ! ! calculates the augmentation part of the transition matrix element ! implicit none integer :: ibi , ibf , niPC , ispin integer :: LL , LLP , LMBASE , LM , LMP integer :: L , M , LP , MP , iT real ( kind = dp ) :: atomicOverlap ! complex ( kind = dp ) :: cProjIe , cProjFe ! ispin = 1 ! paw_PsiPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! LMBASE = 0 ! do niPC = 1 , nIonsPC ! LOOP OVER THE IONS ! iT = TYPNIPC ( niPC ) LM = 0 DO LL = 1 , atomsPC ( iT )% lMax L = atomsPC ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! LMP = 0 DO LLP = 1 , atomsPC ( iT )% lMax LP = atomsPC ( iT )% LPS ( LLP ) DO MP = - LP , LP LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp if ( ( L == LP ). and .( M == MP ) ) then atomicOverlap = sum ( atomsPC ( iT )% F1 (:, LL , LLP )) ! do ibi = iBandIinit , iBandIfinal cProjIe = cProjPC ( LMP + LMBASE , ibi , ISPIN ) ! do ibf = iBandFinit , iBandFfinal cProjFe = conjg ( cProjBetaPCPsiSD ( LM + LMBASE , ibf , ISPIN )) ! paw_PsiPC ( ibf , ibi ) = paw_PsiPC ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe !write(iostd,*) LL, LLP, L, M, atomicOverlap flush ( iostd ) ! enddo ! enddo ! endif ! ENDDO ENDDO ENDDO ENDDO LMBASE = LMBASE + atomsPC ( iT )% lmMax ENDDO ! return ! end subroutine pawCorrectionPsiPC","tags":"","loc":"proc/pawcorrectionpsipc.html","title":"pawCorrectionPsiPC – Carrier Cross Sections"},{"text":"public subroutine pawCorrectionSDPhi() Arguments None Contents Source Code pawCorrectionSDPhi Source Code subroutine pawCorrectionSDPhi () ! ! calculates the augmentation part of the transition matrix element ! implicit none integer :: ibi , ibf , ni , ispin integer :: LL , LLP , LMBASE , LM , LMP integer :: L , M , LP , MP , iT real ( kind = dp ) :: atomicOverlap ! complex ( kind = dp ) :: cProjIe , cProjFe ! ispin = 1 ! paw_SDPhi (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! LMBASE = 0 ! do ni = 1 , nIonsSD ! LOOP OVER THE IONS ! iT = TYPNISD ( ni ) LM = 0 DO LL = 1 , atoms ( iT )% lMax L = atoms ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! LMP = 0 DO LLP = 1 , atoms ( iT )% lMax LP = atoms ( iT )% LPS ( LLP ) DO MP = - LP , LP LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp if ( ( L == LP ). and .( M == MP ) ) then atomicOverlap = sum ( atoms ( iT )% F1 (:, LL , LLP )) ! do ibi = iBandIinit , iBandIfinal cProjIe = cProjBetaSDPhiPC ( LMP + LMBASE , ibi , ISPIN ) ! do ibf = iBandFinit , iBandFfinal cProjFe = conjg ( cProjSD ( LM + LMBASE , ibf , ISPIN )) ! paw_SDPhi ( ibf , ibi ) = paw_SDPhi ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe ! enddo ! enddo ! endif ! ENDDO ENDDO ENDDO ENDDO LMBASE = LMBASE + atoms ( iT )% lmMax ENDDO ! return ! end subroutine pawCorrectionSDPhi","tags":"","loc":"proc/pawcorrectionsdphi.html","title":"pawCorrectionSDPhi – Carrier Cross Sections"},{"text":"public subroutine pawCorrection() Arguments None Contents Source Code pawCorrection Source Code subroutine pawCorrection () ! ! calculates the augmentation part of the transition matrix element ! implicit none integer :: ibi , ibf , niPC , ispin integer :: LL , LLP , LMBASE , LM , LMP integer :: L , M , LP , MP , iT real ( kind = dp ) :: atomicOverlap ! !real(kind = dp), allocatable :: Qij(:,:) ! complex ( kind = dp ) :: cProjIe , cProjFe ! ispin = 1 ! !open(52, file=trim(exportDirPC)//\"/Qij\") !read(52,*) !allocate ( Qij (8,8) ) !do LL = 1, 8 !  do LLP = 1, 8 !    read(52,'(3i3,ES24.15E3)') LMBASE, LMBASE, LMBASE, Qij(LL, LLP) !  enddo !enddo !close(52) ! paw_fi (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! LMBASE = 0 ! do niPC = 1 , nIonsPC ! LOOP OVER THE IONS ! iT = TYPNIPC ( niPC ) LM = 0 DO LL = 1 , atomsPC ( iT )% lMax L = atomsPC ( iT )% LPS ( LL ) DO M = - L , L LM = LM + 1 !1st index for CPROJ ! LMP = 0 DO LLP = 1 , atomsPC ( iT )% lMax LP = atomsPC ( iT )% LPS ( LLP ) DO MP = - LP , LP LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp if ( ( L == LP ). and .( M == MP ) ) atomicOverlap = sum ( atomsPC ( iT )% F2 (:, LL , LLP )) ! do ibi = iBandIinit , iBandIfinal cProjIe = cProjPC ( LMP + LMBASE , ibi , ISPIN ) ! do ibf = iBandFinit , iBandFfinal cProjFe = conjg ( cProjPC ( LM + LMBASE , ibf , ISPIN )) ! paw_fi ( ibf , ibi ) = paw_fi ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe ! enddo ! enddo ! ENDDO ENDDO ENDDO ENDDO LMBASE = LMBASE + atomsPC ( iT )% lmMax ENDDO ! return ! end subroutine pawCorrection","tags":"","loc":"proc/pawcorrection.html","title":"pawCorrection – Carrier Cross Sections"},{"text":"public subroutine readEigenvalues(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code readEigenvalues Source Code subroutine readEigenvalues ( ik ) ! implicit none ! integer , intent ( in ) :: ik integer :: ib ! character ( len = 300 ) :: iks ! call int2str ( ik , iks ) ! open ( 72 , file = trim ( exportDirSD ) // \"/eigenvalues.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandIinit - 1 read ( 72 , * ) enddo ! do ib = iBandIinit , iBandIfinal read ( 72 , '(ES24.15E3)' ) eigvI ( ib ) enddo ! close ( 72 ) ! open ( 72 , file = trim ( exportDirSD ) // \"/eigenvalues.\" // trim ( iks )) ! read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandFinit - 1 read ( 72 , * ) enddo ! do ib = iBandFinit , iBandFfinal read ( 72 , '(ES24.15E3)' ) eigvF ( ib ) enddo ! close ( 72 ) ! return ! end subroutine readEigenvalues","tags":"","loc":"proc/readeigenvalues.html","title":"readEigenvalues – Carrier Cross Sections"},{"text":"public subroutine calculateVfiElements() Arguments None Contents Source Code calculateVfiElements Source Code subroutine calculateVfiElements () ! implicit none ! integer :: ik , ib , nOfEnergies , iE ! real ( kind = dp ) :: eMin , eMax , E , av , sd , x , EiMinusEf , A , DHifMin ! real ( kind = dp ), allocatable :: sumWk (:), sAbsVfiOfE2 (:), absVfiOfE2 (:) integer , allocatable :: nKsInEbin (:) ! character ( len = 300 ) :: text ! allocate ( DE ( iBandIinit : iBandIfinal , nKptsPC ), absVfi2 ( iBandIinit : iBandIfinal , nKptsPC ) ) ! DE (:,:) = 0.0_dp absVfi2 (:,:) = 0.0_dp ! do ik = 1 , nKptsPC ! eigvI (:) = 0.0_dp eigvF (:) = 0.0_dp ! call readEigenvalues ( ik ) ! do ib = iBandIinit , iBandIfinal ! EiMinusEf = eigvI ( ib ) - eigvF ( iBandFinit ) absVfi2 ( ib , ik ) = EiMinusEf ** 2 * ( abs ( Ufi ( iBandFinit , ib , ik )) ** 2 - abs ( Ufi ( iBandFinit , ib , ik )) ** 4 ) ! DE ( ib , ik ) = sqrt ( EiMinusEf ** 2 - 4.0_dp * absVfi2 ( ib , ik )) ! enddo ! enddo ! eMin = minval ( DE (:,:) ) eMax = maxval ( DE (:,:) ) ! nOfEnergies = int (( eMax - eMin ) / eBin ) + 1 ! allocate ( absVfiOfE2 ( 0 : nOfEnergies ), nKsInEbin ( 0 : nOfEnergies ), sumWk ( 0 : nOfEnergies ) ) ! absVfiOfE2 (:) = 0.0_dp nKsInEbin (:) = 0 sumWk (:) = 0.0_dp ! do ik = 1 , nKptsPC ! do ib = iBandIinit , iBandIfinal ! if ( abs ( eMin - DE ( ib , ik )) < 1.0e-3_dp ) DHifMin = absVfi2 ( ib , ik ) iE = int (( DE ( ib , ik ) - eMin ) / eBin ) if ( absVfi2 ( ib , ik ) > 0.0_dp ) then absVfiOfE2 ( iE ) = absVfiOfE2 ( iE ) + wkPC ( ik ) * absVfi2 ( ib , ik ) sumWk ( iE ) = sumWk ( iE ) + wkPC ( ik ) nKsInEbin ( iE ) = nKsInEbin ( iE ) + 1 else write ( iostd , * ) 'lalala' , absVfi2 ( ib , ik ) endif ! enddo ! enddo ! allocate ( sAbsVfiOfE2 ( 0 : nOfEnergies ) ) ! sAbsVfiOfE2 = 0.0_dp ! open ( 11 , file = trim ( VfisOutput ) // 'ofKpt' , status = 'unknown' ) ! write ( 11 , '(\"# |<f|V|i>|&#94;2 versus energy for all the k-points.\")' ) write ( text , '(\"# Energy (eV) shifted by half eBin, |<f|V|i>|&#94;2 (Hartree)&#94;2,\")' ) write ( 11 , '(a, \" k-point index. Format : ''(2ES24.15E3,i10)''\")' ) trim ( text ) ! do ik = 1 , nKptsPC ! do ib = iBandIinit , iBandIfinal ! iE = int (( DE ( ib , ik ) - eMin ) / eBin ) av = absVfiOfE2 ( iE ) / sumWk ( iE ) x = absVfi2 ( ib , ik ) write ( 11 , '(2ES24.15E3,i10)' ) ( eMin + ( iE + 0.5_dp ) * eBin ) * HartreeToEv , x , ik write ( 12 , '(2ES24.15E3,i10)' ) DE ( ib , ik ) * HartreeToEv , absVfi2 ( ib , ik ), ik !write(11, '(2ES24.15E3,i10)') (eMin + iE*eBin + eBin/2.0_dp), x, ik sAbsVfiOfE2 ( iE ) = sAbsVfiOfE2 ( iE ) + wkPC ( ik ) * ( x - av ) ** 2 / sumWk ( iE ) ! enddo ! enddo ! close ( 11 ) ! open ( 63 , file = trim ( VfisOutput ), status = 'unknown' ) ! write ( 63 , '(\"# Averaged |<f|V|i>|&#94;2 over K-points versus energy.\")' ) write ( 63 , '(\"#                 Cell volume : \", ES24.15E3, \" (a.u.)&#94;3,   Format : ''(ES24.15E3)''\")' ) omega write ( 63 , '(\"#   Minimun transition energy : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eMin write ( 63 , '(\"# |DHif|&#94;2 at minimum Tr. En. : \", ES24.15E3, \" (Hartree&#94;2),Format : ''(ES24.15E3)''\")' ) DHifMin write ( 63 , '(\"#                  Energy bin : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eBin write ( text , '(\"# Energy (Hartree), averaged |<f|V|i>|&#94;2 over K-points (Hartree)&#94;2,\")' ) write ( 63 , '(a, \" standard deviation (Hartree)&#94;2. Format : ''(3ES24.15E3)''\")' ) trim ( text ) ! do iE = 0 , nOfEnergies E = iE * eBin av = 0.0_dp sd = 0.0_dp if ( nKsInEbin ( iE ) > 0 ) then av = absVfiOfE2 ( iE ) / sumWk ( iE ) sd = sqrt ( sAbsVfiOfE2 ( iE )) endif write ( 63 , '(3ES24.15E3)' ) eMin + E , av , sd enddo ! close ( 63 ) ! return ! end subroutine calculateVfiElements","tags":"","loc":"proc/calculatevfielements.html","title":"calculateVfiElements – Carrier Cross Sections"},{"text":"public subroutine checkIfCalculated(ik, tmes_file_exists) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik logical, intent(out) :: tmes_file_exists Contents Source Code checkIfCalculated Source Code subroutine checkIfCalculated ( ik , tmes_file_exists ) ! implicit none ! integer , intent ( in ) :: ik logical , intent ( out ) :: tmes_file_exists ! character ( len = 300 ) :: Uelements ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! inquire ( file = trim ( elementsPath ) // trim ( Uelements ), exist = tmes_file_exists ) ! return ! end subroutine checkIfCalculated","tags":"","loc":"proc/checkifcalculated.html","title":"checkIfCalculated – Carrier Cross Sections"},{"text":"public subroutine readUfis(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code readUfis Source Code subroutine readUfis ( ik ) ! implicit none ! integer , intent ( in ) :: ik ! integer :: ibi , ibf , totalNumberOfElements , iDum , i real ( kind = dp ) :: rDum , t1 , t2 complex ( kind = dp ) :: cUfi ! character ( len = 300 ) :: Uelements ! call cpu_time ( t1 ) write ( iostd , '(\" Reading Ufi(:,:) of k-point: \", i4)' ) ik ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) ! read ( 17 , * ) read ( 17 , * ) read ( 17 , '(5i10)' ) totalNumberOfElements , iDum , iDum , iDum , iDum read ( 17 , * ) ! do i = 1 , totalNumberOfElements ! read ( 17 , 1001 ) ibf , ibi , rDum , cUfi , rDum Ufi ( ibf , ibi , ik ) = cUfi ! enddo ! close ( 17 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Reading Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! return ! end subroutine readUfis","tags":"","loc":"proc/readufis.html","title":"readUfis – Carrier Cross Sections"},{"text":"public subroutine writeResults(ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Contents Source Code writeResults Source Code subroutine writeResults ( ik ) ! implicit none ! integer , intent ( in ) :: ik ! integer :: ibi , ibf , totalNumberOfElements real ( kind = dp ) :: t1 , t2 ! character ( len = 300 ) :: text , Uelements ! call cpu_time ( t1 ) ! call readEigenvalues ( ik ) ! write ( iostd , '(\" Writing Ufi(:,:).\")' ) ! if ( ik < 10 ) then write ( Uelements , '(\"/TMEs_kptI_\",i1,\"_kptF_\",i1)' ) ik , ik else if ( ik < 100 ) then write ( Uelements , '(\"/TMEs_kptI_\",i2,\"_kptF_\",i2)' ) ik , ik else if ( ik < 1000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i3,\"_kptF_\",i3)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i4,\"_kptF_\",i4)' ) ik , ik else if ( ik < 10000 ) then write ( Uelements , '(\"/TMEs_kptI_\",i5,\"_kptF_\",i5)' ) ik , ik endif ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) ! write ( 17 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(a51, ES24.15E3)'' \", ES24.15E3)' ) omega ! text = \"# Total number of <f|U|i> elements, Initial States (bandI, bandF), Final States (bandI, bandF)\" write ( 17 , '(a, \" Format : ''(5i10)''\")' ) trim ( text ) ! totalNumberOfElements = ( iBandIfinal - iBandIinit + 1 ) * ( iBandFfinal - iBandFinit + 1 ) write ( 17 , '(5i10)' ) totalNumberOfElements , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! write ( 17 , '(\"# Final Band, Initial Band, Delta energy, Complex <f|U|i>, |<f|U|i>|&#94;2 Format : ''(2i10,4ES24.15E3)''\")' ) ! do ibf = iBandFinit , iBandFfinal do ibi = iBandIinit , iBandIfinal ! write ( 17 , 1001 ) ibf , ibi , eigvI ( ibi ) - eigvF ( ibf ), Ufi ( ibf , ibi , ik ), abs ( Ufi ( ibf , ibi , ik )) ** 2 ! enddo enddo ! close ( 17 ) ! call cpu_time ( t2 ) write ( iostd , '(\" Writing Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! return ! end subroutine writeResults","tags":"","loc":"proc/writeresults.html","title":"writeResults – Carrier Cross Sections"},{"text":"public subroutine bessel_j(x, lmax, jl) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: lmax real(kind=dp), intent(out) :: jl (0:lmax) Contents Source Code bessel_j Source Code subroutine bessel_j ( x , lmax , jl ) ! ! x is the argument of j, jl(0:lmax) is the output values. implicit none integer , intent ( in ) :: lmax real ( kind = dp ), intent ( in ) :: x real ( kind = dp ), intent ( out ) :: jl ( 0 : lmax ) integer :: l ! if ( x <= 0.0_dp ) then jl = 0.0_dp jl ( 0 ) = 1.0_dp return end if ! jl ( 0 ) = sin ( x ) / x if ( lmax <= 0 ) return jl ( 1 ) = ( jl ( 0 ) - cos ( x )) / x if ( lmax == 1 ) return ! do l = 2 , lmax jl ( l ) = dble ( 2 * l - 1 ) * jl ( l - 1 ) / x - jl ( l - 2 ) enddo ! return ! end subroutine bessel_j","tags":"","loc":"proc/bessel_j.html","title":"bessel_j – Carrier Cross Sections"},{"text":"public subroutine ylm(V_in, LMAX, Y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_in (3) integer, intent(in) :: LMAX complex(kind=dp), intent(out) :: Y (*) Contents Source Code ylm Source Code subroutine ylm ( v_in , lmax , y ) ! ! lmax   : spherical harmonics are calculated for l = 0 to lmax ! v      : vector, argument of the spherical harmonics (we calculate ! Ylm(v/norm(v)) ! y      : array containing Ylm(v) for several l,m ! ! !DESCRIPTION: !   1.  PURPOSE !        The spherical harmonics (Condon and Shortley convention) !          Y(0,0),Y(1,-1),Y(1,0),Y(1,1),Y(2,-2) ... Y(LMAX,LMAX) !        for vector V (given in Cartesian coordinates) !        are calculated. In the Condon Shortley convention the !        spherical harmonics are defined as !         Y(l,m) = (-1)&#94;m \\sqrt{\\frac{1}{\\pi}} P_{lm}(\\cos{\\theta}) !        \\rm !        e&#94;{\\rm i m \\phi}  ! !        where  $P_{lm}(\\cos{\\theta})$ is the normalized Associated !        Legendre ! !        function. Thus, ! !                       Y(l,-m) = (-1)&#94;m Y&#94;*(l,m)  ! !   2.  USAGE !        DOUBLE PRECISION V(3), Y(5*5) !        V(1) = ... !        V(2) = ... !        V(3) = ... !        CALL YLM(V,4,Y) ! !       ARGUMENT-DESCRIPTION !          V      - DOUBLE PRECISION vector, dimension 3        (input) !                   Must be given in Cartesian coordinates. !                   Conversion of V to polar coordinates gives the !                   angles Theta and Phi necessary for the calculation !                   of the spherical harmonics. !          LMAX   - INTEGER value                               (input) !                   upper bound of L for which spherical harmonics !                   will be calculated !                   constraint: !                      LMAX >= 0 !          Y      - COMPLEX*16 array, dimension (LMAX+1)**2    (output) !                   contains the calculated spherical harmonics !                   Y(1)                   for L .EQ. 0 (M = 0) !                   Y(2), ..., Y(4)        for L .EQ. 1 (M = -1, 0, 1) !                   ... !                   Y(LMAX*LMAX+1), ..., Y((LMAX+1)*(LMAX+1)) !                                          for L .EQ. LMAX !                                              (M = -L,...,L) !                   constraint: !                      Dimension of Y .GE. (LMAX+1)**2 (not checked) !        USED SUBROUTINES (DIRECTLY CALLED) !           none ! !        INDIRECTLY CALLED SUBROUTINES !           none ! !        UTILITY-SUBROUTINES (USE BEFOREHAND OR AFTERWARDS) !           none ! !        INPUT/OUTPUT (READ/WRITE) !           none ! !        MACHINENDEPENDENT PROGRAMPARTS !           Type COMPLEX*16 is used which does not conform to the !           FORTRAN 77 standard. !           Also the non-standard type conversion function DCMPLX() !           is used which combines two double precision values into !           one double complex value. ! !   3.     METHOD !           The basic algorithm used to calculate the spherical !           harmonics for vector V is as follows: ! !           Y(0,0) !           Y(1,0) !           Y(1,1) !           Y(1,-1) = -Y(1,1) !           DO L = 2, LMAX !              Y(L,L)   = f(Y(L-1,L-1)) ... Formula 1 !              Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 !              DO M = L-2, 0, -1 !                 Y(L,M) = f(Y(L-1,M),Y(L-2,M)) ... Formula 2 !                 Y(L,-M)= (-1)**M*Y(L,M) !              ENDDO !           ENDDO ! !           In the following the necessary recursion formulas and !           starting values are given: ! !        Start: !%                        +------+ !%                        |   1 !%           Y(0,0) =  -+ | ----- !%                       \\| 4(Pi) !% !%                                   +------+ !%                                   |   3 !%           Y(1,0) =  cos(Theta) -+ | ----- !%                                  \\| 4(Pi) !% !%                                     +------+ !%                                     |   3    i(Phi) !%           Y(1,1) =  - sin(Theta) -+ | ----- e !%                                    \\| 8(Pi) !% !%        Formula 1: !% !%           Y(l,l) = !%                           +--------+ !%                           | (2l+1)   i(Phi) !%            -sin(Theta) -+ | ------  e       Y(l-1,l-1) !%                          \\|   2l !% !%        Formula 2: !%                                  +---------------+ !%                                  |  (2l-1)(2l+1) !%           Y(l,m) = cos(Theta) -+ | -------------- Y(l-1,m)  - !%                                 \\|   (l-m)(l+m) !% !%                                    +--------------------+ !%                                    |(l-1+m)(l-1-m)(2l+1) !%                              -  -+ |-------------------- Y(l-2,m) !%                                   \\|  (2l-3)(l-m)(l+m) !% !%        Formula 3: (not used in the algorithm because of the division !%                    by sin(Theta) which may be zero) !% !%                                    +--------------+ !%                      cos(Theta)    |  4(m+1)(m+1)   -i(Phi) !%           Y(l,m) = - ---------- -+ | ------------  e       Y(l,m+1) - !%                      sin(Theta)   \\| (l+m+1)(l-m) !% !%                                    +--------------+ !%                                    |(l-m-1)(l+m+2)  -2i(Phi) !%                              -  -+ |-------------- e        Y(l,m+2) !%                                   \\| (l-m)(l+m+1) !% !% ! !REVISION HISTORY: !   26. April 1994                                   Version 1.2 !   Taken 8 1 98 from SRC_lapw2 to SRC_telnes !   Updated November 2004 (Kevin Jorissen) !   cosmetics March 2005 (Kevin Jorissen) ! implicit none ! !   In/Output : ! integer , intent ( in ) :: LMAX real ( kind = dp ), intent ( in ) :: V_in ( 3 ) complex ( kind = dp ), intent ( out ) :: Y ( * ) !   Local variables : real ( kind = dp ), parameter :: pi = 3.1415926535897932384626433_dp ! INTEGER :: I2L , I4L2 , INDEX , INDEX2 , L , M , MSIGN real ( kind = dp ) :: A , B , C , AB , ABC , ABMAX , ABCMAX , V ( 3 ) real ( kind = dp ) :: D4LL1C , D2L13 real ( kind = dp ) :: COSTH , SINTH , COSPH , SINPH real ( kind = dp ) :: TEMP1 , TEMP2 , TEMP3 real ( kind = dp ) :: YLLR , YLL1R , YL1L1R , YLMR real ( kind = dp ) :: YLLI , YLL1I , YL1L1I , YLMI ! ! Y(0,0) ! do INDEX = 1 , 3 V ( INDEX ) = dble ( V_in ( INDEX )) enddo YLLR = 1.0_dp / sqrt ( 4.0_dp * PI ) YLLI = 0.0_dp Y ( 1 ) = CMPLX ( YLLR , YLLI , kind = dp ) ! ! continue only if spherical harmonics for (L .GT. 0) are desired ! IF ( LMAX . LE . 0 ) GOTO 999 ! ! calculate sin(Phi), cos(Phi), sin(Theta), cos(Theta) ! Theta, Phi ... polar angles of vector V ! ABMAX = MAX ( ABS ( V ( 1 )), ABS ( V ( 2 ))) IF ( ABMAX . GT . 0.0_dp ) THEN A = V ( 1 ) / ABMAX B = V ( 2 ) / ABMAX AB = SQRT ( A * A + B * B ) COSPH = A / AB SINPH = B / AB ELSE COSPH = 1.0_dp SINPH = 0.0_dp ENDIF ABCMAX = MAX ( ABMAX , ABS ( V ( 3 ))) IF ( ABCMAX . GT . dble ( 0 )) THEN A = V ( 1 ) / ABCMAX B = V ( 2 ) / ABCMAX C = V ( 3 ) / ABCMAX AB = A * A + B * B ABC = SQRT ( AB + C * C ) COSTH = C / ABC SINTH = SQRT ( AB ) / ABC ELSE COSTH = 1.0_dp SINTH = 0.0_dp ENDIF ! ! Y(1,0) ! Y ( 3 ) = CMPLX ( sqrt ( 3.0_dp ) * YLLR * COSTH , 0.0_dp , kind = dp ) ! ! Y(1,1) ( = -DCONJG(Y(1,-1))) ! TEMP1 = - SQRT ( 1.5_dp ) * YLLR * SINTH Y ( 4 ) = CMPLX ( TEMP1 * COSPH , TEMP1 * SINPH , kind = dp ) Y ( 2 ) = - CONJG ( Y ( 4 )) ! DO L = 2 , LMAX INDEX = L * L + 1 INDEX2 = INDEX + 2 * L MSIGN = 1 - 2 * MOD ( L , 2 ) ! ! YLL = Y(L,L) = f(Y(L-1,L-1)) ... Formula 1 ! YL1L1R = DBLE ( Y ( INDEX - 1 )) YL1L1I = DIMAG ( Y ( INDEX - 1 )) TEMP1 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L )) * SINTH YLLR = TEMP1 * ( COSPH * YL1L1R - SINPH * YL1L1I ) YLLI = TEMP1 * ( COSPH * YL1L1I + SINPH * YL1L1R ) Y ( INDEX2 ) = CMPLX ( YLLR , YLLI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! ! YLL1 = Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 ! (the coefficient for Y(L-2,L-1) in Formula 2 is zero) ! TEMP2 = SQRT ( DBLE ( 2 * L + 1 )) * COSTH YLL1R = TEMP2 * YL1L1R YLL1I = TEMP2 * YL1L1I Y ( INDEX2 ) = CMPLX ( YLL1R , YLL1I , kind = dp ) Y ( INDEX ) = - cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = -dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! I4L2 = INDEX2 - 4 * L + 2 I2L = INDEX2 - 2 * L D4LL1C = COSTH * SQRT ( DBLE ( 4 * L * L - 1 )) D2L13 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L - 3 )) ! DO M = L - 2 , 0 , - 1 ! ! YLM = Y(L,M) = f(Y(L-2,M),Y(L-1,M)) ... Formula 2 ! TEMP1 = 1.0_dp / SQRT ( DBLE (( L + M ) * ( L - M ))) TEMP2 = D4LL1C * TEMP1 TEMP3 = D2L13 * SQRT ( DBLE (( L + M - 1 ) * ( L - M - 1 ))) * TEMP1 YLMR = TEMP2 * DBLE ( Y ( I2L )) + TEMP3 * DBLE ( Y ( I4L2 )) YLMI = TEMP2 * DIMAG ( Y ( I2L )) + TEMP3 * DIMAG ( Y ( I4L2 )) Y ( INDEX2 ) = CMPLX ( YLMR , YLMI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) ! MSIGN = - MSIGN INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 I4L2 = I4L2 - 1 I2L = I2L - 1 ENDDO ENDDO ! 999 RETURN END subroutine ylm","tags":"","loc":"proc/ylm.html","title":"ylm – Carrier Cross Sections"},{"text":"public function msta1(x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer Contents None","tags":"","loc":"proc/msta1.html","title":"msta1 – Carrier Cross Sections"},{"text":"public function msta2(x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer Contents None","tags":"","loc":"proc/msta2.html","title":"msta2 – Carrier Cross Sections"},{"text":"public function envj(n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/envj.html","title":"envj – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents None","tags":"","loc":"proc/readinputs.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents None","tags":"","loc":"proc/initialize~2.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Arguments None Contents None","tags":"","loc":"proc/checkandupdateinput.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readPhonons() Arguments None Contents None","tags":"","loc":"proc/readphonons.html","title":"readPhonons – Carrier Cross Sections"},{"text":"public subroutine readAtomicPositions() Arguments None Contents None","tags":"","loc":"proc/readatomicpositions.html","title":"readAtomicPositions – Carrier Cross Sections"},{"text":"public subroutine computeGeneralizedDisplacements() Arguments None Contents None","tags":"","loc":"proc/computegeneralizeddisplacements.html","title":"computeGeneralizedDisplacements – Carrier Cross Sections"},{"text":"public subroutine computeVariables() Arguments None Contents None","tags":"","loc":"proc/computevariables.html","title":"computeVariables – Carrier Cross Sections"},{"text":"public subroutine arrangeLargerToSmaller() Arguments None Contents None","tags":"","loc":"proc/arrangelargertosmaller.html","title":"arrangeLargerToSmaller – Carrier Cross Sections"},{"text":"public subroutine displaceAtoms() Arguments None Contents None","tags":"","loc":"proc/displaceatoms.html","title":"displaceAtoms – Carrier Cross Sections"},{"text":"public subroutine writeNewAtomicPositions() Arguments None Contents None","tags":"","loc":"proc/writenewatomicpositions.html","title":"writeNewAtomicPositions – Carrier Cross Sections"},{"text":"public subroutine exportQEInput() Arguments None Contents None","tags":"","loc":"proc/exportqeinput.html","title":"exportQEInput – Carrier Cross Sections"},{"text":"public subroutine iknb(n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) Contents None","tags":"","loc":"proc/iknb.html","title":"iknb – Carrier Cross Sections"},{"text":"public subroutine iknb2(n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) Contents None","tags":"","loc":"proc/iknb2.html","title":"iknb2 – Carrier Cross Sections"},{"text":"public function lcg(s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer Contents None","tags":"","loc":"proc/lcg.html","title":"lcg – Carrier Cross Sections"},{"text":"public function msta1(x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer Contents None","tags":"","loc":"proc/msta1~2.html","title":"msta1 – Carrier Cross Sections"},{"text":"public function msta2(x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer Contents None","tags":"","loc":"proc/msta2~2.html","title":"msta2 – Carrier Cross Sections"},{"text":"public function envj(n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/envj~2.html","title":"envj – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents None","tags":"","loc":"proc/readinputs~2.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initializeLSF() Arguments None Contents None","tags":"","loc":"proc/initializelsf.html","title":"initializeLSF – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents None","tags":"","loc":"proc/initialize~3.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Arguments None Contents None","tags":"","loc":"proc/checkandupdateinput~2.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readPhononsVASP() Arguments None Contents None","tags":"","loc":"proc/readphononsvasp.html","title":"readPhononsVASP – Carrier Cross Sections"},{"text":"public subroutine readPhononsQE() Arguments None Contents None","tags":"","loc":"proc/readphononsqe.html","title":"readPhononsQE – Carrier Cross Sections"},{"text":"public subroutine computeGeneralizedDisplacements() Arguments None Contents None","tags":"","loc":"proc/computegeneralizeddisplacements~2.html","title":"computeGeneralizedDisplacements – Carrier Cross Sections"},{"text":"public subroutine computeVariables() Arguments None Contents None","tags":"","loc":"proc/computevariables~2.html","title":"computeVariables – Carrier Cross Sections"},{"text":"public subroutine arrangeLargerToSmaller() Arguments None Contents None","tags":"","loc":"proc/arrangelargertosmaller~2.html","title":"arrangeLargerToSmaller – Carrier Cross Sections"},{"text":"public subroutine lsfDeterministicFourPhononsByFourBands() Arguments None Contents None","tags":"","loc":"proc/lsfdeterministicfourphononsbyfourbands.html","title":"lsfDeterministicFourPhononsByFourBands – Carrier Cross Sections"},{"text":"public subroutine lsfOfConfigurationPj() Arguments None Contents None","tags":"","loc":"proc/lsfofconfigurationpj.html","title":"lsfOfConfigurationPj – Carrier Cross Sections"},{"text":"public subroutine calculatePlusMinusStates(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l Contents None","tags":"","loc":"proc/calculateplusminusstates.html","title":"calculatePlusMinusStates – Carrier Cross Sections"},{"text":"public subroutine distrubutePhononsInBands(m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l Contents None","tags":"","loc":"proc/distrubutephononsinbands.html","title":"distrubutePhononsInBands – Carrier Cross Sections"},{"text":"public subroutine lsfWithMphonons(m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes Contents None","tags":"","loc":"proc/lsfwithmphonons.html","title":"lsfWithMphonons – Carrier Cross Sections"},{"text":"public subroutine decimalToOther(iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) Contents None","tags":"","loc":"proc/decimaltoother.html","title":"decimalToOther – Carrier Cross Sections"},{"text":"public subroutine calculateDE(maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de Contents None","tags":"","loc":"proc/calculatede.html","title":"calculateDE – Carrier Cross Sections"},{"text":"public subroutine lsfMbyOneBand(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents None","tags":"","loc":"proc/lsfmbyoneband.html","title":"lsfMbyOneBand – Carrier Cross Sections"},{"text":"public subroutine lsfMbyTwoBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents None","tags":"","loc":"proc/lsfmbytwobands.html","title":"lsfMbyTwoBands – Carrier Cross Sections"},{"text":"public subroutine lsfMbyThreeBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents None","tags":"","loc":"proc/lsfmbythreebands.html","title":"lsfMbyThreeBands – Carrier Cross Sections"},{"text":"public subroutine writeLSFandCrossSection() Arguments None Contents None","tags":"","loc":"proc/writelsfandcrosssection.html","title":"writeLSFandCrossSection – Carrier Cross Sections"},{"text":"public subroutine init_random_seed() Arguments None Contents None","tags":"","loc":"proc/init_random_seed.html","title":"init_random_seed – Carrier Cross Sections"},{"text":"public subroutine iknb(n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) Contents None","tags":"","loc":"proc/iknb~2.html","title":"iknb – Carrier Cross Sections"},{"text":"public subroutine iknb2(n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) Contents None","tags":"","loc":"proc/iknb2~2.html","title":"iknb2 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy3() Arguments None Contents None","tags":"","loc":"proc/parallelisfsby3.html","title":"parallelIsFsBy3 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy4() Arguments None Contents None","tags":"","loc":"proc/parallelisfsby4.html","title":"parallelIsFsBy4 – Carrier Cross Sections"},{"text":"public function lcg(s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer Contents None","tags":"","loc":"proc/lcg~2.html","title":"lcg – Carrier Cross Sections"},{"text":"public function msta1(x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer Contents None","tags":"","loc":"proc/msta1~3.html","title":"msta1 – Carrier Cross Sections"},{"text":"public function msta2(x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer Contents None","tags":"","loc":"proc/msta2~3.html","title":"msta2 – Carrier Cross Sections"},{"text":"public function envj(n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/envj~3.html","title":"envj – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents None","tags":"","loc":"proc/readinputs~3.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initializeLSF() Arguments None Contents None","tags":"","loc":"proc/initializelsf~2.html","title":"initializeLSF – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents None","tags":"","loc":"proc/initialize~4.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Arguments None Contents None","tags":"","loc":"proc/checkandupdateinput~3.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readPhonons() Arguments None Contents None","tags":"","loc":"proc/readphonons~2.html","title":"readPhonons – Carrier Cross Sections"},{"text":"public subroutine computeGeneralizedDisplacements() Arguments None Contents None","tags":"","loc":"proc/computegeneralizeddisplacements~3.html","title":"computeGeneralizedDisplacements – Carrier Cross Sections"},{"text":"public subroutine computeVariables() Arguments None Contents None","tags":"","loc":"proc/computevariables~3.html","title":"computeVariables – Carrier Cross Sections"},{"text":"public subroutine arrangeLargerToSmaller() Arguments None Contents None","tags":"","loc":"proc/arrangelargertosmaller~3.html","title":"arrangeLargerToSmaller – Carrier Cross Sections"},{"text":"public subroutine readMjs() Arguments None Contents None","tags":"","loc":"proc/readmjs.html","title":"readMjs – Carrier Cross Sections"},{"text":"public subroutine lsfDeterministicFourPhononsByFourBands() Arguments None Contents None","tags":"","loc":"proc/lsfdeterministicfourphononsbyfourbands~2.html","title":"lsfDeterministicFourPhononsByFourBands – Carrier Cross Sections"},{"text":"public subroutine lsfOfConfigurationPj() Arguments None Contents None","tags":"","loc":"proc/lsfofconfigurationpj~2.html","title":"lsfOfConfigurationPj – Carrier Cross Sections"},{"text":"public subroutine calculatePlusMinusStates(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l Contents None","tags":"","loc":"proc/calculateplusminusstates~2.html","title":"calculatePlusMinusStates – Carrier Cross Sections"},{"text":"public subroutine distrubutePhononsInBands(m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l Contents None","tags":"","loc":"proc/distrubutephononsinbands~2.html","title":"distrubutePhononsInBands – Carrier Cross Sections"},{"text":"public subroutine lsfWithMphonons(m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes Contents None","tags":"","loc":"proc/lsfwithmphonons~2.html","title":"lsfWithMphonons – Carrier Cross Sections"},{"text":"public subroutine decimalToOther(iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) Contents None","tags":"","loc":"proc/decimaltoother~2.html","title":"decimalToOther – Carrier Cross Sections"},{"text":"public subroutine calculateDE(maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de Contents None","tags":"","loc":"proc/calculatede~2.html","title":"calculateDE – Carrier Cross Sections"},{"text":"public subroutine lsfMbyOneBand(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents None","tags":"","loc":"proc/lsfmbyoneband~2.html","title":"lsfMbyOneBand – Carrier Cross Sections"},{"text":"public subroutine lsfMbyTwoBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents None","tags":"","loc":"proc/lsfmbytwobands~2.html","title":"lsfMbyTwoBands – Carrier Cross Sections"},{"text":"public subroutine lsfMbyThreeBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents None","tags":"","loc":"proc/lsfmbythreebands~2.html","title":"lsfMbyThreeBands – Carrier Cross Sections"},{"text":"public subroutine writeLSFandCrossSection() Arguments None Contents None","tags":"","loc":"proc/writelsfandcrosssection~2.html","title":"writeLSFandCrossSection – Carrier Cross Sections"},{"text":"public subroutine init_random_seed() Arguments None Contents None","tags":"","loc":"proc/init_random_seed~2.html","title":"init_random_seed – Carrier Cross Sections"},{"text":"public subroutine iknb(n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) Contents None","tags":"","loc":"proc/iknb~3.html","title":"iknb – Carrier Cross Sections"},{"text":"public subroutine iknb2(n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) Contents None","tags":"","loc":"proc/iknb2~3.html","title":"iknb2 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy3() Arguments None Contents None","tags":"","loc":"proc/parallelisfsby3~2.html","title":"parallelIsFsBy3 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy4() Arguments None Contents None","tags":"","loc":"proc/parallelisfsby4~2.html","title":"parallelIsFsBy4 – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents Source Code readInputs Source Code subroutine readInputs () ! implicit none ! ! Check if an output file exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , elphscat , iostat = ios ) ! call checkInputAndUpdateParameters () ! call readLSF () ! call readVfis () ! return ! end subroutine readInputs","tags":"","loc":"proc/readinputs~4.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents Source Code initialize Source Code subroutine initialize () ! implicit none ! VfisInput = '' LSFinput = '' crossSectionOutput = '' ! de = maxEnergy * eVToHartree / real ( nOfEnergyBins , dp ) ! return ! end subroutine initialize","tags":"","loc":"proc/initialize~5.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkInputAndUpdateParameters() Arguments None Contents Source Code checkInputAndUpdateParameters Source Code subroutine checkInputAndUpdateParameters () ! implicit none ! if ( VfisInput == '' ) then write ( iostd , '(\" Vfi elements input (input variable VfisInput) is not defined!\")' ) else inquire ( file = trim ( VfisInput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" Vfi elements input : \", a)' ) trim ( VfisInput ) else write ( iostd , '(\" Vfi elements input : \", a, \" does not exist!\")' ) trim ( VfisInput ) endif endif ! if ( LSFinput == '' ) then write ( iostd , '(\" LSF input (input variable LSFinput) is not defined!\")' ) else inquire ( file = trim ( LSFinput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" LSF input : \", a)' ) trim ( LSFinput ) else write ( iostd , '(\" LSF input : \", a, \" does not exist!\")' ) trim ( LSFinput ) endif endif ! if ( crossSectionOutput == '' ) then write ( iostd , '(\" crossSectionOutput is not defined! File name : crossSection, will be used.\")' ) crossSectionOutput = 'crossSection' else write ( iostd , '(\" Cross section output file name : \", a)' ) trim ( crossSectionOutput ) endif ! if ( ( VfisInput == '' ) . or . ( LSFinput == '' ) ) then ! write ( iostd , '(\" One or both of the input files is not defined! \")' ) write ( iostd , '(\" ********************************************** \")' ) write ( iostd , '(\" *               Program stops!               * \")' ) write ( iostd , '(\" *       Please check the output file.        * \")' ) write ( iostd , '(\" ********************************************** \")' ) ! stop ! endif ! flush ( iostd ) ! return ! end subroutine checkInputAndUpdateParameters","tags":"","loc":"proc/checkinputandupdateparameters.html","title":"checkInputAndUpdateParameters – Carrier Cross Sections"},{"text":"public subroutine readLSF() Arguments None Contents Source Code readLSF Source Code subroutine readLSF () ! implicit none ! character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! real ( kind = dp ) :: ee ! integer :: iE ! open ( 1 , file = trim ( LSFinput ), status = 'old' ) ! read ( 1 , '(a1, i10, a9, i5, a8)' ) dummyC1 , nEnergies , dummyC9 , m , dummyC8 ! allocate ( E ( - nEnergies : nEnergies ), lsfVsE ( - nEnergies : nEnergies ), lsfVsEbyPhonon ( - nEnergies : nEnergies ) ) ! do iE = - nEnergies , nEnergies ! read ( 1 , '(F16.8,2E18.6e3)' ) ee , lsfVsE ( iE ), lsfVsEbyPhonon ( iE ) E ( iE ) = ee * eVToHartree ! enddo ! close ( 1 ) ! end subroutine readLSF","tags":"","loc":"proc/readlsf.html","title":"readLSF – Carrier Cross Sections"},{"text":"public subroutine readVfis() Arguments None Contents Source Code readVfis Source Code subroutine readVfis () ! implicit none ! integer :: i , iE0 , iE real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , VfiOfE , VfiOfE0 , eBin character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 ! open ( 1 , file = trim ( VfisInput ), status = \"old\" ) ! !read(1, '(a1, i10, a9, f15.4, a16)') dummyC1, nEVfi, dummyC9, volume, dummyC16 ! read ( 1 , * ) read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 read ( 1 , * ) ! read ( 1 , '(i10)' ) numOfVfis ! allocate ( Vfis ( 0 : numOfVfis ), energy ( 0 : numOfVfis ), lsf ( 0 : numOfVfis ) ) ! Vfis (:) = 0.0_dp energy (:) = 0.0_dp lsf (:) = 0.0_dp ! read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE0 , dummyD1 ! Vfis ( 1 ) = VfiOfE0 energy ( 1 ) = Ee ! iE = int ( Ee / de ) + 1 ! do i = 2 , numOfVfis ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE , dummyD2 energy ( i ) = Ee iE = int ( Ee / de ) + 1 !Vfis(iE0:iE) = VfiOfE0 Vfis ( i ) = VfiOfE !VfiOfE0 = VfiOfE lsf ( i - 1 ) = sum ( lsfVsE ( iE0 : iE )) / ( iE - iE0 + 1 ) write ( 26 , * ) E ( iE0 ), Ee , lsf ( i ) ! sum(lsfVsE(iE0:iE))/(iE-iE0+1) ! enddo ! close ( 1 ) close ( 26 ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies write ( 44 , * ) energy ( iE ) * HartreeToEv , Vfis ( iE ), lsf ( iE ) enddo ! close ( 44 ) ! return ! end subroutine readVfis","tags":"","loc":"proc/readvfis.html","title":"readVfis – Carrier Cross Sections"},{"text":"public subroutine calculateSigma() Arguments None Contents Source Code calculateSigma Source Code subroutine calculateSigma () ! implicit none ! integer :: iE real ( kind = dp ) :: vg , sigma0 ! allocate ( sigma ( numOfVfis ) ) ! , sigmaByPhonon(-nEnergies:nEnergies) ) !allocate( sigma(-nEnergies:nEnergies), sigmaByPhonon(-nEnergies:nEnergies) ) ! iE = int ( eifMin / de ) + 1 write ( 6 , * ) eifMin , eifMin * HartreeToEv , iE sigma0 = twoPi * abCM ** 2 * volume * DHifMin * lsfVsE ( iE ) / sqrt ( 2.0_dp * E ( iE )) ! !do iE = 1, numOfVfis ! -nEnergies, nEnergies - 1 !  if ( (E(iE) < eifMin).and.(E(iE+1) > eifMin) ) sigma0 = twoPi*abCM**2*volume*DHifMin*lsfVsE(iE)/sqrt(2.0_dp*E(iE)) !enddo ! write ( 6 , * ) eifMin * HartreeToEv , sigma0 ! sigma (:) = 0.0_dp ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies vg = 1.0_dp if ( energy ( iE ) > 0.0_dp ) vg = sqrt ( 2.0_dp * energy ( iE )) !write(6,*) iE, energy(iE), vg, Vfis(iE), lsf(iE) sigma ( iE ) = twoPi * abCM ** 2 * volume * Vfis ( iE ) * lsf ( iE ) / vg !sigma(iE)         = twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg !sigmaByPhonon(iE) = twoPi*abCM**2*volume*Vfis(iE)*lsfVsEbyPhonon(iE)/vg enddo ! return ! end subroutine calculateSigma","tags":"","loc":"proc/calculatesigma.html","title":"calculateSigma – Carrier Cross Sections"},{"text":"public subroutine writeSigma() Arguments None Contents Source Code writeSigma Source Code subroutine writeSigma () ! implicit none ! integer :: iE ! open ( 2 , file = trim ( crossSectionOutput ), status = 'unknown' ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies ! write ( 2 , * ) energy ( iE ) * HartreeToEv , sigma ( iE ) !, sigmaByPhonon(iE) !write(2,*) E(iE), sigma(iE), sigmaByPhonon(iE) ! enddo ! close ( 2 ) ! return ! end subroutine writeSigma","tags":"","loc":"proc/writesigma.html","title":"writeSigma – Carrier Cross Sections"},{"text":"Uses io_global kinds parameters Contents Variables file_version restart_module_verbosity Subroutines write_restart_wfc Variables Type Visibility Attributes Name Initial integer, public, parameter :: file_version = 202 integer, public :: restart_module_verbosity = 0 Subroutines public subroutine write_restart_wfc (iuni, exportDir, ik, nk, kunit, ispin, nspin, scal, wf0, t0, wfm, tm, ngw, gamma_only, nbnd, igl, ngwl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iuni character(len=256), intent(in) :: exportDir integer, intent(in) :: ik integer, intent(in) :: nk integer, intent(in) :: kunit integer, intent(in) :: ispin integer, intent(in) :: nspin real(kind=DP), intent(in) :: scal complex(kind=DP), intent(in) :: wf0 (:,:) logical, intent(in) :: t0 complex(kind=DP), intent(in) :: wfm (:,:) logical, intent(in) :: tm integer, intent(in) :: ngw logical, intent(in) :: gamma_only integer, intent(in) :: nbnd integer, intent(in) :: igl (:) integer, intent(in) :: ngwl","tags":"","loc":"module/io_base_export.html","title":"io_base_export – Carrier Cross Sections"},{"text":"Declare all global variables\n and house all subroutines Used to group the variables read in from the .in file Contents Variables dp iostd root evToHartree HartreeToEv pi sq4pi ii output fftxMin fftxMax fftyMin fftyMax fftzMin fftzMax gx gy gz i iBandFfinal iBandFinit iBandIfinal iBandIinit ibf ibi id ierr ig ik ind2 ios iPn iTypes j JMAX kf ki maxL myid n n1 n2 n3 n4 nBands nF nGf nGi nGvsF nGvsI nI nIonsPC nIonsSD nKpts nKptsPC np nPP nProjsPC nProjsSD npw npwMf npwMi npwNf npwNi nSquareProcs nSpins numOfGvecs numOfPWs numOfPWsPC numOfPWsSD numOfTypes numOfTypesPC numOfUsedGvecsPP numprocs eBin t0 tf omega threej paw paw2 pseudo1 pseudo2 calculateVfis coulomb gamma_only master tmes_file_exists elementsPath exportDirSD exportDirPC input inputPC mkdir textDum VfisOutput counts displmnt groundState igvs iqs nFs ngs nIs nPWsI nPWsF npwsPC npwsSD pwGindPC pwGindSD pwGvecs pwGs TYPNIPC TYPNISD at bg absVfi2 DE eigvF eigvI gvecs posIonPC posIonSD wk wkPC xk xkPC betaPC betaSD cProjBetaPCPsiSD cProjBetaSDPhiPC cProjPC cProjSD paw_id paw_fi pawKPC paw_PsiPC pawPsiPC pawSDK paw_SDPhi pawSDPhi paw_SDKKPC Ufi wfcPC wfcSD atoms atomsPC vecs newVecs Derived Types atom vec Subroutines readInput initialize checkInitialization readInputPC distributePWsToProcs int2str finalizeCalculation readPWsSet readWfcPC projectBetaPCwfcSD readWfcSD readInputSD calculatePWsOverlap readProjectionsPC readProjectionsSD projectBetaSDwfcPC pawCorrectionKPC pawCorrectionSDK pawCorrectionPsiPC pawCorrectionSDPhi pawCorrection readEigenvalues calculateVfiElements checkIfCalculated readUfis writeResults bessel_j ylm Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) Used to set real variables to double precision integer, public, parameter :: iostd = 16 Unit number for output file integer, public, parameter :: root = 0 ID of the root process real(kind=dp), public, parameter :: evToHartree = 0.03674932538878_dp Conversion factor from eV to Hartree real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp Conversion factor from Hartree to eV real(kind=dp), public, parameter :: pi = 3.141592653589793_dp Pi real(kind=dp), public, parameter :: sq4pi = 3.544907701811032_dp \\sqrt{4\\pi} complex(kind=dp), public, parameter :: ii = cmplx(0.0_dp, 1.0_dp, kind=dp) Complex i character(len=6), public, parameter :: output = 'output' Name of the output file;\n used in readInput integer, public :: fftxMin integer, public :: fftxMax integer, public :: fftyMin integer, public :: fftyMax integer, public :: fftzMin integer, public :: fftzMax integer, public :: gx integer, public :: gy integer, public :: gz integer, public :: i integer, public :: iBandFfinal integer, public :: iBandFinit integer, public :: iBandIfinal integer, public :: iBandIinit integer, public :: ibf integer, public :: ibi integer, public :: id integer, public :: ierr Error code returned from MPI integer, public :: ig integer, public :: ik integer, public :: ind2 integer, public :: ios Status returned from I/O commands integer, public :: iPn integer, public :: iTypes integer, public :: j integer, public :: JMAX integer, public :: kf integer, public :: ki integer, public :: maxL integer, public :: myid ID for each MPI process integer, public :: n integer, public :: n1 integer, public :: n2 integer, public :: n3 integer, public :: n4 integer, public :: nBands integer, public :: nF integer, public :: nGf integer, public :: nGi integer, public :: nGvsF integer, public :: nGvsI integer, public :: nI integer, public :: nIonsPC integer, public :: nIonsSD integer, public :: nKpts integer, public :: nKptsPC integer, public :: np integer, public :: nPP integer, public :: nProjsPC integer, public :: nProjsSD integer, public :: npw integer, public :: npwMf integer, public :: npwMi integer, public :: npwNf integer, public :: npwNi integer, public :: nSquareProcs integer, public :: nSpins integer, public :: numOfGvecs integer, public :: numOfPWs integer, public :: numOfPWsPC integer, public :: numOfPWsSD integer, public :: numOfTypes integer, public :: numOfTypesPC integer, public :: numOfUsedGvecsPP integer, public :: numprocs Number of processes in the MPI pool real(kind=dp), public :: eBin real(kind=dp), public :: t0 Start time for program real(kind=dp), public :: tf End time for program real(kind=dp), public :: omega real(kind=dp), public :: threej complex(kind=dp), public :: paw complex(kind=dp), public :: paw2 complex(kind=dp), public :: pseudo1 complex(kind=dp), public :: pseudo2 logical, public :: calculateVfis logical, public :: coulomb logical, public :: gamma_only logical, public :: master logical, public :: tmes_file_exists character(len=300), public :: elementsPath character(len=200), public :: exportDirSD SD output directory from the pw_export_for_TME program character(len=200), public :: exportDirPC PC output directory from the pw_export_for_TME program character(len=300), public :: input character(len=300), public :: inputPC character(len=320), public :: mkdir Command for creating the elements path directory character(len=300), public :: textDum Dummy variable to hold unneeded lines from input file character(len=200), public :: VfisOutput Output file for ?? integer, public, allocatable :: counts (:) integer, public, allocatable :: displmnt (:) integer, public, allocatable :: groundState (:) integer, public, allocatable :: igvs (:,:,:) integer, public, allocatable :: iqs (:) integer, public, allocatable :: nFs (:,:) integer, public, allocatable :: ngs (:,:) integer, public, allocatable :: nIs (:,:) integer, public, allocatable :: nPWsI (:) integer, public, allocatable :: nPWsF (:) integer, public, allocatable :: npwsPC (:) integer, public, allocatable :: npwsSD (:) integer, public, allocatable :: pwGindPC (:) integer, public, allocatable :: pwGindSD (:) integer, public, allocatable :: pwGvecs (:,:) integer, public, allocatable :: pwGs (:,:) integer, public, allocatable :: TYPNIPC (:) integer, public, allocatable :: TYPNISD (:) real(kind=dp), public :: at (3,3) real(kind=dp), public :: bg (3,3) real(kind=dp), public, allocatable :: absVfi2 (:,:) real(kind=dp), public, allocatable :: DE (:,:) real(kind=dp), public, allocatable :: eigvF (:) real(kind=dp), public, allocatable :: eigvI (:) real(kind=dp), public, allocatable :: gvecs (:,:) real(kind=dp), public, allocatable :: posIonPC (:,:) real(kind=dp), public, allocatable :: posIonSD (:,:) real(kind=dp), public, allocatable :: wk (:) real(kind=dp), public, allocatable :: wkPC (:) real(kind=dp), public, allocatable :: xk (:,:) real(kind=dp), public, allocatable :: xkPC (:,:) complex(kind=dp), public, allocatable :: betaPC (:,:) complex(kind=dp), public, allocatable :: betaSD (:,:) complex(kind=dp), public, allocatable :: cProjBetaPCPsiSD (:,:,:) complex(kind=dp), public, allocatable :: cProjBetaSDPhiPC (:,:,:) complex(kind=dp), public, allocatable :: cProjPC (:,:,:) complex(kind=dp), public, allocatable :: cProjSD (:,:,:) complex(kind=dp), public, allocatable :: paw_id (:,:) complex(kind=dp), public, allocatable :: paw_fi (:,:) complex(kind=dp), public, allocatable :: pawKPC (:,:,:) complex(kind=dp), public, allocatable :: paw_PsiPC (:,:) complex(kind=dp), public, allocatable :: pawPsiPC (:,:) complex(kind=dp), public, allocatable :: pawSDK (:,:,:) complex(kind=dp), public, allocatable :: paw_SDPhi (:,:) complex(kind=dp), public, allocatable :: pawSDPhi (:,:) complex(kind=dp), public, allocatable :: paw_SDKKPC (:,:) complex(kind=dp), public, allocatable :: Ufi (:,:,:) complex(kind=dp), public, allocatable :: wfcPC (:,:) complex(kind=dp), public, allocatable :: wfcSD (:,:) type( atom ), public, allocatable :: atoms (:) type( atom ), public, allocatable :: atomsPC (:) type( vec ), public, allocatable :: vecs (:) type( vec ), public, allocatable :: newVecs (:) Derived Types type, public :: atom Define a new type to represent an atom in the structure. \n Each different type of atom in the structure will be another\n variable with the type atom . Components Type Visibility Attributes Name Initial integer, public :: iRc integer, public :: numOfAtoms Number of atoms of a specific type in the structure integer, public :: lMax integer, public :: lmMax integer, public :: nMax character(len=2), public :: symbol integer, public, allocatable :: lps (:) real(kind=dp), public, allocatable :: bes_J_qr (:,:) real(kind=dp), public, allocatable :: F (:,:) real(kind=dp), public, allocatable :: F1 (:,:,:) real(kind=dp), public, allocatable :: F2 (:,:,:) real(kind=dp), public, allocatable :: r (:) real(kind=dp), public, allocatable :: rab (:) real(kind=dp), public, allocatable :: wae (:,:) real(kind=dp), public, allocatable :: wps (:,:) type, public :: vec Components Type Visibility Attributes Name Initial integer, public :: ind integer, public, allocatable :: igN (:) integer, public, allocatable :: igM (:) Subroutines public subroutine readInput () Delete any previous output, initialize input variables,\n start a timer, and read in the input files Read more… Arguments None public subroutine initialize () Set default values for all of the input variables\n that can easily be tested to see if they were changed Read more… Arguments None public subroutine checkInitialization () Check to see if variables from .in file still\n have the values set in initialize or if they have values that aren't allowed Read more… Arguments None public subroutine readInputPC () Read input files in the Export directory created by pw_export_for_TME Read more… Arguments None public subroutine distributePWsToProcs (nOfPWs, nOfBlocks) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nOfPWs integer, intent(in) :: nOfBlocks public subroutine int2str (integ, string) Arguments Type Intent Optional Attributes Name integer :: integ character(len=300) :: string public subroutine finalizeCalculation () Arguments None public subroutine readPWsSet () Arguments None public subroutine readWfcPC (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine projectBetaPCwfcSD (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine readWfcSD (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine readInputSD () Arguments None public subroutine calculatePWsOverlap (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine readProjectionsPC (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine readProjectionsSD (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine projectBetaSDwfcPC (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine pawCorrectionKPC () Arguments None public subroutine pawCorrectionSDK () Arguments None public subroutine pawCorrectionPsiPC () Arguments None public subroutine pawCorrectionSDPhi () Arguments None public subroutine pawCorrection () Arguments None public subroutine readEigenvalues (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine calculateVfiElements () Arguments None public subroutine checkIfCalculated (ik, tmes_file_exists) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik logical, intent(out) :: tmes_file_exists public subroutine readUfis (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine writeResults (ik) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik public subroutine bessel_j (x, lmax, jl) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: lmax real(kind=dp), intent(out) :: jl (0:lmax) public subroutine ylm (V_in, LMAX, Y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_in (3) integer, intent(in) :: LMAX complex(kind=dp), intent(out) :: Y (*)","tags":"","loc":"module/tmemodule.html","title":"TMEModule – Carrier Cross Sections"},{"text":"read ( 1 , ' (d22.14,i5,4d22.14) ' ) E , dummyI , dummyD , MjsOfE0 , dummyD ! E = E * eVToHartree iE = int ( E / deltaE ) + 1 ! do i = 1 , nEMjs - 1 ! iE0 = iE read ( 1 , ' (d22.14,i5,4d22.14) ' ) E , dummyI , dummyD , MjsOfE , dummyD E = E * eVToHartree iE = int ( E / deltaE ) + 1 Mjs ( iE0 : iE ) = MjsOfE0 MjsOfE0 = MjsOfE ! enddo ! close ( 1 ) ! ! do iE = - nEnergies , nEnergies ! write ( 44 , * ) real ( iE , dp ) * deltaE * HartreeToEv , Mjs ( iE ) ! enddo ! Contents Variables dp int32 int64 iostd un pi twopi abCM THzToHartree HartreeToEv eVToHartree nAtoms nOfqPoints nModes ios ti tf t1 t2 temperature kT s2L atomD atomM phonQ phonF genCoord atomPosition newAtomicPosition wby2kT phonD x Sj coth besOrderNofModeM maxDisplacement modeI modeF qPoint elements output phononsInput equilibriumAtomicPositions newAtomicPositions QEInput file_exists readQEInput Functions msta1 msta2 envj Subroutines readInputs initialize checkAndUpdateInput readPhonons readAtomicPositions computeGeneralizedDisplacements computeVariables arrangeLargerToSmaller displaceAtoms writeNewAtomicPositions exportQEInput iknb iknb2 Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: iostd = 16 integer, public, parameter :: un = 3 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: THzToHartree = 1.0_dp/6579.683920729_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer, public :: nAtoms integer, public :: nOfqPoints integer, public :: nModes integer, public :: ios real(kind=dp), public :: ti real(kind=dp), public :: tf real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: temperature real(kind=dp), public :: kT integer, public, allocatable :: s2L (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: atomPosition (:,:) real(kind=dp), public, allocatable :: newAtomicPosition (:,:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: x (:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public :: maxDisplacement integer, public :: modeI integer, public :: modeF integer, public :: qPoint character(len=2), public, allocatable :: elements (:) character(len=6), public, parameter :: output = 'status' character(len=256), public :: phononsInput character(len=256), public :: equilibriumAtomicPositions character(len=256), public :: newAtomicPositions character(len=256), public :: QEInput logical, public :: file_exists logical, public :: readQEInput Functions public function msta1 (x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer public function msta2 (x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer public function envj (n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public subroutine readInputs () Arguments None public subroutine initialize () Arguments None public subroutine checkAndUpdateInput () Arguments None public subroutine readPhonons () Arguments None public subroutine readAtomicPositions () Arguments None public subroutine computeGeneralizedDisplacements () Arguments None public subroutine computeVariables () Arguments None public subroutine arrangeLargerToSmaller () Arguments None public subroutine displaceAtoms () Arguments None public subroutine writeNewAtomicPositions () Arguments None public subroutine exportQEInput () Arguments None public subroutine iknb (n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) public subroutine iknb2 (n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n)","tags":"","loc":"module/mjmodule.html","title":"MjModule – Carrier Cross Sections"},{"text":"Contents Variables dp int32 int64 iostd un root pi twopi abCM THzToHartree HartreeToEv eVToHartree myid numprocs ios istat ierr iMode l m nMC nProcMax iMint iMmod i printsteps iE ni mi nAtoms nOfqPoints nModes minimumNumberOfPhonons maximumNumberOfPhonons nEnergies ti tf t1 t2 weight times de E temperature maxEnergy deltaE kT iModeIs iModeFs pj pj0s pms s2L iEbinsByBands iEbinsByPhonons atomD atomM phonQ phonF genCoord wby2kT phonD x Sj coth besOrderNofModeM lsfVsEbyBands lsfVsE lsfVsEbyPhonons lsfbyPhononsPerProc output phononsInputFormat phononsInput fn continueLSFfromFile file_exists Functions lcg msta1 msta2 envj Subroutines readInputs initializeLSF initialize checkAndUpdateInput readPhononsVASP readPhononsQE computeGeneralizedDisplacements computeVariables arrangeLargerToSmaller lsfDeterministicFourPhononsByFourBands lsfOfConfigurationPj calculatePlusMinusStates distrubutePhononsInBands lsfWithMphonons decimalToOther calculateDE lsfMbyOneBand lsfMbyTwoBands lsfMbyThreeBands writeLSFandCrossSection init_random_seed iknb iknb2 parallelIsFsBy3 parallelIsFsBy4 Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: iostd = 16 integer, public, parameter :: un = 3 integer, public, parameter :: root = 0 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: THzToHartree = 1.0_dp/6579.683920729_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer(kind=int32), public :: myid integer(kind=int32), public :: numprocs integer(kind=int32), public :: ios integer(kind=int32), public :: istat integer(kind=int32), public :: ierr integer, public :: iMode integer, public :: l integer, public :: m integer, public :: nMC integer, public :: nProcMax integer, public :: iMint integer, public :: iMmod integer, public :: i integer, public :: printsteps integer, public :: iE integer, public :: ni integer, public :: mi integer, public :: nAtoms integer, public :: nOfqPoints integer, public :: nModes integer, public :: minimumNumberOfPhonons integer, public :: maximumNumberOfPhonons integer, public :: nEnergies real(kind=dp), public :: ti real(kind=dp), public :: tf real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: weight real(kind=dp), public :: times real(kind=dp), public :: de real(kind=dp), public :: E real(kind=dp), public :: temperature real(kind=dp), public :: maxEnergy real(kind=dp), public :: deltaE real(kind=dp), public :: kT integer, public, allocatable :: iModeIs (:) integer, public, allocatable :: iModeFs (:) integer, public, allocatable :: pj (:) integer, public, allocatable :: pj0s (:,:) integer, public, allocatable :: pms (:,:) integer, public, allocatable :: s2L (:) integer, public, allocatable :: iEbinsByBands (:) integer, public, allocatable :: iEbinsByPhonons (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: x (:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public, allocatable :: lsfVsEbyBands (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonons (:) real(kind=dp), public, allocatable :: lsfbyPhononsPerProc (:) character(len=6), public, parameter :: output = 'status' character(len=256), public :: phononsInputFormat character(len=256), public :: phononsInput character(len=256), public :: fn character(len=256), public :: continueLSFfromFile logical, public :: file_exists Functions public function lcg (s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer public function msta1 (x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer public function msta2 (x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer public function envj (n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public subroutine readInputs () Arguments None public subroutine initializeLSF () Arguments None public subroutine initialize () Arguments None public subroutine checkAndUpdateInput () Arguments None public subroutine readPhononsVASP () Arguments None public subroutine readPhononsQE () Arguments None public subroutine computeGeneralizedDisplacements () Arguments None public subroutine computeVariables () Arguments None public subroutine arrangeLargerToSmaller () Arguments None public subroutine lsfDeterministicFourPhononsByFourBands () Arguments None public subroutine lsfOfConfigurationPj () Arguments None public subroutine calculatePlusMinusStates (l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l public subroutine distrubutePhononsInBands (m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l public subroutine lsfWithMphonons (m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes public subroutine decimalToOther (iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) public subroutine calculateDE (maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de public subroutine lsfMbyOneBand (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyTwoBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyThreeBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine writeLSFandCrossSection () Arguments None public subroutine init_random_seed () Arguments None public subroutine iknb (n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) public subroutine iknb2 (n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) public subroutine parallelIsFsBy3 () Arguments None public subroutine parallelIsFsBy4 () Arguments None","tags":"","loc":"module/lsf.html","title":"lsf – Carrier Cross Sections"},{"text":"Contents Variables dp int32 int64 iostd un root pi twopi abCM THzToHartree HartreeToEv eVToHartree myid numprocs ios istat ierr iMode l m nMC nProcMax iMint iMmod i printsteps iE ni mi nAtoms nOfqPoints nModes minimumNumberOfPhonons maximumNumberOfPhonons nEnergies ti tf t1 t2 weight times de E temperature maxEnergy deltaE kT iModeIs iModeFs pj pj0s pms s2L iEbinsByBands iEbinsByPhonons atomD atomM phonQ phonF genCoord Mjs wby2kT phonD x Sj coth besOrderNofModeM lsfVsEbyBands lsfVsE lsfVsEbyPhonons lsfbyPhononsPerProc modes output MjsInput phononsInput fn continueLSFfromFile equilibriumAtomicPositions file_exists Functions lcg msta1 msta2 envj Subroutines readInputs initializeLSF initialize checkAndUpdateInput readPhonons computeGeneralizedDisplacements computeVariables arrangeLargerToSmaller readMjs lsfDeterministicFourPhononsByFourBands lsfOfConfigurationPj calculatePlusMinusStates distrubutePhononsInBands lsfWithMphonons decimalToOther calculateDE lsfMbyOneBand lsfMbyTwoBands lsfMbyThreeBands writeLSFandCrossSection init_random_seed iknb iknb2 parallelIsFsBy3 parallelIsFsBy4 Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: iostd = 16 integer, public, parameter :: un = 3 integer, public, parameter :: root = 0 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: THzToHartree = 1.0_dp/6579.683920729_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer(kind=int32), public :: myid integer(kind=int32), public :: numprocs integer(kind=int32), public :: ios integer(kind=int32), public :: istat integer(kind=int32), public :: ierr integer, public :: iMode integer, public :: l integer, public :: m integer, public :: nMC integer, public :: nProcMax integer, public :: iMint integer, public :: iMmod integer, public :: i integer, public :: printsteps integer, public :: iE integer, public :: ni integer, public :: mi integer, public :: nAtoms integer, public :: nOfqPoints integer, public :: nModes integer, public :: minimumNumberOfPhonons integer, public :: maximumNumberOfPhonons integer, public :: nEnergies real(kind=dp), public :: ti real(kind=dp), public :: tf real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: weight real(kind=dp), public :: times real(kind=dp), public :: de real(kind=dp), public :: E real(kind=dp), public :: temperature real(kind=dp), public :: maxEnergy real(kind=dp), public :: deltaE real(kind=dp), public :: kT integer, public, allocatable :: iModeIs (:) integer, public, allocatable :: iModeFs (:) integer, public, allocatable :: pj (:) integer, public, allocatable :: pj0s (:,:) integer, public, allocatable :: pms (:,:) integer, public, allocatable :: s2L (:) integer, public, allocatable :: iEbinsByBands (:) integer, public, allocatable :: iEbinsByPhonons (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: Mjs (:,:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: x (:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public, allocatable :: lsfVsEbyBands (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonons (:) real(kind=dp), public, allocatable :: lsfbyPhononsPerProc (:) integer, public :: modes character(len=6), public, parameter :: output = 'status' character(len=256), public :: MjsInput character(len=256), public :: phononsInput character(len=256), public :: fn character(len=256), public :: continueLSFfromFile character(len=256), public :: equilibriumAtomicPositions logical, public :: file_exists Functions public function lcg (s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer public function msta1 (x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer public function msta2 (x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer public function envj (n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public subroutine readInputs () Arguments None public subroutine initializeLSF () Arguments None public subroutine initialize () Arguments None public subroutine checkAndUpdateInput () Arguments None public subroutine readPhonons () Arguments None public subroutine computeGeneralizedDisplacements () Arguments None public subroutine computeVariables () Arguments None public subroutine arrangeLargerToSmaller () Arguments None public subroutine readMjs () Arguments None public subroutine lsfDeterministicFourPhononsByFourBands () Arguments None public subroutine lsfOfConfigurationPj () Arguments None public subroutine calculatePlusMinusStates (l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l public subroutine distrubutePhononsInBands (m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l public subroutine lsfWithMphonons (m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes public subroutine decimalToOther (iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) public subroutine calculateDE (maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de public subroutine lsfMbyOneBand (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyTwoBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyThreeBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine writeLSFandCrossSection () Arguments None public subroutine init_random_seed () Arguments None public subroutine iknb (n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) public subroutine iknb2 (n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) public subroutine parallelIsFsBy3 () Arguments None public subroutine parallelIsFsBy4 () Arguments None","tags":"","loc":"module/lsf~2.html","title":"lsf – Carrier Cross Sections"},{"text":"Contents Variables dp int32 iostd maxEnergy nOfEnergyBins pi twopi abCM HartreeToEv eVToHartree ios nEnergies m numOfVfis volume de eifMin DHifMin E Vfis lsfVsE lsfVsEbyPhonon energy lsf sigma sigmaByPhonon lorentz lorentzByPhonon output VfisInput LSFinput crossSectionOutput file_exists Subroutines readInputs initialize checkInputAndUpdateParameters readLSF readVfis calculateSigma writeSigma Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: iostd = 16 real(kind=dp), public, parameter :: maxEnergy = 10.0_dp integer, public, parameter :: nOfEnergyBins = 5040 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer(kind=int32), public :: ios integer, public :: nEnergies integer, public :: m integer, public :: numOfVfis real(kind=dp), public :: volume real(kind=dp), public :: de real(kind=dp), public :: eifMin real(kind=dp), public :: DHifMin real(kind=dp), public, allocatable :: E (:) real(kind=dp), public, allocatable :: Vfis (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonon (:) real(kind=dp), public, allocatable :: energy (:) real(kind=dp), public, allocatable :: lsf (:) real(kind=dp), public, allocatable :: sigma (:) real(kind=dp), public, allocatable :: sigmaByPhonon (:) real(kind=dp), public, allocatable :: lorentz (:) real(kind=dp), public, allocatable :: lorentzByPhonon (:) character(len=11), public, parameter :: output = 'sigmaStatus' character(len=256), public :: VfisInput character(len=256), public :: LSFinput character(len=256), public :: crossSectionOutput logical, public :: file_exists Subroutines public subroutine readInputs () Arguments None public subroutine initialize () Arguments None public subroutine checkInputAndUpdateParameters () Arguments None public subroutine readLSF () Arguments None public subroutine readVfis () Arguments None public subroutine calculateSigma () Arguments None public subroutine writeSigma () Arguments None","tags":"","loc":"module/sigma_module.html","title":"sigma_module – Carrier Cross Sections"},{"text":"Uses wrappers pwcom io_global io_files ions_base iotk_module mp_global mp_pools mp_world mp environment Contents Variables trimcheck ik i kunittmp ios ryToHartree pp_file exportDir writeWFC Subroutines write_export Source Code pw_export_for_TME Variables Type Attributes Name Initial character(len=256), EXTERNAL :: trimcheck integer :: ik integer :: i integer :: kunittmp integer :: ios real(kind=dp), parameter :: ryToHartree = 0.5_dp character(len=256) :: pp_file character(len=256) :: exportDir logical :: writeWFC Subroutines subroutine write_export (pp_file, exportDir, kunit) Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: pp_file character(len=256), intent(in) :: exportDir integer, intent(in) :: kunit Source Code PROGRAM pw_export_for_TME !----------------------------------------------------------------------- ! ! writes PWSCF data for postprocessing purposes in XML format using IOTK lib ! Wave-functions are collected and written using IO_BASE module. ! ! input:  namelist \"&inputpp\", with variables !   prefix       prefix of input files saved by program pwscf !   outdir       temporary directory where files resides !   exportDir    output directory. A directory !                \"exportDir\" is created and !                output files are put there. All the data !                are accessible through the \"\"exportDir\"/input\" file. ! USE wrappers , ONLY : f_mkdir_safe USE pwcom USE io_global , ONLY : ionode , ionode_id USE io_files , ONLY : prefix , tmp_dir , outdir USE ions_base , ONLY : ntype => nsp USE iotk_module USE mp_global , ONLY : mp_startup USE mp_pools , ONLY : kunit USE mp_world , ONLY : world_comm USE mp , ONLY : mp_bcast USE environment , ONLY : environment_start ! IMPLICIT NONE ! CHARACTER ( LEN = 256 ), EXTERNAL :: trimcheck ! INTEGER :: ik , i , kunittmp , ios ! real ( kind = dp ), parameter :: ryToHartree = 0.5_dp ! CHARACTER ( len = 256 ) :: pp_file , exportDir LOGICAL :: writeWFC ! NAMELIST / inputpp / prefix , outdir , exportDir , writeWFC ! ! initialise environment ! #ifdef __MPI CALL mp_startup ( ) #endif CALL environment_start ( 'PW_EXPORT' ) ! !   set default values for variables in namelist ! prefix = '' CALL get_environment_variable ( 'ESPRESSO_TMPDIR' , outdir ) IF ( trim ( outdir ) == ' ' ) outdir = './' exportDir = './Export' ! writeWFC = . true . ! gdb : by default the wavefunctions are needed, !       this gives the user the ability not to write the wavefunctions ! !    Reading input file ! IF ( ionode ) THEN ! CALL input_from_file ( ) ! READ ( 5 , inputpp , IOSTAT = ios ) ! IF ( ios /= 0 ) CALL errore ( 'pw_export' , 'reading inputpp namelist' , abs ( ios ) ) ! ios = f_mkdir_safe ( trim ( exportDir ) ) ! pp_file = trim ( exportDir ) // \"/input\" ! ! ENDIF ! ! ... Broadcasting variables ! tmp_dir = trimcheck ( outdir ) CALL mp_bcast ( outdir , ionode_id , world_comm ) CALL mp_bcast ( tmp_dir , ionode_id , world_comm ) CALL mp_bcast ( prefix , ionode_id , world_comm ) ! !   Now allocate space for pwscf variables, read and check them. ! CALL read_file CALL openfil_pp ! #if defined __MPI kunittmp = kunit #else kunittmp = 1 #endif CALL write_export ( pp_file , exportDir , kunittmp ) CALL stop_pp ! CONTAINS ! !----------------------------------------------------------------------- SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export END PROGRAM pw_export_for_TME","tags":"","loc":"program/pw_export_for_tme.html","title":"pw_export_for_TME – Carrier Cross Sections"},{"text":"Uses mpi TMEModule Contents Variables t1 t2 Source Code transitionMatrixElements Variables Type Attributes Name Initial real(kind=dp) :: t1 real(kind=dp) :: t2 Source Code program transitionMatrixElements ! ! Use pre-built mpi library and declarations module that ! is defined in TME_Module_v28.f90 use mpi use TMEModule ! implicit none ! ! Declare start and end times real ( kind = dp ) :: t1 , t2 ! ! Initialize MPI environment call MPI_INIT ( ierr ) ! Determine the rank or ID of the calling process call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) ! Determine the size of the MPI pool (i.e., the number of processes) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! ! Allocate space for variables allocate ( nPWsI ( 0 : numprocs - 1 ), nPWsF ( 0 : numprocs - 1 ) ) ! ! If this is the root process if ( myid == root ) then ! ! Start a timer call cpu_time ( t0 ) ! ! Reading input, initializing and checking all variables of the calculation. call readInput () ! ! ???????????????????????????????? call readPWsSet () ! ! Allocate space for variables allocate ( counts ( 0 : numprocs - 1 ), displmnt ( 0 : numprocs - 1 ) ) allocate ( Ufi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nKptsPC ) ) allocate ( paw_SDKKPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_PsiPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_SDPhi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_fi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( eigvI ( iBandIinit : iBandIfinal ), eigvF ( iBandFinit : iBandFfinal ) ) ! ! Initialize all values in Ufi matrix to complex double zero Ufi (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! ! Distribute plane waves to processes ??? call distributePWsToProcs ( numOfGvecs , numprocs ) ! ! Initialize the number of initial and final plane waves to zero for each process nPWsI (:) = 0 nPWsF (:) = 0 ! ! For each process, calculate the number of initial and final plane waves do i = 0 , numprocs - 1 nPWsI ( i ) = 1 + sum ( counts (: i - 1 )) nPWsF ( i ) = sum ( counts (: i )) enddo ! endif ! ! Broadcast variables from root process to all other processes call MPI_BCAST ( iBandIinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandIfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nKptsPC , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nProjsPC , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nProjsSD , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nBands , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nSpins , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( numOfPWs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( numOfGvecs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nPWsI , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nPWsF , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( numOfTypesPC , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( JMAX , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! ! Have other processes allocate space for gvecs so that root can send to them if ( myid /= root ) allocate ( gvecs ( 3 , numOfGvecs ) ) call MPI_BCAST ( gvecs , size ( gvecs ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( atomsPC ( numOfTypesPC ) ) ! ! For each type of ??? do i = 1 , numOfTypesPC ! ! Broadcast the variables in the atomsPC structure array call MPI_BCAST ( atomsPC ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% lMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% iRc , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! ! Allocate space for arrays in atomsPC structure if ( myid /= root ) then allocate ( atomsPC ( i )% lps ( atomsPC ( i )% lMax ) ) allocate ( atomsPC ( i )% r ( atomsPC ( i )% nMax ) ) allocate ( atomsPC ( i )% rab ( atomsPC ( i )% nMax ) ) allocate ( atomsPC ( i )% F ( atomsPC ( i )% iRc , atomsPC ( i )% lMax ) ) allocate ( atomsPC ( i )% F1 ( atomsPC ( i )% iRc , atomsPC ( i )% lMax , atomsPC ( i )% lMax ) ) allocate ( atomsPC ( i )% bes_J_qr ( 0 : JMAX , atomsPC ( i )% iRc ) ) endif ! ! Broadcast arrays from root to all other processes call MPI_BCAST ( atomsPC ( i )% lps , size ( atomsPC ( i )% lps ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% r , size ( atomsPC ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% rab , size ( atomsPC ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% F , size ( atomsPC ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% F1 , size ( atomsPC ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atomsPC ( i )% bes_J_qr , size ( atomsPC ( i )% bes_J_qr ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( nIonsPC , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( posIonPC ( 3 , nIonsPC ), TYPNIPC ( nIonsPC ) ) call MPI_BCAST ( TYPNIPC , size ( TYPNIPC ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( posIonPC , size ( posIonPC ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( atoms ( numOfTypes ) ) ! do i = 1 , numOfTypes ! call MPI_BCAST ( atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% lMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% iRc , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( atoms ( i )% lps ( atoms ( i )% lMax ) ) allocate ( atoms ( i )% r ( atoms ( i )% nMax ) ) allocate ( atoms ( i )% rab ( atoms ( i )% nMax ) ) allocate ( atoms ( i )% F ( atoms ( i )% iRc , atoms ( i )% lMax ) ) allocate ( atoms ( i )% F1 ( atoms ( i )% iRc , atoms ( i )% lMax , atoms ( i )% lMax ) ) allocate ( atoms ( i )% bes_J_qr ( 0 : JMAX , atoms ( i )% iRc ) ) endif ! call MPI_BCAST ( atoms ( i )% lps , size ( atoms ( i )% lps ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% r , size ( atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% rab , size ( atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% F , size ( atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% F1 , size ( atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( atoms ( i )% bes_J_qr , size ( atoms ( i )% bes_J_qr ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( nIonsSD , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( posIonSD ( 3 , nIonsSD ), TYPNISD ( nIonsSD ) ) call MPI_BCAST ( TYPNISD , size ( TYPNISD ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( posIonSD , size ( posIonSD ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! allocate ( paw_id ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) ! do ik = 1 , nKptsPC ! if ( myid == root ) then ! tmes_file_exists = . false . call checkIfCalculated ( ik , tmes_file_exists ) ! endif ! call MPI_BCAST ( tmes_file_exists , 1 , MPI_LOGICAL , root , MPI_COMM_WORLD , ierr ) ! if ( . not . tmes_file_exists ) then ! allocate ( cProjPC ( nProjsPC , nBands , nSpins ) ) allocate ( cProjSD ( nProjsSD , nBands , nSpins ) ) ! if ( myid == root ) then ! write ( iostd , '(\" Starting Ufi(:,:) calculation for k-point\", i4, \" of\", i4)' ) ik , nKptsPC flush ( iostd ) ! write ( iostd , * ) write ( iostd , '(\"    Plane waves part begun.\")' ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> begun.\")' ) call cpu_time ( t1 ) allocate ( wfcPC ( numOfPWs , iBandIinit : iBandIfinal ), wfcSD ( numOfPWs , iBandFinit : iBandFfinal ) ) ! call calculatePWsOverlap ( ik ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! write ( iostd , '(\"    Plane waves part done in\", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) write ( iostd , '(\"    PAW part begun.\")' ) ! call cpu_time ( t1 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> begun.\")' ) flush ( iostd ) ! call readProjectionsPC ( ik ) ! allocate ( cProjBetaPCPsiSD ( nProjsPC , nBands , nSpins ) ) call projectBetaPCwfcSD ( ik ) ! deallocate ( wfcSD ) ! call pawCorrectionPsiPC () ! deallocate ( cProjBetaPCPsiSD ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 call cpu_time ( t1 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> begun.\")' ) flush ( iostd ) ! call readProjectionsSD ( ik ) ! allocate ( cProjBetaSDPhiPC ( nProjsSD , nBands , nSpins ) ) call projectBetaSDwfcPC ( ik ) ! deallocate ( wfcPC ) ! call pawCorrectionSDPhi () deallocate ( cProjBetaSDPhiPC ) ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! call cpu_time ( t1 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = paw_SDPhi(ibf,ibi) + paw_PsiPC(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6ES14.5E3)') ibi, ibf, paw_SDPhi(ibf,ibi), paw_PsiPC(ibf,ibi), paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! !call pawCorrection() !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = paw_SDPhi(ibf,ibi) + paw_PsiPC(ibf,ibi) + paw_fi(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf,ibi,ik), paw, Ufi(ibf,ibi,ik) + paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! endif ! call MPI_BCAST ( cProjPC , size ( cProjPC ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( cProjSD , size ( cProjSD ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) ! allocate ( pawKPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid )) ) ! call pawCorrectionKPC () ! if ( myid == root ) then call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 ! call cpu_time ( t1 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> begun.\")' ) flush ( iostd ) ! endif ! allocate ( pawSDK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid ) ) ) ! call pawCorrectionSDK () ! if ( myid == root ) then ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> done in\", f10.2, \" secs.\")' ) t2 - t1 ! call cpu_time ( t1 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) ! endif ! paw_id (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal paw_id ( ibf , ibi ) = sum ( pawSDK ( ibf , ibi ,:) * pawKPC ( ibf , ibi ,:)) enddo ! enddo ! if ( myid == root ) paw_SDKKPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! CALL MPI_REDUCE ( paw_id , paw_SDKKPC , size ( paw_id ), MPI_DOUBLE_COMPLEX , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call cpu_time ( t2 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! Ufi (:,:, ik ) = Ufi (:,:, ik ) + paw_SDPhi (:,:) + paw_PsiPC (:,:) + paw_SDKKPC (:,:) * 1 6.0_dp * pi * pi / omega ! call writeResults ( ik ) ! !write(iostd,*)'--------------------------------------------------------------------------------------------' ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = iBandFinit, iBandFfinal !    !paw = paw_SDPhi(ibf,ibi) + paw_PsiPC(ibf,ibi) + paw_SDKKPC(ibf,ibi)*16.0_dp*pi*pi/omega !    !write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf, ibi, ik), paw, Ufi(ibf, ibi, ik) + paw !    !Ufi(ibf, ibi, ik) = Ufi(ibf, ibi, ik) + paw !    write(iostd,'(\" Ufi \", 2i4, 2ES24.15E3)') ibi, ibf, Ufi(ibf, ibi, ik) !  enddo !  ! !  flush(iostd) !  ! !enddo ! !write(iostd,*)'--------------------------------------------------------------------------------------------' !flush(iostd) ! endif ! deallocate ( cProjPC , pawKPC ) deallocate ( cProjSD , pawSDK ) ! else ! if ( myid == root ) call readUfis ( ik ) ! endif ! enddo ! if ( allocated ( paw_id ) ) deallocate ( paw_id ) if ( myid == root ) then if ( allocated ( paw_PsiPC ) ) deallocate ( paw_PsiPC ) if ( allocated ( paw_SDPhi ) ) deallocate ( paw_SDPhi ) endif ! ! Calculating Vfi ! if ( myid == root ) then ! if ( calculateVfis ) call calculateVfiElements () ! ! Finalize Calculation ! call finalizeCalculation () ! endif ! call MPI_FINALIZE ( ierr ) ! end program transitionMatrixElements","tags":"","loc":"program/transitionmatrixelements.html","title":"transitionMatrixElements – Carrier Cross Sections"},{"text":"Uses MjModule Contents Source Code MjME Source Code program MjME ! use MjModule ! implicit none ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call displaceAtoms () ! if ( readQEInput ) then call exportQEInput () else call writeNewAtomicPositions () endif ! end program MjME","tags":"","loc":"program/mjme.html","title":"MjME – Carrier Cross Sections"},{"text":"Uses mpi lsf Contents Variables lll iPhonon charI Source Code lineShapeFunction Variables Type Attributes Name Initial integer :: lll integer :: iPhonon character(len=2) :: charI Source Code program lineShapeFunction ! ! Pull in modules use mpi use lsf ! implicit none ! ! Define an integer for ???? integer :: lll , iPhonon ! character ( len = 2 ) :: charI ! ! Initialize mpi and set up processes call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! ! If root process if ( myid == root ) then ! ! Start a timer call cpu_time ( ti ) ! ! Read input, check all variables needed and initialize the calculation. call readInputs () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call initializeLSF () ! endif ! ! Broadcast calculation parameters to all processes call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! ! For all processes that aren't the root if ( myid /= root ) then ! Allocate space for arrays allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !allocate( Vfis(-nEnergies:nEnergies) ) endif ! ! Broadcast arrays to all processes call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) !call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! ! Allocate space for arrays allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( 3 <= maximumNumberOfPhonons ) then ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! end if ! do iPhonon = minimumNumberOfPhonons , MIN0 ( maximumNumberOfPhonons , 4 ) if ( ( ( iPhonon == 1 . or . iPhonon == 2 ) . and . myid == root ) . or . iPhonon > 2 ) then if ( iPhonon > 2 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! endif ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then call cpu_time ( t1 ) ! call lsfMbyOneBand ( iPhonon ) ! if ( iPhonon > 1 ) then ! call lsfMbyTwoBands ( iPhonon ) ! else if ( iPhonon > 2 ) then ! call parallelIsFsBy3 () ! endif ! endif ! if ( iPhonon > 2 ) then ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( iPhonon ) ! endif ! if ( iPhonon > 3 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfDeterministicFourPhononsByFourBands () ! endif ! if ( iPhonon > 2 ) then ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! endif if ( myid == root ) then ! call cpu_time ( t2 ) ! write ( iostd , '(i2, \" modes, time needed :,\" , f10.2, \" secs.\")' ) iPhonon , t2 - t1 flush ( iostd ) ! if ( iPhonon > 2 ) then ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! else ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByBands , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! endif ! write ( iostd , * ) 'DE' , iPhonon , de flush ( iostd ) ! charI = '' write ( charI , \"(i2.2)\" ) iPhonon ! open ( 1 , file = 'lsfVsEwithUpTo' // trim ( charI ) // 'phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , iPhonon ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! if ( iPhonon < 3 ) then ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de ! else ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de ! endif ! enddo ! close ( 1 ) ! endif ! endif ! enddo ! if ( maximumNumberOfPhonons >= 5 ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then ! if ( istat /= 0 ) then ! write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' ! else ! write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' ! endif ! flush ( iostd ) ! endif ! if ( istat /= 0 ) close ( un ) ! ! allocate ( lsfbyPhononsPerProc(-nEnergies:nEnergies) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC ! do i = numprocs - 1 , 1 , - 1 ! iModeIs ( i ) = i * iMint + 1 ! if ( iMmod > 0 ) then ! iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 ! endif ! iModeFs ( i - 1 ) = iModeIs ( i ) - 1 ! enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 ! do ni = m - 1 , m - l + 1 , - 1 ! times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 ! enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = nModes ! do iMode = 2 , l ! weight = weight * ( nModes - iMode + 1 ) / iMode ! enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m ! elseif ( m < 100 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m ! elseif ( m < 1000 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m ! else ! write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m ! endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de ! enddo ! close ( 5000 ) ! endif ! enddo ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! deallocate ( lsfVsEbyBands , iEbinsByBands , pj ) ! if ( 3 <= maximumNumberOfPhonons ) then ! deallocate ( iModeIs , iModeFs ) ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! end if ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"program/lineshapefunction.html","title":"lineShapeFunction – Carrier Cross Sections"},{"text":"Uses mpi lsf Contents Source Code lineShapeFunction Source Code program lineShapeFunction ! use mpi use lsf ! implicit none ! call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! if ( myid == root ) then ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call readPhonons () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call readMjs () ! call initializeLSF () ! endif ! call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( modes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !    allocate( Vfis(-nEnergies:nEnergies) ) endif ! call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( s2L , size ( s2L ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) !  call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( myid == root ) then ! !if ( maximumNumberOfPhonons > 0 ) then if ( ( minimumNumberOfPhonons < 2 ) . and . ( maximumNumberOfPhonons > 0 ) . and . ( modes > 0 ) ) then ! ! One phonon ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call lsfMbyOneBand ( 1 ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 1 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 1 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 1 , file = 'lsfVsEwithUpTo1phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 1 ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 1 ) ! endif ! if ( ( minimumNumberOfPhonons < 3 ) . and . ( maximumNumberOfPhonons > 1 ) . and . ( modes > 1 ) ) then ! ! Two phonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call cpu_time ( t1 ) ! call lsfMbyOneBand ( 2 ) call lsfMbyTwoBands ( 2 ) ! call cpu_time ( t2 ) ! write ( iostd , '(\" 2 modes, time needed :,\" , f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 2 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 2 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 2 , file = 'lsfVsEwithUpTo2phonons' , status = 'unknown' ) ! !      write(2,'(\"# \", i5, \" phonons\")') 2 write ( 2 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 2 do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 2 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 2 ) ! endif ! !   call lsfDeterministicOneAndTwoBands() ! !deallocate ( lsfVsEbyPhonons ) ! endif ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! !if ( maximumNumberOfPhonons > 2 ) then if ( ( minimumNumberOfPhonons < 4 ) . and . ( maximumNumberOfPhonons > 2 ) . and . ( modes > 2 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then ! call lsfMbyOneBand ( 3 ) call lsfMbyTwoBands ( 3 ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 3 ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 3 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 3 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo3phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 3 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 3 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! !if ( maximumNumberOfPhonons > 3 ) then if ( ( minimumNumberOfPhonons < 5 ) . and . ( maximumNumberOfPhonons > 3 ) . and . ( modes > 3 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( 4 ) call lsfMbyTwoBands ( 4 ) ! call parallelIsFsBy3 () ! !write(6,*) '3' !do i = 0, nProcMax - 1 !  write(6,*) i, iModeIs(i), iModeFs(i) !enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 4 ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !if ( myid == root ) then !  write(6,*) '4' !  do i = 0, nProcMax - 1 !    write(6,*) i, iModeIs(i), iModeFs(i) !  enddo !endif ! call lsfDeterministicFourPhononsByFourBands () ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 4 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 4 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo4phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 4 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 4 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! if ( ( maximumNumberOfPhonons > 4 ) . and . ( modes > 4 ) ) then !if ( ( minimumNumberOfPhonons < 6 ) .and. ( maximumNumberOfPhonons > 4 ) ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then if ( istat /= 0 ) then write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' else write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' endif flush ( iostd ) endif ! if ( istat /= 0 ) close ( un ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) allocate ( lsfbyPhononsPerProc ( - nEnergies : nEnergies ) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC do i = numprocs - 1 , 1 , - 1 iModeIs ( i ) = i * iMint + 1 if ( iMmod > 0 ) then iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 endif iModeFs ( i - 1 ) = iModeIs ( i ) - 1 enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 do ni = m - 1 , m - l + 1 , - 1 times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = modes ! do iMode = 2 , l weight = weight * ( modes - iMode + 1 ) / iMode enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m elseif ( m < 100 ) then write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m elseif ( m < 1000 ) then write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m else write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !        write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de enddo close ( 5000 ) ! endif ! enddo ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"program/lineshapefunction~2.html","title":"lineShapeFunction – Carrier Cross Sections"},{"text":"Uses sigma_module Contents Source Code crossSection Source Code program crossSection ! use sigma_module ! implicit none ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call calculateSigma () ! call writeSigma () ! end program crossSection","tags":"","loc":"program/crosssection.html","title":"crossSection – Carrier Cross Sections"},{"text":"Welcome to the README for the Carrier Cross Sections project! This tab contains more information\non the theory behind the code, the input and output files used by the code, and how to install/run\nthe code as well as a Todo list for cleaning up and developing the code.","tags":"","loc":"page//index.html","title":"README – Carrier Cross Sections"},{"text":"There are several input and output files used by this program. The goal of this\npage is to make it clear where these files come from, how they are used by the code\nand the physical meaning of the data in the files.","tags":"","loc":"page/intputOutput/index.html","title":"Input and Output Files – Carrier Cross Sections"},{"text":"This file is exported from pw_export_for_TME . It has the following format: # Cell volume ( a . u . ) &#94; 3 . Format : ' (ES24.15E3) ' 2 . 653020000000000 E + 002 # Number of K - points . Format : ' (i10) ' 2 # ik , groundState , ngk_g ( ik ) , wk ( ik ) , xk ( 1 : 3 , ik ) . Format : ' (3i10,4ES24.15E3) ' 1 0 180 5 . 000000000000000 E - 001 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 2 0 186 1 . 500000000000000 E + 000 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 7 . 500000000000000 E - 001 # Number of G - vectors . Format : ' (i10) ' 1459 # Number of PW - vectors . Format : ' (i10) ' 266 # Number of min - max values of fft grid in x , y and z axis . Format : ' (6i10) ' - 7 7 - 7 7 - 7 7 # Cell ( a . u . ) . Format : ' (a5, 3ES24.15E3) ' # a1 - 5 . 100000000000000 E + 000 0 . 000000000000000 E + 000 5 . 100000000000000 E + 000 # a2 0 . 000000000000000 E + 000 5 . 100000000000000 E + 000 5 . 100000000000000 E + 000 # a3 - 5 . 100000000000000 E + 000 5 . 100000000000000 E + 000 0 . 000000000000000 E + 000 # Reciprocal cell ( a . u . ) . Format : ' (a5, 3ES24.15E3) ' # b1 - 6 . 159985595274104 E - 001 - 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 # b2 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 # b3 - 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 - 6 . 159985595274104 E - 001 # Number of Atoms . Format : ' (i10) ' 2 # Number of Types . Format : ' (i10) ' 1 # Atoms type , position ( 1 : 3 ) ( a . u . ) . Format : ' (i10,3ES24.15E3) ' 1 0 . 000000000000000 E + 000 0 . 000000000000000 E + 000 0 . 000000000000000 E + 000 1 2 . 550000000000000 E + 000 2 . 550000000000000 E + 000 2 . 550000000000000 E + 000 # Number of Bands . Format : ' (i10) ' 4 # Spin . Format : ' (i10) ' 1 # Element Si # Number of Atoms of this type . Format : ' (i10) ' 2 # Number of projectors . Format : ' (i10) ' 6 # Angular momentum , index of the projectors . Format : ' (2i10) ' 0 1 0 2 1 3 1 4 2 5 2 6 # Number of channels . Format : ' (i10) ' 18 # Number of radial mesh points . Format : ' (2i10) ' 1141 837 # Radial grid , Integratable grid . Format : ' (2ES24.15E3) ' 6 . 513442611103688 E - 005 8 . 141803263879609 E - 007 6 . 595371633350159 E - 005 8 . 244214541687697 E - 007 6 . 678331195832729 E - 005 8 . 347913994790911 E - 007 6 . 762334261151813 E - 005 8 . 452917826439768 E - 007 6 . 847393954957285 E - 005 8 . 559242443696606 E - 007 ...\n# AE , PS radial wfc for each beta function . Format : ' (2ES24.15E3) ' 5 . 130578464215461 E - 004 3 . 370121859129863 E - 005 5 . 194773426646861 E - 004 3 . 412512773645108 E - 005 5 . 259771611021033 E - 004 3 . 455436900225269 E - 005 5 . 325583067433258 E - 004 3 . 498900945852498 E - 005 5 . 392217087420185 E - 004 3 . 542911701872407 E - 005 ...\n# Fermi Energy ( Hartree ) . Format : ' (ES24.15E3) ' 2 . 090654946391985 E - 001 Currently, the program does not read in cell volume, groundState , number of G vectors, the fft grid min and max values, real space or reciprocal space lattice vectors, number of bands, or spin format.","tags":"","loc":"page/intputOutput/exportedInput.html","title":"input – Carrier Cross Sections"},{"text":"Can use xcrysden to visualize QE input and output Can convert from QE output to xsf (VASP format) using PW/tools/pwo2xsf.sh There are four different types of extraction from the PWscf output: initial structure: the one reported from the input at the beginning of the output file (for the SCF calculation one should select this option) latest structure: the latest structure in the output file; if the latest structure is the optimized structure, then this one is extracted. For an SCF calculation only initial structure is reported and the \"latest structure\" extraction extracts noting in this case optimized structure: extracts the optimized structure, if it is not present it extracts nothing all structures as animation What is the purpose of the QE calculation? --> Explore the TME program","tags":"","loc":"page/./notes.html","title":"Notes – Carrier Cross Sections"},{"text":"../TME/src/TME_Module_v28.f90:285: Change readInput() to have arguments to make clear that these variables are getting changed ../TME/src/TME_Module_v28.f90:291: Change file_exists to fileExists in readInput() ../TME/src/TME_Module_v28.f90:316: Figure out what the difference in PC and SD is ../TME/src/TME_Module_v28.f90:335: Change initialize() to have arguments to make clear that these variables are getting changed ../TME/src/TME_Module_v28.f90:370: Change checkInitialization() to have arguments to make clear that these variables are getting changed ../TME/src/TME_Module_v28.f90:378: Change file_exists to fileExists in checkInitialization() ../TME/src/TME_Module_v28.f90:564: Check if there is any kind of check on ki and kf . Why was this commented out? ../TME/src/TME_Module_v28.f90:634: Change readInputPC() to have arguments so that it is clear that these variables are getting changed ../TME/src/TME_Module_v28.f90:649: Change file_exists to fileExists in readInputPC() ../TME/src/TME_Module_v28.f90:679: Add information about these variables to top ../TME/src/TME_Module_v28.f90:803: Look more into how AE and PS wavefunctions are combined to further understand this ../TME/src/TME_Module_v28.f90:804: Move this behavior to another subroutine for clarity","tags":"","loc":"page/./todo.html","title":"Todo – Carrier Cross Sections"}]}