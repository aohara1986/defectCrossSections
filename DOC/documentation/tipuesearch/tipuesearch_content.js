var tipuesearch = {"pages":[{"text":"Carrier Cross Sections Installation Dependencies Install all of the required dependencies (commands given for Unix environment): sudo apt-get update\nsudo apt install gfortran\nsudo apt install libmpich-dev\nsudo apt install libopenmpi-dev\nsudo apt-get install python-pip python-dev build-essential\nsudo pip install ford\nsudo apt-get install graphviz\nsudo wget https://github.com/QEF/q-e/archive/qe-5.3.tar.gz\nsudo apt-get install git Set up Quantum Espresso Change to whatever directory you saved the QE tar file in on the CLI Decompress the tar file using tar -xvzf q-e-qe-5.3.tar.gz Change into the q-e-qe-5.3 directory and run ./configure Confirm that the last line of output is configure: success Run make pw pp ph to build the PW, PP, and PHonon packages Compile Source Clone the repository using git clone https://github.com/laurarnichols/carrierCrossSections.git Change into the carrierCrossSections directory Open the Makefile and edit the path to Quantum Espresso to match your system Note: Make sure that your path does not have a / at the end or there will be an error * You should now be able to make the target you want (e.g., to compile everything, use make all_QE-5.3.0 )\n* For a list of some possible targets, read through the Makefile or type make Documentation This documentation is generated by FORD . Note This documentation is in progress. Please report any issues you find. How to Run I don't know how to run yet, so this section contains notes to try to figure that out. Here is a flow chart describing \nhow the programs connect as far as I know. TME stands for transition matrix element LSF stands for line shape function Sigma is likely the cross section calculation Mj is likely calculating equation 46 (for linear phonon TMEs) If cross section (sigma) is goal (zeroth order): TME and LSF --> Sigma ? QE --> TME ? Input and Output QE: Input: scf.in Output: scf.out output directory (e.g. tmp ) Export: Input: output directory Output: export directory TME: Input: export directory Output: VfisVsE LSF: Input: phonons_disp.dat --> where does this come from? Output: lsfVsEwithUpTo<%i>phonons Sigma Input: VfisVsE lsfVsEwithUpTo<%i>phonons","tags":"home","loc":"index.html","title":" Carrier Cross Sections "},{"text":"Contents Programs pw_export_for_TME Modules io_base_export Source Code Export_QE-5.3.0_v3.f90 Source Code ! ! Copyright (C) 2003-2009 Andrea Ferretti and Quantum ESPRESSO group ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !=----------------------------------------------------------------------------=! MODULE io_base_export !=----------------------------------------------------------------------------=! ! do i = 1, nk             !                                                   ! !   WAVEFUNCTIONS( i )     !  write_restart_wfc         read_restart_wfc       ! ! end do                   !                                                   ! USE io_global , ONLY : stdout USE kinds USE parameters , ONLY : nsx IMPLICIT NONE SAVE INTEGER , PARAMETER :: file_version = 202 INTEGER :: restart_module_verbosity = 0 !=----------------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------------=! ! !=----------------------------------------------------------------------------=! ! ..  This subroutine write wavefunctions to the disk ! .. Where: ! iuni    = Restart file I/O fortran unit ! SUBROUTINE write_restart_wfc ( iuni , exportDir , & ik , nk , kunit , ispin , nspin , scal , wf0 , t0 , wfm , tm , ngw , gamma_only , nbnd , igl , ngwl ) ! USE mp_wave USE mp , ONLY : mp_sum , mp_get , mp_max USE mp_pools , ONLY : me_pool , my_pool_id , & nproc_pool , intra_pool_comm , root_pool USE mp_world , ONLY : mpime , nproc , root , world_comm USE io_global , ONLY : ionode , ionode_id USE iotk_module ! IMPLICIT NONE ! INTEGER , INTENT ( in ) :: iuni character ( len = 256 ), intent ( in ) :: exportDir INTEGER , INTENT ( in ) :: ik , nk , kunit , ispin , nspin COMPLEX ( DP ), INTENT ( in ) :: wf0 (:,:) COMPLEX ( DP ), INTENT ( in ) :: wfm (:,:) INTEGER , INTENT ( in ) :: ngw ! LOGICAL , INTENT ( in ) :: gamma_only INTEGER , INTENT ( in ) :: nbnd INTEGER , INTENT ( in ) :: ngwl INTEGER , INTENT ( in ) :: igl (:) REAL ( DP ), INTENT ( in ) :: scal LOGICAL , INTENT ( in ) :: t0 , tm INTEGER :: i , j , ierr , idum = 0 INTEGER :: nkl , nkr , nkbl , iks , ike , nkt , ikt , igwx , ig INTEGER :: npool , ipmask ( nproc ), ipsour COMPLEX ( DP ), ALLOCATABLE :: wtmp (:) INTEGER , ALLOCATABLE :: igltot (:) CHARACTER ( len = 20 ) :: section_name = 'wfc' LOGICAL :: twrite = . true . INTEGER :: ierr_iotk CHARACTER ( len = iotk_attlenx ) :: attr ! ! ... Subroutine Body ! ! set working variables for k point index (ikt) and k points number (nkt) ikt = ik nkt = nk !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkt / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkt - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ipmask = 0 ipsour = ionode_id !  find out the index of the processor which collect the data in the pool of ik IF ( npool > 1 ) THEN IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN IF ( me_pool == root_pool ) ipmask ( mpime + 1 ) = 1 ENDIF CALL mp_sum ( ipmask , world_comm ) DO i = 1 , nproc IF ( ipmask ( i ) == 1 ) ipsour = ( i - 1 ) ENDDO ENDIF igwx = 0 ierr = 0 IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN IF ( ngwl > size ( igl ) ) THEN ierr = 1 ELSE igwx = maxval ( igl ( 1 : ngwl ) ) ENDIF ENDIF ! get the maximum index within the pool ! CALL mp_max ( igwx , intra_pool_comm ) ! now notify all procs if an error has been found ! CALL mp_max ( ierr , world_comm ) IF ( ierr > 0 ) & CALL errore ( ' write_restart_wfc ' , ' wrong size ngl ' , ierr ) IF ( ipsour /= ionode_id ) THEN CALL mp_get ( igwx , igwx , mpime , ionode_id , ipsour , 1 , world_comm ) ENDIF ALLOCATE ( wtmp ( max ( igwx , 1 ) ) ) wtmp = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) DO j = 1 , nbnd IF ( t0 ) THEN IF ( npool > 1 ) THEN IF ( ( ikt >= iks ) . and . ( ikt <= ike ) ) THEN CALL mergewf ( wf0 (:, j ), wtmp , ngwl , igl , me_pool , & nproc_pool , root_pool , intra_pool_comm ) ENDIF IF ( ipsour /= ionode_id ) THEN CALL mp_get ( wtmp , wtmp , mpime , ionode_id , ipsour , j , world_comm ) ENDIF ELSE CALL mergewf ( wf0 (:, j ), wtmp , ngwl , igl , mpime , nproc , & ionode_id , world_comm ) ENDIF IF ( ionode ) THEN do ig = 1 , igwx write ( iuni , '(2ES24.15E3)' ) wtmp ( ig ) enddo ! !              do j = 1, nbnd !                do i = 1, igwx ! ngk_g(ik) !                  write(74,'(2ES24.15E3)') wf0(i,j) ! wf0 is the local array for evc(i,j) !                enddo !              enddo ! ENDIF ELSE ENDIF ENDDO !        DO j = 1, nbnd !          IF( tm ) THEN !            IF( npool > 1 ) THEN !              IF( ( ikt >= iks ) .and. ( ikt <= ike ) ) THEN !                CALL mergewf(wfm(:,j), wtmp, ngwl, igl, me_pool, & !                             nproc_pool, root_pool, intra_pool_comm) !              ENDIF !              IF( ipsour /= ionode_id ) THEN !                CALL mp_get( wtmp, wtmp, mpime, ionode_id, ipsour, j, world_comm ) !              ENDIF !            ELSE !              CALL mergewf(wfm(:,j), wtmp, ngwl, igl, mpime, nproc, ionode_id, world_comm ) !            ENDIF !            IF( ionode ) THEN !              CALL iotk_write_dat(iuni,\"Wfcm\"//iotk_index(j),wtmp(1:igwx)) !            ENDIF !          ELSE !          ENDIF !        ENDDO IF ( ionode ) then close ( iuni ) !CALL iotk_write_end  (iuni,\"Kpoint\"//iotk_index(ik)) endif DEALLOCATE ( wtmp ) RETURN END SUBROUTINE END MODULE !=----------------------------------------------------------------------------=! !----------------------------------------------------------------------- PROGRAM pw_export_for_TME !----------------------------------------------------------------------- ! ! writes PWSCF data for postprocessing purposes in XML format using IOTK lib ! Wave-functions are collected and written using IO_BASE module. ! ! input:  namelist \"&inputpp\", with variables !   prefix       prefix of input files saved by program pwscf !   outdir       temporary directory where files resides !   exportDir    output directory. A directory !                \"exportDir\" is created and !                output files are put there. All the data !                are accessible through the \"\"exportDir\"/input\" file. ! USE wrappers , ONLY : f_mkdir_safe USE pwcom USE io_global , ONLY : ionode , ionode_id USE io_files , ONLY : prefix , tmp_dir , outdir USE ions_base , ONLY : ntype => nsp USE iotk_module USE mp_global , ONLY : mp_startup USE mp_pools , ONLY : kunit USE mp_world , ONLY : world_comm USE mp , ONLY : mp_bcast USE environment , ONLY : environment_start ! IMPLICIT NONE ! CHARACTER ( LEN = 256 ), EXTERNAL :: trimcheck ! INTEGER :: ik , i , kunittmp , ios ! real ( kind = dp ), parameter :: ryToHartree = 0.5_dp ! CHARACTER ( len = 256 ) :: pp_file , exportDir LOGICAL :: writeWFC ! NAMELIST / inputpp / prefix , outdir , exportDir , writeWFC ! ! initialise environment ! #ifdef __MPI CALL mp_startup ( ) #endif CALL environment_start ( 'PW_EXPORT' ) ! !   set default values for variables in namelist ! prefix = '' CALL get_environment_variable ( 'ESPRESSO_TMPDIR' , outdir ) IF ( trim ( outdir ) == ' ' ) outdir = './' exportDir = './Export' ! writeWFC = . true . ! gdb : by default the wavefunctions are needed, !       this gives the user the ability not to write the wavefunctions ! !    Reading input file ! IF ( ionode ) THEN ! CALL input_from_file ( ) ! READ ( 5 , inputpp , IOSTAT = ios ) ! IF ( ios /= 0 ) CALL errore ( 'pw_export' , 'reading inputpp namelist' , abs ( ios ) ) ! ios = f_mkdir_safe ( trim ( exportDir ) ) ! pp_file = trim ( exportDir ) // \"/input\" ! ! ENDIF ! ! ... Broadcasting variables ! tmp_dir = trimcheck ( outdir ) CALL mp_bcast ( outdir , ionode_id , world_comm ) CALL mp_bcast ( tmp_dir , ionode_id , world_comm ) CALL mp_bcast ( prefix , ionode_id , world_comm ) ! !   Now allocate space for pwscf variables, read and check them. ! CALL read_file CALL openfil_pp ! #if defined __MPI kunittmp = kunit #else kunittmp = 1 #endif CALL write_export ( pp_file , exportDir , kunittmp ) CALL stop_pp ! CONTAINS ! !----------------------------------------------------------------------- SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export END PROGRAM pw_export_for_TME","tags":"","loc":"sourcefile/export_qe-5.3.0_v3.f90.html","title":"Export_QE-5.3.0_v3.f90 – Carrier Cross Sections"},{"text":"Contents Programs transitionMatrixElements Source Code TME_Main_v9.f90 Source Code program transitionMatrixElements !! @todo Add detailed math derivation and summary for main program @endtodo !! !! <h2>Walkthrough</h2> !! use mpi use TMEModule !! * Use pre-built mpi library and declarations module that !! is defined in TME_Module_v28.f90 ! implicit none ! real ( kind = dp ) :: t1 !! Start time used in various timers real ( kind = dp ) :: t2 !! End time used in various timers ! call MPI_INIT ( ierr ) !! * Initialize MPI environment call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) !! * Determine the rank or ID of the calling process call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) !! * Determine the size of the MPI pool (i.e., the number of processes) ! allocate ( nPWsI ( 0 : numprocs - 1 ), nPWsF ( 0 : numprocs - 1 ) ) ! if ( myid == root ) then !! * If this is the root process !!    * Call [[TMEModule(module):initializeCalculation(subroutine)]] !!      to start timer and set default values !!    * Call [[TMEModule(module):readInput(subroutine)]] to read program input and !!      QE Export output !!    * Call [[TMEModule(module):readPWsSet(subroutine)]] to read g vectors from `mgrid` file !!    * Initialize all values in `Ufi` matrix to complex double zero !!    * Figure out how many g vectors/plane waves to give each process !!    * Initialize the number of initial and final plane waves to zero for each process !!    * For each process, calculate the initial (before this process) and final (after this process) !!      number of plane waves ! call initializeCalculation ( solidDefect , perfectCrystal , elementsPath , VFisOutput , ki , kf , eBin , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , calculateVFis , t0 ) ! call readInput ( perfectCrystal , solidDefect , elementsPath , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput ) ! call readPWsSet () ! !> @todo Figure out if need to allocate space for arrays so soon @endtodo allocate ( counts ( 0 : numprocs - 1 ) ) !, displmnt(0:numprocs-1) ) allocate ( Ufi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , perfectCrystal % nKpts ) ) allocate ( paw_SDKKPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( perfectCrystal % paw_Wfc ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( solidDefect % paw_Wfc ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_fi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( eigvI ( iBandIinit : iBandIfinal ), eigvF ( iBandFinit : iBandFfinal ) ) ! Ufi (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! call distributePWsToProcs ( solidDefect % numOfGvecs , numprocs ) !! @todo Figure out if SD and PC `numOfGvecs` should be the same @endtodo ! nPWsI (:) = 0 nPWsF (:) = 0 ! do i = 0 , numprocs - 1 nPWsI ( i ) = 1 + sum ( counts (: i - 1 )) nPWsF ( i ) = sum ( counts (: i )) enddo ! endif ! !-------------------------------------------------------------------------------------------------------- !> * Broadcast variables from root process to all other processes, allocating space as needed ! call MPI_BCAST ( iBandIinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandIfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % nKpts , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % nProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nBands , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nSpins , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % numOfPWs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % numOfGvecs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nPWsI , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nPWsF , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( JMAX , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( gvecs ( 3 , solidDefect % numOfGvecs ) ) call MPI_BCAST ( gvecs , size ( gvecs ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( perfectCrystal % atoms ( perfectCrystal % numOfTypes ) ) ! do i = 1 , perfectCrystal % numOfTypes ! call MPI_BCAST ( perfectCrystal % atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% numProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% iRAugMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( perfectCrystal % atoms ( i )% projAngMom ( perfectCrystal % atoms ( i )% numProjs ) ) allocate ( perfectCrystal % atoms ( i )% r ( perfectCrystal % atoms ( i )% nMax ) ) allocate ( perfectCrystal % atoms ( i )% rab ( perfectCrystal % atoms ( i )% nMax ) ) allocate ( perfectCrystal % atoms ( i )% F ( perfectCrystal % atoms ( i )% iRAugMax , perfectCrystal % atoms ( i )% numProjs ) ) allocate ( perfectCrystal % atoms ( i )% F1 ( perfectCrystal % atoms ( i )% iRAugMax , perfectCrystal % atoms ( i )% numProjs , & perfectCrystal % atoms ( i )% numProjs )) allocate ( perfectCrystal % atoms ( i )% bes_J_qr ( 0 : JMAX , perfectCrystal % atoms ( i )% iRAugMax ) ) endif ! call MPI_BCAST ( perfectCrystal % atoms ( i )% projAngMom , size ( perfectCrystal % atoms ( i )% projAngMom ), & MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% r , size ( perfectCrystal % atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% rab , size ( perfectCrystal % atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% F , size ( perfectCrystal % atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% F1 , size ( perfectCrystal % atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% bes_J_qr , size ( perfectCrystal % atoms ( i )% bes_J_qr ), & MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( perfectCrystal % nIons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( perfectCrystal % posIon ( 3 , perfectCrystal % nIons ), perfectCrystal % atomTypeIndex ( perfectCrystal % nIons ) ) call MPI_BCAST ( perfectCrystal % atomTypeIndex , size ( perfectCrystal % atomTypeIndex ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % posIon , size ( perfectCrystal % posIon ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( solidDefect % numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( solidDefect % atoms ( solidDefect % numOfTypes ) ) ! do i = 1 , solidDefect % numOfTypes ! call MPI_BCAST ( solidDefect % atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% numProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% iRAugMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( solidDefect % atoms ( i )% projAngMom ( solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% r ( solidDefect % atoms ( i )% nMax ) ) allocate ( solidDefect % atoms ( i )% rab ( solidDefect % atoms ( i )% nMax ) ) allocate ( solidDefect % atoms ( i )% F ( solidDefect % atoms ( i )% iRAugMax , solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% F1 ( solidDefect % atoms ( i )% iRAugMax , & solidDefect % atoms ( i )% numProjs , solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% bes_J_qr ( 0 : JMAX , solidDefect % atoms ( i )% iRAugMax ) ) endif ! call MPI_BCAST ( solidDefect % atoms ( i )% projAngMom , size ( solidDefect % atoms ( i )% projAngMom ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% r , size ( solidDefect % atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% rab , size ( solidDefect % atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% F , size ( solidDefect % atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% F1 , size ( solidDefect % atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% bes_J_qr , size ( solidDefect % atoms ( i )% bes_J_qr ), MPI_DOUBLE_PRECISION , & root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( solidDefect % nIons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( solidDefect % posIon ( 3 , solidDefect % nIons ), solidDefect % atomTypeIndex ( solidDefect % nIons ) ) call MPI_BCAST ( solidDefect % atomTypeIndex , size ( solidDefect % atomTypeIndex ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % posIon , size ( solidDefect % posIon ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! allocate ( paw_id ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) ! !-------------------------------------------------------------------------------------------------------- ! do ik = 1 , perfectCrystal % nKpts !! * For each k point !!    * If I'm root, check if the matrix elements have already !!      been calculated and send the result to all other processes !!    * If the matrix elements haven't already been !!      calculated !!       * Allocate space for the projections `cProj` !!       * If I'm root !!          * Start a timer and output that starting to !!            calculate overlap !!          * Allocate space for the wavefunctions !!          * Read wavefunctions and calculate !!            `U_fi`= \\langle\\Phi_f|\\Psi_i\\rangle !!          * Stop timer and output how long calculating overlap !!            took !!          * Output that starting projector augmented wave !!            portion !!          * Start a timer and report that doing PAW for !!            perfect crystal !!          * Read \\langle\\beta_{\\Psi}|\\Psi\\rangle !!            from [[pw_export_for_tme(program)]] !!          * Allocate space for cross projection !!            \\langle\\beta_{\\Psi}|\\Phi\\rangle !!          * Calculate cross projection of |\\Phi\\rangle !!          * Deallocate space for solid defect wavefunction !!          * Calculate the 2nd and 3rd terms in C3 from paper !!          * Deallocate space for the cross projection of !!            |\\Phi\\rangle !!          * Stop timer and output that finished PAW for perfect !!            crystal !!          * Start timer and output that started PAW for solid !!            defect !!          * Read \\langle\\beta_{\\Phi}|\\Phi\\rangle from !!            [[pw_export_for_tme(program)]] !!          * Allocate space for cross projection !!            \\langle\\beta_{\\Phi}|\\Psi\\rangle !!          * Calculate cross projection of |\\Psi\\rangle !!          * Deallocate space for the perfect crystal wavefunction !!          * Calculate the 4th and 5th terms in C3 from paper !!          * Deallocate space for the cross projection of !!            |\\Psi\\rangle !!          * Stop timer and output that finished PAW for solid !!            defect !!          * Start a timer and output that started k projections !!            for perfect crystal !!       * Send projectors to all other processes !!       * Allocate space for k projections for perfect crystal !!       * Calculate k projections for perfect crystal !!       * If I'm root !!          * Stop timer and output that done with k projection for !!            perfect crystal !!          * Start timer and output that started k projection for !!            solid defect !!       * Allocate space for k projections for solid defect !!       * Calculate k projections for solid defect !!       * If I'm root !!          * Stop timer and output that done with k projection for !!            solid defect !!          * Start timer and output that combining k projections !!       * For each initial and final band, sum the product of the !!         k projections of the solid defect and perfect crystal !!         to get the last term in equation C3 in the paper !!       * Allocate space for `paw_SDKKPC` if root and sum !!         individual sums from processes into a single total !!       * If I'm root !!          * Stop timer and output that done with summing k !!            projections !!          * Add PAW corrections to initially calculated overlap !!          * Output transition matrix elements for a given k point !!       * Deallocate space for the projections !!    * If the transition matrix elements for this k point have !!      already been calculated and I'm root, read in the existing !!      output file ! if ( myid == root ) then ! If I'm root, check if the matrix elements have ! already been calculated ! tmes_file_exists = . false . call checkIfCalculated ( ik , tmes_file_exists ) ! endif ! call MPI_BCAST ( tmes_file_exists , 1 , MPI_LOGICAL , root , MPI_COMM_WORLD , ierr ) ! Send the result to all other processes ! if ( . not . tmes_file_exists ) then ! If the matrix elements haven't already been calculated ! allocate ( perfectCrystal % cProj ( perfectCrystal % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) allocate ( solidDefect % cProj ( solidDefect % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) ! Allocate space for the projections `cProj` ! if ( myid == root ) then ! If I'm root ! write ( iostd , '(\" Starting Ufi(:,:) calculation for k-point\", i4, \" of\", i4)' ) ik , perfectCrystal % nKpts flush ( iostd ) ! write ( iostd , * ) write ( iostd , '(\"    Plane waves part begun.\")' ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> begun.\")' ) call cpu_time ( t1 ) ! Start a timer and output that starting to calculate overlap ! allocate ( perfectCrystal % wfc ( solidDefect % numOfPWs , iBandIinit : iBandIfinal ), & solidDefect % wfc ( solidDefect % numOfPWs , iBandFinit : iBandFfinal ) ) ! Allocate space for the wavefunctions ! call calculatePWsOverlap ( ik ) ! Read wavefunctions and calculate `U_fi`= \\langle\\Phi_f|\\Psi_i\\rangle ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , '(\"    Plane waves part done in\", f10.2, \" secs.\")' ) t2 - t1 ! Stop timer and output how long calculating overlap took ! flush ( iostd ) write ( iostd , * ) write ( iostd , '(\"    PAW part begun.\")' ) ! Output that starting projector augmented wave portion ! write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start a timer and report that doing PAW for perfect crystal ! call readProjections ( ik , perfectCrystal ) ! Read \\langle\\beta_{\\Psi}|\\Psi\\rangle from [[pw_export_for_tme(program)]] ! allocate ( perfectCrystal % cCrossProj ( perfectCrystal % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) ! Allocate space for cross projection \\langle\\beta_{\\Psi}|\\Phi\\rangle ! call projectBeta ( ik , perfectCrystal , solidDefect ) ! Calculate cross projection of |\\Phi\\rangle ! deallocate ( solidDefect % wfc ) ! Deallocate space for solid defect wavefunction ! call pawCorrectionWfc ( perfectCrystal ) ! Calculate the 2nd and 3rd terms in C3 from paper ! deallocate ( perfectCrystal % cCrossProj ) ! Deallocate space for the cross projection of |\\Phi\\rangle ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 ! Stop timer and output that finished PAW for perfect crystal ! write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start timer and output that started PAW for solid defect ! call readProjections ( ik , solidDefect ) ! Read \\langle\\beta_{\\Phi}|\\Phi\\rangle from [[pw_export_for_tme(program)]] ! allocate ( solidDefect % cCrossProj ( solidDefect % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) ! Allocate space for cross projection \\langle\\beta_{\\Phi}|\\Psi\\rangle ! call projectBeta ( ik , solidDefect , perfectCrystal ) ! Calculate cross projection of |\\Psi\\rangle ! deallocate ( perfectCrystal % wfc ) ! Deallocate space for the perfect crystal wavefunction ! call pawCorrectionWfc ( solidDefect ) ! Calculate the 4th and 5th terms in C3 from paper ! deallocate ( solidDefect % cCrossProj ) ! Deallocate space for the cross projection of |\\Psi\\rangle ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! Stop timer and output that finished PAW for solid defect ! write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start a timer and output that started k projections for perfect crystal ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6ES14.5E3)') ibi, ibf, solidDefect%paw_Wfc(ibf,ibi), perfectCrystal%paw_Wfc(ibf,ibi), paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! !call pawCorrection() !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) + paw_fi(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf,ibi,ik), paw, Ufi(ibf,ibi,ik) + paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! endif ! call MPI_BCAST ( perfectCrystal % cProj , size ( perfectCrystal % cProj ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % cProj , size ( solidDefect % cProj ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) ! Send projectors to all other processes ! allocate ( perfectCrystal % pawK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid )) ) ! Allocate space for k projections for perfect crystal ! call pawCorrectionK ( perfectCrystal ) ! Calculate k projections for perfect crystal ! if ( myid == root ) then ! If I'm root ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 ! Stop timer and output that done with k projection for perfect crystal ! write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start timer and output that started k projection for solid defect ! endif ! allocate ( solidDefect % pawK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid ) ) ) ! Allocate space for k projections for solid defect ! call pawCorrectionK ( solidDefect ) ! Calculate k projections for solid defect ! if ( myid == root ) then ! If I'm root ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> done in\", f10.2, \" secs.\")' ) t2 - t1 ! Stop timer and output that done with k projection for solid defect ! write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start timer and output that combining k projections ! endif ! paw_id (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! For each initial and final band, sum the product of the k projections ! of the solid defect and perfect crystal to get the last term in ! equation C3 in the paper ! paw_id ( ibf , ibi ) = sum ( solidDefect % pawK ( ibf , ibi ,:) * perfectCrystal % pawK ( ibf , ibi ,:)) ! enddo ! enddo ! if ( myid == root ) paw_SDKKPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) CALL MPI_REDUCE ( paw_id , paw_SDKKPC , size ( paw_id ), MPI_DOUBLE_COMPLEX , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! Allocate space for `paw_SDKKPC` if root and sum individual sums from ! processes into a single total ! if ( myid == root ) then ! If I'm root ! call cpu_time ( t2 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! Stop timer and output that done with summing k projections ! Ufi (:,:, ik ) = Ufi (:,:, ik ) + solidDefect % paw_Wfc (:,:) + perfectCrystal % paw_Wfc (:,:) + & paw_SDKKPC (:,:) * 1 6.0_dp * pi * pi / solidDefect % omega ! Add PAW corrections to initially calculated overlap ! call writeResults ( ik ) ! Output transition matrix elements for a given k point ! !write(iostd,*)'--------------------------------------------------------------------------------------------' ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = iBandFinit, iBandFfinal !    !paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) + paw_SDKKPC(ibf,ibi)*16.0_dp*pi*pi/solidDefect%omega !    !write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf, ibi, ik), paw, Ufi(ibf, ibi, ik) + paw !    !Ufi(ibf, ibi, ik) = Ufi(ibf, ibi, ik) + paw !    write(iostd,'(\" Ufi \", 2i4, 2ES24.15E3)') ibi, ibf, Ufi(ibf, ibi, ik) !  enddo !  ! !  flush(iostd) !  ! !enddo ! !write(iostd,*)'--------------------------------------------------------------------------------------------' !flush(iostd) ! endif ! deallocate ( perfectCrystal % cProj , perfectCrystal % pawK ) deallocate ( solidDefect % cProj , solidDefect % pawK ) ! Deallocate space for the projections ! else ! If the transition matrix elements for this k point have already been ! calculated and I'm root, read in the existing output file ! if ( myid == root ) call readUfis ( ik ) ! endif ! enddo ! if ( allocated ( paw_id ) ) deallocate ( paw_id ) if ( myid == root ) then if ( allocated ( perfectCrystal % paw_Wfc ) ) deallocate ( perfectCrystal % paw_Wfc ) if ( allocated ( solidDefect % paw_Wfc ) ) deallocate ( solidDefect % paw_Wfc ) endif !! * Deallocate space for the PAW corrections ! ! if ( myid == root ) then !! * If my ID is root, calculate `VfiElements` if needed and finalize !!   calculation ! if ( calculateVfis ) call calculateVfiElements () ! call finalizeCalculation () ! endif ! call MPI_FINALIZE ( ierr ) ! end program transitionMatrixElements","tags":"","loc":"sourcefile/tme_main_v9.f90.html","title":"TME_Main_v9.f90 – Carrier Cross Sections"},{"text":"Contents Modules TMEModule Source Code TME_Module_v28.f90 Source Code module TMEModule ! !! Declare all global variables !! and house all subroutines !! implicit none ! ! Declare integer parameters integer , parameter :: dp = selected_real_kind ( 15 , 307 ) !! Used to set real variables to double precision integer , parameter :: iostd = 16 !! Unit number for output file integer , parameter :: root = 0 !! ID of the root process ! ! Declare real parameters real ( kind = dp ), parameter :: evToHartree = 0.03674932538878_dp !! Conversion factor from eV to Hartree real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp !! Conversion factor from Hartree to eV real ( kind = dp ), parameter :: pi = 3.141592653589793_dp !! Pi real ( kind = dp ), parameter :: sq4pi = 3.544907701811032_dp !! \\sqrt{4\\pi} ! ! Declare complex parameter complex ( kind = dp ), parameter :: ii = cmplx ( 0.0_dp , 1.0_dp , kind = dp ) !! Complex i ! ! Declare character parameter character ( len = 6 ), parameter :: output = 'output' !! Name of the output file; !! used in [[TMEModule(module):readInput(subroutine)]] !! @todo Change I/O from file to console so that usage matches that of QE @endtodo ! ! ! Declare scalar integers integer :: gx integer :: gy integer :: gz integer :: i integer :: iBandFfinal integer :: iBandFinit integer :: iBandIfinal integer :: iBandIinit integer :: ibf integer :: ibi integer :: id integer :: ierr !! Error code returned from MPI integer :: ig integer :: ik integer :: ind2 integer :: ios !! Status returned from I/O commands integer :: iPn integer :: iTypes integer :: j integer :: JMAX !! 2*L_{\\text{max}} + 1 integer :: kf integer :: ki integer :: maxL !! Maximum angular momentum of projector from any atom type integer :: myid !! ID for each MPI process integer :: n integer :: n1 integer :: n2 integer :: n3 integer :: n4 integer :: nF integer :: nGf integer :: nGi integer :: nGvsF integer :: nGvsI integer :: nI integer :: np integer :: nPP integer :: npw integer :: npwMf integer :: npwMi integer :: npwNf integer :: npwNi integer :: nSquareProcs integer :: numOfPWs integer :: numOfUsedGvecsPP integer :: numprocs !! Number of processes in the MPI pool ! ! Declare scalar reals real ( kind = dp ) :: eBin real ( kind = dp ) t0 !! Start time for program real ( kind = dp ) tf !! End time for program real ( kind = dp ) :: threej ! ! Declare scalar complex numbers complex ( kind = dp ) :: paw complex ( kind = dp ) :: paw2 complex ( kind = dp ) :: pseudo1 complex ( kind = dp ) :: pseudo2 ! ! Define scalar logicals logical :: calculateVfis logical :: coulomb logical :: gamma_only logical :: master logical :: tmes_file_exists ! ! Declare scalar characters character ( len = 300 ) :: elementsPath character ( len = 320 ) :: mkdir !! Command for creating the elements path directory character ( len = 300 ) :: textDum !! Dummy variable to hold unneeded lines from input file character ( len = 200 ) :: VfisOutput !! Output file for ?? ! ! ! Declare matrix/vector integers integer , allocatable :: counts (:) !integer, allocatable :: displmnt(:) integer , allocatable :: igvs (:,:,:) integer , allocatable :: iqs (:) integer , allocatable :: nFs (:,:) integer , allocatable :: ngs (:,:) integer , allocatable :: nIs (:,:) integer , allocatable :: nPWsI (:) integer , allocatable :: nPWsF (:) integer , allocatable :: pwGvecs (:,:) integer , allocatable :: pwGs (:,:) ! ! Declare matrix/vector reals real ( kind = dp ), allocatable :: absVfi2 (:,:) real ( kind = dp ), allocatable :: DE (:,:) real ( kind = dp ), allocatable :: eigvF (:) real ( kind = dp ), allocatable :: eigvI (:) real ( kind = dp ), allocatable :: gvecs (:,:) ! ! Declare matrix/vector complex numbers complex ( kind = dp ), allocatable :: paw_id (:,:) complex ( kind = dp ), allocatable :: paw_fi (:,:) complex ( kind = dp ), allocatable :: pawPsiPC (:,:) complex ( kind = dp ), allocatable :: pawSDPhi (:,:) complex ( kind = dp ), allocatable :: paw_SDKKPC (:,:) complex ( kind = dp ), allocatable :: Ufi (:,:,:) ! ! ! type :: atom !! Define a new type to represent an atom in the structure. !! Each different type of atom in the structure will be another !! variable with the type `atom`. !! @todo Consider changing `atom` type to `element` since it holds more than one atom @endtodo ! ! Define scalar integers integer :: iRAugMax !! Maximum radius of beta projector (outer radius to integrate); !! for PAW augmentation charge may extend a bit further; I think this !! is the max index for the augmentation sphere, so I'm changing the !! name; last name was `iRc` integer :: numOfAtoms !! Number of atoms of a specific type in the structure integer :: numProjs !! Number of projectors integer :: lmMax !! Number of channels integer :: nMax !! Number of radial mesh points ! ! Define scalar character character ( len = 2 ) :: symbol !! Element name for the given atom type ! ! Define matrix/vector integer integer , allocatable :: projAngMom (:) !! Angular momentum of each projector ! ! Define matrix/vector reals real ( kind = dp ), allocatable :: bes_J_qr (:,:) real ( kind = dp ), allocatable :: F (:,:) real ( kind = dp ), allocatable :: F1 (:,:,:) real ( kind = dp ), allocatable :: F2 (:,:,:) real ( kind = dp ), allocatable :: r (:) !! Radial mesh real ( kind = dp ), allocatable :: rab (:) !! Derivative of radial mesh real ( kind = dp ), allocatable :: wae (:,:) !! All electron wavefunction real ( kind = dp ), allocatable :: wps (:,:) !! Psuedowavefunction ! end type atom ! ! type :: crystal integer :: nKpts !! Number of k points integer :: numOfPWs !! Total number of plane waves integer :: nIons !! Total number of atoms in system integer :: numOfTypes !! Number of different types of atoms integer :: nProjs !! Number of projectors integer :: numOfGvecs !! Number of G vectors !integer :: fftxMax, fftxMin, fftyMax, fftyMin, fftzMax, fftzMin !! FFT grid was read from `input` file but not used, so removed integer :: nBands !! Number of bands integer :: nSpins !! Number of spins integer , allocatable :: npws (:) !! Number of plane waves per k point integer , allocatable :: atomTypeIndex (:) !! Index of the given atom type !integer, allocatable :: groundState(:) ! Was read from `input` file but not used, so removed ! real ( kind = dp ) :: omega !! Cell volume !real(kind = dp) :: at(3,3) ! Was read from `input` file but not used, so removed real ( kind = dp ) :: bg ( 3 , 3 ) real ( kind = dp ), allocatable :: wk (:) real ( kind = dp ), allocatable :: xk (:, :) real ( kind = dp ), allocatable :: posIon (:,:) ! complex ( kind = dp ), allocatable :: wfc (:,:) complex ( kind = dp ), allocatable :: beta (:,:) complex ( kind = dp ), allocatable :: cProj (:,:,:) complex ( kind = dp ), allocatable :: cCrossProj (:,:,:) complex ( kind = dp ), allocatable :: paw_Wfc (:,:) complex ( kind = dp ), allocatable :: pawK (:,:,:) ! character ( len = 2 ) crystalType !! 'PC' for pristine crystal and 'SD' for solid defect character ( len = 200 ) :: exportDir !! Export directory from [[pw_export_for_tme(program)]] ! TYPE ( atom ), allocatable :: atoms (:) ! !    integer :: Jmax, maxL, iTypes, nn, nm !    integer :: i, j, n1, n2, n3, n4, n, id !    ! !    ! !    real(kind = dp), allocatable :: eigvI(:), eigvF(:) !    real(kind = dp), allocatable :: DE(:,:), absVfi2(:,:) !    ! !    complex(kind = dp), allocatable :: Ufi(:,:,:) !    ! !    integer, allocatable :: igvs(:,:,:), pwGvecs(:,:), iqs(:) !    integer, allocatable :: pwGs(:,:), nIs(:,:), nFs(:,:), ngs(:,:) ! end type crystal ! TYPE ( crystal ) :: perfectCrystal !! Structure that holds all of the information on the perfect crystal ! TYPE ( crystal ) :: solidDefect !! Structure that holds all of the information on the solid defect ! type :: vec ! integer :: ind integer , allocatable :: igN (:) integer , allocatable :: igM (:) end type vec ! ! Define vectors of vecs TYPE ( vec ), allocatable :: vecs (:) TYPE ( vec ), allocatable :: newVecs (:) ! ! !===================================================================================================== contains ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine initializeCalculation ( solidDefect , pristineCrystal , elementsPath , VFisOutput , ki , kf , eBin , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , calculateVFis , t0 ) !! Initialize the calculation by starting timer, !! setting start values for variables to be read from !! `.in` file, removing any existing output in the output directory, !! and opening a clean output file !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( out ) :: ki , kf , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! real ( kind = dp ), intent ( out ) :: eBin , t0 ! character ( len = 200 ), intent ( out ) :: VfisOutput character ( len = 300 ), intent ( out ) :: elementsPath ! logical , intent ( out ) :: calculateVfis logical :: fileExists !! Whether or not the output file already exists TYPE ( crystal ), intent ( inout ) :: solidDefect , pristineCrystal ! solidDefect % exportDir = '' perfectCrystal % exportDir = '' elementsPath = '' VfisOutput = '' ! ki = - 1 kf = - 1 ! eBin = - 1.0_dp ! iBandIinit = - 1 iBandIfinal = - 1 iBandFinit = - 1 iBandFfinal = - 1 ! calculateVfis = . false . ! perfectCrystal % crystalType = 'PC' solidDefect % crystalType = 'SD' ! call cpu_time ( t0 ) !! * Start a timer ! inquire ( file = output , exist = fileExists ) !! * Check if file output exists, if ( fileExists ) then !! and delete it if it does open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! return ! end subroutine initializeCalculation ! ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine readInput ( perfectCrystal , solidDefect , elementsPath , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput ) !! Delete any previous output, initialize input variables, !! start a timer, and read in the input files !! implicit none ! integer , intent ( inout ) :: ki , kf , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! character ( len = 300 ), intent ( inout ) :: elementsPath character ( len = 200 ), intent ( inout ) :: VfisOutput character ( len = 200 ) :: exportDirSD character ( len = 200 ) :: exportDirPC ! logical , intent ( inout ) :: calculateVfis ! TYPE ( crystal ), intent ( inout ) :: perfectCrystal !! Holds all of the information on the perfect crystal TYPE ( crystal ), intent ( inout ) :: solidDefect !! Holds all of the information on the defective crystal ! NAMELIST / TME_Input / exportDirSD , exportDirPC , elementsPath , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput , eBin !! Used to group the variables read in from the .in file ! ! READ ( 5 , TME_Input , iostat = ios ) !! * Read input from command line (or input file if use `< TME_Input.md`) solidDefect % exportDir = exportDirSD perfectCrystal % exportDir = exportDirPC ! call checkInitialization () !! * Check that all required variables were input and have values that make sense ! call readQEExport ( perfectCrystal ) !! * Read perfect crystal inputs call readQEExport ( solidDefect ) !! * Read solid defect inputs ! numOfPWs = max ( perfectCrystal % numOfPWs , solidDefect % numOfPWs ) !! * Calculate the number of plane waves as the maximum of the number of PC and SD plane waves ! return ! end subroutine readInput ! ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine checkInitialization () !! Check to see if variables from .in file still !! have the values set in [[TMEModule(module):initializeCalculation(subroutine)]] !! or if they have values that aren't allowed !! !! <h2>Walkthrough</h2> !! !! @todo Change `checkInitialization()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! logical :: fileExists !! Whether or not the exported directory from [[pw_export_for_TME(program)]] !! exists logical :: abortExecution ! abortExecution = . false . !! * Set the default value of abort execution so that the program !! will only abort if there is an issue with the inputs ! write ( iostd , '(\" Inputs : \")' ) !! * Write out a header to the output file ! if ( wasRead ( LEN ( trim ( solidDefect % exportDir )) - 1 , 'exportDirSD' , 'exportDirSD = ''./Export/''' , abortExecution ) ) then !! * If the SD export directory variable was read !!    * Check if the SD export directory exists !!    * If the SD export directory doesn't exist !!       * Output an error message and set `abortExecution` to true !!    * Output the given SD export directory ! inquire ( file = trim ( solidDefect % exportDir ), exist = fileExists ) ! if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" exportDirSD :\", a, \" does not exist !\")' ) trim ( solidDefect % exportDir ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"exportDirSD = ''\", a, \"''\")' ) trim ( solidDefect % exportDir ) ! endif ! ! if ( wasRead ( LEN ( trim ( perfectCrystal % exportDir )) - 1 , 'exportDirPC' , 'exportDirPC = ''./Export/''' , abortExecution ) ) then !! * If the PC export directory variable was read !!    * Check if the PC export directory exists !!    * If the PC export directory doesn't exist !!       * Output an error message and set `abortExecution` to true !!    * Output the given PC export directory ! inquire ( file = trim ( perfectCrystal % exportDir ), exist = fileExists ) ! if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" exportDirPC :\", a, \" does not exist !\")' ) trim ( perfectCrystal % exportDir ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"exportDirPC = ''\", a, \"''\")' ) trim ( perfectCrystal % exportDir ) ! endif ! if ( . not . wasRead ( LEN ( elementsPath ) - 1 , 'elementsPath' , 'elementsPath = ''./''' ) ) then !! * If the elements path was not read, set the default value to `./` ! write ( iostd , '(\" The current directory will be used as elementsPath.\")' ) elementsPath = './' ! endif ! inquire ( file = trim ( elementsPath ), exist = fileExists ) !! * Check if the elements path folder exists already ! if ( . not . fileExists ) then !! * If the elements path folder doesn't already exist !!    * Write the `mkdir` command to a string !!    * Execute the command to create the directory ! write ( mkDir , '(\"mkdir -p \", a)' ) trim ( elementsPath ) ! call system ( mkDir ) ! endif ! write ( iostd , '(\"elementsPath = ''\", a, \"''\")' ) trim ( elementsPath ) !! * Output the elements path ! if ( wasRead ( iBandIinit , 'iBandIinit' , 'iBandIinit = 10' , abortExecution ) ) then !! * If `iBandIinit` was read, output its value ! write ( iostd , '(\"iBandIinit = \", i4)' ) iBandIinit ! endif ! if ( wasRead ( iBandIfinal , 'iBandIfinal' , 'iBandIfinal = 20' , abortExecution ) ) then !! * If `iBandIfinal` was read, output its value ! write ( iostd , '(\"iBandIfinal = \", i4)' ) iBandIfinal ! endif ! if ( wasRead ( iBandFinit , 'iBandFinit' , 'iBandFinit = 9' , abortExecution ) ) then !! * If `iBandFinit` was read, output its value ! write ( iostd , '(\"iBandFinit = \", i4)' ) iBandFinit ! endif ! if ( wasRead ( iBandFfinal , 'iBandFfinal' , 'iBandFfinal = 9' , abortExecution ) ) then !! * If `iBandFfinal` was read, output its value ! write ( iostd , '(\"iBandFfinal = \", i4)' ) iBandFfinal ! endif ! !> * If `calculateVfis` is true and `iBandFinit` and `iBandFfinal` are not equal !>    * Output an error message and set `abortExecution` to true if ( ( calculateVfis ) . and . ( iBandFinit /= iBandFfinal ) ) then ! write ( iostd , * ) write ( iostd , '(\" Vfis can be calculated only if the final state is one and only one!\")' ) write ( iostd , '(\" ''iBandFInit'' = \", i10)' ) iBandFinit write ( iostd , '(\" ''iBandFfinal'' = \", i10)' ) iBandFfinal write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"calculateVfis = \", l )' ) calculateVfis !! * Output the value of `calculateVfis` ! !> * If the `VfisOutput` file name is blank !>    * Output a warning message and set the default value to `VfisVsE` if ( trim ( VfisOutput ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"VfisOutput\"\" is not defined!\")' ) write ( iostd , '(\" usage : VfisOutput = ''VfisVsE''\")' ) write ( iostd , '(\" The default value ''VfisVsE'' will be used.\")' ) VfisOutput = 'VfisVsE' ! endif ! write ( iostd , '(\"VfisOutput = ''\", a, \"''\")' ) trim ( VfisOutput ) !! * Output the value of `VfisOutput` !> @todo Remove everything with `ki` and `kf` because never used @endtodo ! !if( .not. wasRead(ki, 'ki', 'ki = 1') ) then !  !! * If `ki` wasn't read, set the default value to 1 !  ! !  write(iostd, '(\" ki = 1 will be used.\")') !  ki = 1 !  ! !endif ! !if( .not. wasRead(kf, 'kf', 'kf = 1') ) then !  !! * If `kf` wasn't read, set the default value to the total !  !!   number of k points (actually done in [[TMEModeul(module):readQEInput(subroutine)]] !  !!   where the total number of k points is read !  ! !  write(iostd, '(\" kf = total number of k-points will be used.\")') !  ! !endif ! !if ( ki /= kf ) then !  write(iostd, *) !  write(iostd, '(\" Initial k-point index ''ki'', should be equal to the Final k-point index ''kf'' !\")') !  write(iostd, '(\" Calculation of transition matrix elements with momentum transfer is not implemented!\")') !  write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  abortExecution = .true. !endif ! if ( . not . wasRead ( INT ( eBin ), 'eBin' , 'eBin = 0.01' ) ) then !! * If the value of `eBin` was not read !!    * Output a warning message and set the default value to 0.01 eV ! write ( iostd , '(\" A default value of 0.01 eV will be used !\")' ) eBin = 0.01_dp ! eV ! endif ! write ( iostd , '(\"eBin = \", f8.4, \" (eV)\")' ) eBin !! * Output the value of eBin ! eBin = eBin * evToHartree !! * Convert `eBin` from eV to Hartree ! if ( abortExecution ) then !! * If `abortExecution` was ever set to true !!    * Output an error message and stop the program write ( iostd , '(\" Program stops!\")' ) stop endif ! flush ( iostd ) !! * Make the output file available for other processes ! return ! end subroutine checkInitialization ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine readQEExport ( system ) !! Read input files in the Export directory created by !! [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! ! implicit none ! !integer, intent(in) :: id ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect` ! integer :: i , ik , iType , ni !! Loop index integer :: iRAugMax !! Local value of `iRAugMax` for each atom so don't have to keep accessing in loop integer :: l !! Angular momentum of each projector read from input file integer :: ind !! Index of each projector read from input file integer :: iDum !! Dummy variable to hold trash from input file ! real ( kind = dp ) :: t1 !! Local start time real ( kind = dp ) :: t2 !! Local end time real ( kind = dp ) :: ef ! character ( len = 300 ) :: textDum !! Dummy variable to hold trash from input file character ( len = 300 ) :: input !! The input file path ! logical :: fileExists !! Whether or not the `input` file exists in the given !! Export directory ! call cpu_time ( t1 ) !! * Start a local timer ! !> * Output header to output file based on the input crystal type !> @note !> The program will end if a crystal type other than `PC` or `SD` is used. !> @endnote write ( iostd , * ) if ( system % crystalType == 'PC' ) then ! write ( iostd , '(\" Reading perfect crystal inputs.\")' ) ! else if ( system % crystalType == 'SD' ) then ! write ( iostd , '(\" Reading solid defect inputs.\")' ) ! else ! write ( iostd , '(\"Unknown crystal type\", a, \".\")' ) system % crystalType write ( iostd , '(\"Please only use PC for pristine crystal or SD for solid defect.\")' ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! write ( iostd , * ) ! input = trim ( trim ( system % exportDir ) // '/input' ) !! * Set the path for the input file from the PC export directory ! inquire ( file = trim ( input ), exist = fileExists ) !! * Check if the input file from the PC export directory exists ! !> * If the input file doesn't exist !>    * Output an error message and end the program if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" File : \", a, \" , does not exist!\")' ) trim ( input ) write ( iostd , '(\" Please make sure that folder : \", a, \" has been created successfully !\")' ) trim ( system % exportDir ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! !............................................................................................... !> * Open and read the [input](../page/inputOutput/exportedInput.html) file ! open ( 50 , file = trim ( input ), status = 'old' ) ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(ES24.15E3)' ) system % omega ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % nKpts !if ( kf < 0 ) kf = system%nKpts ! read ( 50 , '(a)' ) textDum ! allocate ( system % npws ( system % nKpts ), system % wk ( system % nKpts ), system % xk ( 3 , system % nKpts ) ) ! !allocate( system%groundState(system%nKpts) ) ! Don't allocate space for groundState because it is never used ! do ik = 1 , system % nKpts ! !read(50, '(3i10,4ES24.15E3)') iDum, system%groundState(ik), system%npws(ik), system%wk(ik), system%xk(1:3,ik) ! Don't read in groundState because it is never used read ( 50 , '(3i10,4ES24.15E3)' ) iDum , iDum , system % npws ( ik ), system % wk ( ik ), system % xk ( 1 : 3 , ik ) ! enddo ! read ( 50 , '(a)' ) textDum ! read ( 50 , * ) system % numOfGvecs ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % numOfPWs ! read ( 50 , '(a)' ) textDum ! !read(50, '(6i10)') fftxMin, fftxMax, fftyMin, fftyMax, fftzMin, fftzMax ! Don't read in FFT grid because it is never used read ( 50 , * ) ! read ( 50 , '(a)' ) textDum ! !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,1) !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,2) !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,3) ! Don't read in `at` because it is never used read ( 50 , * ) read ( 50 , * ) read ( 50 , * ) ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 1 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 2 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 3 ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % nIons ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % numOfTypes ! allocate ( system % posIon ( 3 , system % nIons ), system % atomTypeIndex ( system % nIons ) ) ! read ( 50 , '(a)' ) textDum ! do ni = 1 , system % nIons ! read ( 50 , '(i10, 3ES24.15E3)' ) system % atomTypeIndex ( ni ), system % posIon ( 1 : 3 , ni ) ! enddo ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(i10)' ) system % nBands ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(i10)' ) system % nSpins ! allocate ( system % atoms ( system % numOfTypes ) ) ! system % nProjs = 0 ! do iType = 1 , system % numOfTypes ! read ( 50 , '(a)' ) textDum read ( 50 , * ) system % atoms ( iType )% symbol ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% numOfAtoms ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% numProjs ! number of projectors ! allocate ( system % atoms ( iType )% projAngMom ( system % atoms ( iType )% numProjs ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , system % atoms ( iType )% numProjs ! read ( 50 , '(2i10)' ) l , ind system % atoms ( iType )% projAngMom ( ind ) = l ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% lmMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(2i10)' ) system % atoms ( iType )% nMax , system % atoms ( iType )% iRAugMax ! allocate ( system % atoms ( iType )% r ( system % atoms ( iType )% nMax ), system % atoms ( iType )% rab ( system % atoms ( iType )% nMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , system % atoms ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) system % atoms ( iType )% r ( i ), system % atoms ( iType )% rab ( i ) ! enddo ! allocate ( system % atoms ( iType )% wae ( system % atoms ( iType )% nMax , system % atoms ( iType )% numProjs ) ) allocate ( system % atoms ( iType )% wps ( system % atoms ( iType )% nMax , system % atoms ( iType )% numProjs ) ) ! read ( 50 , '(a)' ) textDum do j = 1 , system % atoms ( iType )% numProjs do i = 1 , system % atoms ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) system % atoms ( iType )% wae ( i , j ), system % atoms ( iType )% wps ( i , j ) ! write(iostd, '(2i5, ES24.15E3)') j, i, abs(system%atoms(iType)%wae(i, j)-system%atoms(iType)%wps(i, j)) ! enddo enddo ! allocate ( system % atoms ( iType )% F ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs ) ) !, system%atoms(iType)%numProjs) ) allocate ( system % atoms ( iType )% F1 ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs , system % atoms ( iType )% numProjs ) ) allocate ( system % atoms ( iType )% F2 ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs , system % atoms ( iType )% numProjs ) ) ! system % atoms ( iType )% F = 0.0_dp system % atoms ( iType )% F1 = 0.0_dp system % atoms ( iType )% F2 = 0.0_dp ! !> * Calculate `F`, `F1`, and `F2` using the all-electron and psuedowvefunctions !> @todo Look more into how AE and PS wavefunctions are combined to further understand this @endtodo !> @todo Move this behavior to another subroutine for clarity @endtodo do j = 1 , system % atoms ( iType )% numProjs ! iRAugMax = system % atoms ( iType )% iRAugMax ! system % atoms ( iType )% F ( 1 : iRAugMax , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% r ( 1 : iRAugMax ) * system % atoms ( iType )% rab ( 1 : iRAugMax ) ! do i = 1 , system % atoms ( iType )% numProjs !> @todo Figure out if differences in PC and SD `F1` calculations are intentional @endtodo !> @todo Figure out if should be `(wae_i wae_j - wps_i wps_j)r_{ab}` @endtodo !> @todo Figure out if first term in each should be conjugated for inner product form @endtodo !> @todo Figure out if `rab` plays role of dr within augmentation sphere @endtodo if ( system % crystalType == 'PC' ) then ! system % atoms ( iType )% F1 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) ! else if ( system % crystalType == 'SD' ) then ! system % atoms ( iType )% F1 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) ! endif ! system % atoms ( iType )% F2 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) + & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) enddo enddo ! system % nProjs = system % nProjs + system % atoms ( iType )% numOfAtoms * system % atoms ( iType )% lmMax ! deallocate ( system % atoms ( iType )% wae , system % atoms ( iType )% wps ) !deallocate ( system%groundState ) ! Don't use because groundState is never used ! enddo ! !............................................................................................... ! close ( 50 ) !! * Close the input file ! !> * Go through the `projAngMom` values for each projector for each atom !> and find the max to store in `JMAX` !> @todo Figure out if intentional to only use `JMAX` from SD input @endtodo JMAX = 0 do iType = 1 , system % numOfTypes ! do i = 1 , system % atoms ( iType )% numProjs ! if ( system % atoms ( iType )% projAngMom ( i ) > JMAX ) JMAX = system % atoms ( iType )% projAngMom ( i ) ! enddo ! enddo ! maxL = JMAX JMAX = 2 * JMAX + 1 ! do iType = 1 , system % numOfTypes ! allocate ( system % atoms ( iType )% bes_J_qr ( 0 : JMAX , system % atoms ( iType )% iRAugMax ) ) system % atoms ( iType )% bes_J_qr (:,:) = 0.0_dp ! enddo ! !> * End the local timer and write out the total time to read the inputs !> to the output file call cpu_time ( t2 ) write ( iostd , '(\" Reading input files done in:                \", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) flush ( iostd ) ! return ! end subroutine readQEExport ! ! subroutine readPWsSet () !! Read the g vectors in Miller indices from `mgrid` file and convert !! using reciprocal lattice vectors !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer :: ig , iDum , iGx , iGy , iGz ! open ( 72 , file = trim ( solidDefect % exportDir ) // \"/mgrid\" ) !! * Open the `mgrid` file from Export directory from [[pw_export_for_tme(program)]] ! !> * Ignore the first two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( gvecs ( 3 , solidDefect % numOfGvecs ) ) !! * Allocate space for the g vectors ! gvecs (:,:) = 0.0_dp !! * Initialize all of the g vectors to zero ! do ig = 1 , solidDefect % numOfGvecs !! * For each g vector !!    * Read in the g vector in terms of Miller indices !!    * Calculate the g vector using the reciprocal lattice vectors from input file read ( 72 , '(4i10)' ) iDum , iGx , iGy , iGz gvecs ( 1 , ig ) = dble ( iGx ) * solidDefect % bg ( 1 , 1 ) + dble ( iGy ) * solidDefect % bg ( 1 , 2 ) + dble ( iGz ) * solidDefect % bg ( 1 , 3 ) gvecs ( 2 , ig ) = dble ( iGx ) * solidDefect % bg ( 2 , 1 ) + dble ( iGy ) * solidDefect % bg ( 2 , 2 ) + dble ( iGz ) * solidDefect % bg ( 2 , 3 ) gvecs ( 3 , ig ) = dble ( iGx ) * solidDefect % bg ( 3 , 1 ) + dble ( iGy ) * solidDefect % bg ( 3 , 2 ) + dble ( iGz ) * solidDefect % bg ( 3 , 3 ) enddo ! close ( 72 ) !! Close the `mgrid` file ! return ! end subroutine readPWsSet ! ! subroutine distributePWsToProcs ( nOfPWs , nOfBlocks ) !! Determine how many g vectors each process should get !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: nOfPWs !! Number of g vectors integer , intent ( in ) :: nOfBlocks !! Number of processes integer :: iStep !! Number of g vectors per number of processes integer :: iModu !! Number of remaining g vectors after giving !! each process the same number of g vectors ! iStep = int ( nOfPWs / nOfBlocks ) !! * Determine the base number of g vectors to give !!   to each process iModu = mod ( nOfPWs , nOfBlocks ) !! * Determine the number of g vectors left over after that ! do i = 0 , nOfBlocks - 1 !! * For each process, give the base amount and an extra !!   if there were any still left over counts ( i ) = iStep ! if ( iModu > 0 ) then ! counts ( i ) = counts ( i ) + 1 ! iModu = iModu - 1 ! endif ! enddo ! !displmnt(0) = 0 !do i = 1, nOfBlocks-1 !  displmnt(i) = displmnt(i-1) + counts(i) !enddo ! return ! end subroutine distributePWsToProcs ! ! subroutine checkIfCalculated ( ik , tmes_file_exists ) !! Determine if the output file for a given k point already exists !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index logical , intent ( out ) :: tmes_file_exists !! Whether or not the output file exists ! character ( len = 300 ) :: Uelements !! Output file name character ( len = 300 ) :: ikstr !! String version of integer input `ik` ! call int2str ( ik , ikstr ) write ( Uelements , '(\"/TMEs_kptI_\",a,\"_kptF_\",a)' ) trim ( ikstr ), trim ( ikstr ) !! * Determine what the file name should be based on the k point index ! inquire ( file = trim ( elementsPath ) // trim ( Uelements ), exist = tmes_file_exists ) !! * Check if that file already exists ! return ! end subroutine checkIfCalculated ! ! subroutine calculatePWsOverlap ( ik ) !! Read the wavefunctions and calculate the overlap !! \\langle\\Phi_f|\\Psi_i\\rangle !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ibi , ibf !! Loop index ! call readWfc ( ik , perfectCrystal ) !! * Read the perfect crystal wavefunction ([[TMEModule(module):readWfc(subroutine)]]) ! call readWfc ( ik , solidDefect ) !! * Read the solid defect wavefunction ([[TMEModule(module):readWfc(subroutine)]]) ! Ufi (:,:, ik ) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize `Ufi` for the given k point to complex double zero ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal !! * For each initial band, calculate \\sum \\phi_f&#94;*\\psi_i (overlap??) with each final band !! Ufi ( ibf , ibi , ik ) = sum ( conjg ( solidDefect % wfc (:, ibf )) * perfectCrystal % wfc (:, ibi )) !! * Calculate \\langle\\Phi_f|\\Psi_i\\rangle !! !if ( ibi == ibf ) write(iostd,'(2i4,3ES24.15E3)') ibf, ibi, Ufi(ibf, ibi, ik), abs(Ufi(ibf, ibi, ik))**2 flush ( iostd ) ! enddo ! enddo ! return ! end subroutine calculatePWsOverlap ! ! subroutine readWfc ( ik , system ) !! Open the `grid.ki` file from [[pw_export_for_tme(program)]] !! to get the indices for the wavefunction to be stored in, then !! open the `wfc.ki` file and read in the wavefunction for the !! proper bands and store in the proper indices in the system's `wfc` !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ib , ig !! Loop index integer :: iDumV ( 3 ) !! Dummy vector to ignore g vectors from `grid.ki` integer , allocatable :: pwGind (:) !! Indices for the wavefunction of a given k point ! complex ( kind = dp ) :: wfc !! Wavefunction ! character ( len = 300 ) :: ikstr !! String version of the k point index ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! open ( 72 , file = trim ( system % exportDir ) // \"/grid.\" // trim ( ikstr )) !! * Open the `grid.ki` file from [[pw_export_for_tme(program)]] ! !> * Ignore the first two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGind ( system % npws ( ik )) ) !! * Allocate space for `pwGind` ! do ig = 1 , system % npws ( ik ) !! * For each plane wave for a given k point, !!   read in the indices for the plane waves that !!   are held in `wfc.ki` ! read ( 72 , '(4i10)' ) pwGind ( ig ), iDumV ( 1 : 3 ) ! enddo ! close ( 72 ) !! * Close the `grid.ki` file ! open ( 72 , file = trim ( system % exportDir ) // \"/wfc.\" // trim ( ikstr )) !! * Open the `wfc.ki` file from [[pw_export_for_tme(program)]] ! !> Ignore the first two lines because they are comments read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandIinit - 1 do ig = 1 , system % npws ( ik ) !! * For each band before `iBandInit`, ignore all of the !!   plane waves for the given k point read ( 72 , * ) ! enddo enddo ! system % wfc (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize the wavefunction to complex double zero ! do ib = iBandIinit , iBandIfinal do ig = 1 , system % npws ( ik ) !! * For bands between `iBandIinit` and `iBandIfinal`, !!   read in all of the plane waves for the given k point !!   and store them in the proper index of the system's `wfc` ! read ( 72 , '(2ES24.15E3)' ) wfc system % wfc ( pwGind ( ig ), ib ) = wfc ! enddo enddo ! close ( 72 ) !! * Close the `wfc.ki` file ! deallocate ( pwGind ) !! * Deallocate space for `pwGind` ! return ! end subroutine readWfc ! ! subroutine readProjections ( ik , system ) !! Read in the projection \\langle\\beta|\\Psi\\rangle for each band !! !! <H2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: i , j !! Loop index ! character ( len = 300 ) :: ikstr !! String version of k point index TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! system % cProj (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize `cProj` to all complex double zero ! open ( 72 , file = trim ( system % exportDir ) // \"/projections.\" // trim ( ikstr )) !! * Open the `projections.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) !! * Ignore the first line as it is a comment ! !write(6,'(\"Solid defect nBands: \", i3)') solidDefect%nBands !write(6,'(\"Solid defect nSpins: \", i3)') solidDefect%nSpins !write(6,'(\"Perfect crystal nBands: \", i3)') perfectCrystal%nBands !write(6,'(\"Perfect crystal nSpins: \", i3)') perfectCrystal%nSpins !! @todo Get actual perfect crystal and solid defect output to test @endtodo !! @todo Figure out if loop should be over `solidDefect` or `perfectCrystal` @endtodo !! @todo Look into `nSpins` to figure out if it is needed @endtodo do j = 1 , solidDefect % nBands ! number of bands do i = 1 , system % nProjs ! number of projections !! * For each band, read in the projections \\langle\\beta|\\Psi\\rangle ! read ( 72 , '(2ES24.15E3)' ) system % cProj ( i , j , 1 ) ! enddo enddo ! close ( 72 ) ! return ! end subroutine readProjections ! ! subroutine projectBeta ( ik , betaSystem , projectedSystem ) !! @todo Figure out what this subroutine really does !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ig , i , j !! Loop index integer :: iDumV ( 3 ), iDum !! Dummy variable to ignore input from file integer , allocatable :: pwGind (:) !! Indices for the wavefunction of a given k point ! character ( len = 300 ) :: ikstr !! String version of the k point index ! TYPE ( crystal ), intent ( inout ) :: betaSystem !! Holds the structure for the system you are getting \\beta from !! (either `perfectCrystal` or `solidDefect`) TYPE ( crystal ), intent ( inout ) :: projectedSystem !! Holds the structure for the system you are projecting !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! ! Reading PC projectors ! open ( 72 , file = trim ( betaSystem % exportDir ) // \"/grid.\" // trim ( ikstr )) !! * Open the `grid.ki` file from [[pw_export_for_tme(program)]] ! !> * Ignore the next two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGind ( betaSystem % npws ( ik )) ) !! * Allocate space for `pwGind` ! do ig = 1 , betaSystem % npws ( ik ) !! * Read in the index for each plane wave ! read ( 72 , '(4i10)' ) pwGind ( ig ), iDumV ( 1 : 3 ) ! enddo ! close ( 72 ) !! * Close the `grid.ki` file ! ! allocate ( betaSystem % beta ( numOfPWs , betaSystem % nProjs ) ) !! * Allocate space for |\\beta\\rangle ! betaSystem % beta (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values of |\\beta\\rangle to complex double zero ! open ( 73 , file = trim ( betaSystem % exportDir ) // \"/projectors.\" // trim ( ikstr )) !! * Open the `projectors.ki` file from [[pw_export_for_tme(program)]] ! read ( 73 , * ) !! * Ignore the first line because it is a comment read ( 73 , * ) !! * Ignore the second line because it is the number of projectors that !!   was already calculated in [[TMEModule(module):readQEExport(subroutine)]] !!   and the number of plane waves for a given k point that was read in in the !!   same subroutine ! do j = 1 , betaSystem % nProjs do i = 1 , betaSystem % npws ( ik ) !! * Read in each |\\beta\\rangle and store in the proper index of `beta` !!   for the system ! read ( 73 , '(2ES24.15E3)' ) betaSystem % beta ( pwGind ( i ), j ) ! enddo enddo ! close ( 73 ) ! deallocate ( pwGind ) !! * Deallocate space for `pwGind` ! if ( betaSystem % crystalType == \"PC\" ) then !! * If the system that you are getting |\\beta\\rangle from !!   is the perfect crystal, then calculate !!   \\langle\\beta|\\Phi\\rangle between `iBandFinit` !!   and `iBandFfinal` ! do j = iBandFinit , iBandFfinal do i = 1 , betaSystem % nProjs ! betaSystem % cCrossProj ( i , j , 1 ) = sum ( conjg ( betaSystem % beta (:, i )) * projectedSystem % wfc (:, j )) ! enddo enddo ! else if ( betaSystem % crystalType == \"SD\" ) then !! * If the system that you are getting |\\beta\\rangle from !!   is the solid defect, then calculate !!   \\langle\\beta|\\Psi\\rangle between `iBandIinit` !!   and `iBandIfinal` ! do j = iBandIinit , iBandIfinal do i = 1 , betaSystem % nProjs betaSystem % cCrossProj ( i , j , 1 ) = sum ( conjg ( betaSystem % beta (:, i )) * projectedSystem % wfc (:, j )) enddo enddo ! endif ! deallocate ( betaSystem % beta ) !! * Deallocate space for |\\beta\\rangle ! return ! end subroutine projectBeta ! ! subroutine pawCorrectionWfc ( system ) !! Calculates the augmentation part of the transition matrix element !! @todo Figure out what this subroutine really does @endtodo !! !! <h2>Walkthrough</h2> !! implicit none integer :: iIon !! Loop index over atoms integer :: iProj , jProj !! Loop index of projectors integer :: ibi , ibf !! Loop index over bands integer :: m , mPrime !! Loop index for magnetic quantum number for a given projector integer :: ispin integer :: LMBASE integer :: LM , LMP !! Index for cProj integer :: l , lPrime !! Angular momentum quantum number for a given projector integer :: iAtomType !! Atom type index for a given ion in the system ! real ( kind = dp ) :: atomicOverlap ! complex ( kind = dp ) :: cProjIe , cProjFe ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! ispin = 1 !! * Set the value of `ispin` to 1 !! @note !! `ispin` never has a value other than one, so I'm not sure !!  what its purpose is !! @endnote ! system % paw_Wfc (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values in `paw_Wfc` to complex double zero ! LMBASE = 0 !! * Initialize the base offset for `cProj`'s first index to zero ! do iIon = 1 , system % nIons !! * For each atom in the system !!    * Get the index for the atom type !!    * Loop over the projectors twice, each time finding the !!      angular momentum quantum number (l and l&#94;{\\prime}) !!      and magnetic quantum number (m and m&#94;{\\prime}) !!    * If l = l&#94;{\\prime} and m = m&#94;{\\prime}, loop over the bands to !!      calculate `paw_Wfc` !! !! @todo Figure out the significance of l = l&#94;{\\prime} and m = m&#94;{\\prime} @endtodo ! iAtomType = system % atomTypeIndex ( iIon ) ! LM = 0 ! do iProj = 1 , system % atoms ( iAtomType )% numProjs ! l = system % atoms ( iAtomType )% projAngMom ( iProj ) ! do m = - l , l ! LM = LM + 1 !1st index for CPROJ ! LMP = 0 ! do jProj = 1 , system % atoms ( iAtomType )% numProjs ! lPrime = system % atoms ( iAtomType )% projAngMom ( jProj ) ! do mPrime = - lPrime , lPrime ! LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp ! if ( ( l == lPrime ). and .( m == mPrime ) ) then ! atomicOverlap = sum ( system % atoms ( iAtomType )% F1 (:, iProj , jProj )) ! do ibi = iBandIinit , iBandIfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! cProjIe = system % cProj ( LMP + LMBASE , ibi , ISPIN ) ! else if ( system % crystalType == 'SD' ) then ! cProjIe = system % cCrossProj ( LMP + LMBASE , ibi , ISPIN ) ! endif ! do ibf = iBandFinit , iBandFfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! cProjFe = conjg ( system % cCrossProj ( LM + LMBASE , ibf , ISPIN )) ! else if ( system % crystalType == 'SD' ) then ! cProjFe = conjg ( system % cProj ( LM + LMBASE , ibf , ISPIN )) ! endif ! system % paw_Wfc ( ibf , ibi ) = system % paw_Wfc ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe ! enddo ! enddo ! endif ! enddo ! enddo ! enddo ! enddo ! LMBASE = LMBASE + system % atoms ( iAtomType )% lmMax ! enddo ! return ! end subroutine pawCorrectionWfc ! ! subroutine pawCorrectionK ( system ) !! @todo Figure out what this subroutine really does @endtodo !! !! <h2>Walkthrough</h2> ! implicit none ! !integer, intent(in) :: ik ! integer :: ibi , ibf !! Loop index over bands integer :: iPW !! Loop index over plane waves for a given process integer :: iProj !! Loop index over projectors integer :: iR !! Loop index over radial mesh (up to augmentation sphere) integer :: iAtomType !! Loop index over atom types integer :: iIon !! Loop index over ions in system integer :: l !! Angular momentum quantum number integer :: m !! Magnetic quantum number integer :: ispin integer :: LMBASE integer :: LM integer :: ind ! real ( kind = dp ) :: qDotR !! \\mathbf{G}\\cdot\\mathbf{r} real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time real ( kind = dp ) :: v_in ( 3 ) !! Unit vector in the direction of \\mathbf{G} real ( kind = dp ) :: JL ( 0 : JMAX ) !! Spherical bessel functions for a point up to `JMAX` real ( kind = dp ) :: q real ( kind = dp ) :: FI ! complex ( kind = dp ) :: Y ( ( JMAX + 1 ) ** 2 ) !! All spherical harmonics up to some max momentum complex ( kind = dp ) :: ATOMIC_CENTER !! e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} complex ( kind = dp ) :: VifQ_aug ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! ispin = 1 !! * Set the value of `ispin` to 1 !! @note !! `ispin` never has a value other than one, so I'm not sure !!  what its purpose is !! @endnote ! call cpu_time ( t1 ) !! * Start a timer ! system % pawK (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values in `pawK` to complex double zero ! do iPW = nPWsI ( myid ), nPWsF ( myid ) !! * Loop through the plane waves for a given process ! if ( myid == root ) then if ( ( iPW == nPWsI ( myid ) + 1000 ) . or . ( mod ( iPW , 25000 ) == 0 ) . or . ( iPW == nPWsF ( myid )) ) then !! * If this is the root process, output a status update every 1000 plane waves !!   and every multiple of 25000, giving an estimate of the time remaining at each step !!   @todo Figure out if this output slows things down significantly @endtodo !!   @todo Figure out if formula gives accurate representation of time left @endtodo ! call cpu_time ( t2 ) ! write ( iostd , '(\"        Done \", i10, \" of\", i10, \" k-vecs. ETR : \", f10.2, \" secs.\")' ) & iPW , nPWsF ( myid ) - nPWsI ( myid ) + 1 , ( t2 - t1 ) * ( nPWsF ( myid ) - nPWsI ( myid ) + 1 - iPW ) / iPW ! flush ( iostd ) ! !call cpu_time(t1) ! endif endif ! q = sqrt ( sum ( gvecs (:, iPW ) * gvecs (:, iPW ))) !! * Calculate `q` as \\sqrt{\\mathbf{G}\\cdot\\mathbf{G}} !!   to get length of \\mathbf{G} ! !> * Define a unit vector in the direction of \\mathbf{G}, !>   but only divide by the length if it is bigger than !>   1\\times10&#94;{-6} to avoid dividing by very small numbers v_in (:) = gvecs (:, iPW ) if ( abs ( q ) > 1.0e-6_dp ) v_in = v_in / q ! Y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize the spherical harmonics to complex double zero call ylm ( v_in , JMAX , Y ) !! * Calculate spherical harmonics with argument `v_in` up to !!   Y_{J_{\\text{max}}}&#94;{\\pm J_{\\text{max}}} ! LMBASE = 0 !! * Initialize the base offset for `cProj`'s first index to zero ! do iAtomType = 1 , system % numOfTypes ! do iR = 1 , system % atoms ( iAtomType )% iRAugMax !! * For each atom type, loop through the r points !!   in the augmentation sphere and calculate the !!   spherical Bessel functions from 0 to `JMAX` !!   at each point ! JL = 0.0_dp ! call bessel_j ( q * solidDefect % atoms ( iAtomType )% r ( iR ), JMAX , JL ) ! returns the spherical bessel at qr point !! @todo Figure out if this should be `system` @endtodo !! @todo Figure out significance of \"qr\" point @endtodo ! system % atoms ( iAtomType )% bes_J_qr (:, iR ) = JL (:) !! @todo Test if can just directly store in each atom type's `bes_J_qr` @endtodo ! enddo ! enddo ! do iIon = 1 , system % nIons !! * For each atom in the system !!    * Calculate \\mathbf{G}\\cdot\\mathbf{r} !!    * Calculate e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} !!    * Get the index for the atom type !!    * Loop over the projectors, finding l, m for each !!    * For each possible m !!       * Calculate \\text{FI} = j_l\\cdot F where j_l is !!         the Bessel function and F is for a given projector !!       * Calculate \\text{VifQ_aug} = e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} !!         Y_l&#94;m(\\mathbf{G}/|\\mathbf{G}|)(-i)&#94;l\\text{FI} !!       * Loop over the bands, summing `VifQ_aug*cProj` to get `pawK` ! qDotR = sum ( gvecs (:, iPW ) * system % posIon (:, iIon )) !! @todo Figure out if this should be `gDotR` @endtodo ! !> @todo Figure out why this is called `ATOMIC_CENTER` @endtodo !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! ATOMIC_CENTER = exp ( - ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! else if ( system % crystalType == 'SD' ) then ! ATOMIC_CENTER = exp ( ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! endif ! iAtomType = system % atomTypeIndex ( iIon ) ! LM = 0 ! do iProj = 1 , system % atoms ( iAtomType )% numProjs ! l = system % atoms ( iAtomType )% projAngMom ( iProj ) ! do m = - l , l ! LM = LM + 1 !1st index for CPROJ ! FI = 0.0_dp ! FI = sum ( system % atoms ( iAtomType )% bes_J_qr ( l ,:) * system % atoms ( iAtomType )% F (:, iProj )) ! radial part integration F contains rab ! ind = l * ( l + 1 ) + m + 1 ! index for spherical harmonics ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! VifQ_aug = ATOMIC_CENTER * Y ( ind ) * ( - II ) ** l * FI ! else if ( system % crystalType == 'SD' ) then ! VifQ_aug = ATOMIC_CENTER * conjg ( Y ( ind )) * ( II ) ** l * FI ! endif ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! system % pawK ( ibf , ibi , iPW ) = system % pawK ( ibf , ibi , iPW ) + & VifQ_aug * system % cProj ( LM + LMBASE , ibi , ISPIN ) ! else if ( system % crystalType == 'SD' ) then ! system % pawK ( ibf , ibi , iPW ) = system % pawK ( ibf , ibi , iPW ) + & VifQ_aug * conjg ( system % cProj ( LM + LMBASE , ibi , ISPIN )) ! endif ! enddo ! enddo ! ENDDO ENDDO LMBASE = LMBASE + system % atoms ( iAtomType )% lmMax ENDDO ! enddo ! !system%pawK(:,:,:) = system%pawK(:,:,:)*4.0_dp*pi/sqrt(solidDefect%omega) ! return ! end subroutine pawCorrectionK ! ! subroutine ylm ( v_in , lmax , y ) !! Returns the [spherical harmonics](http://mathworld.wolfram.com/SphericalHarmonic.html) !! for a given argument vector up to the maximum value of l given !! !! <h2>Description</h2> !!   <h3>Purpose</h3> !!        The spherical harmonics (Condon and Shortley convention) !!          Y_0&#94;0,Y_1&#94;{-1},Y_1&#94;0,Y_1&#94;1,Y_2&#94;{-2} ... Y_{l_{\\text{max}}}&#94;{\\pm l_{\\text{max}}} !!        for vector \\mathbf{V} (given in Cartesian coordinates) !!        are calculated. In the Condon Shortley convention the !!        spherical harmonics are defined as !!         Y_l&#94;m = (-1)&#94;m \\sqrt{\\frac{1}{\\pi}} P_l&#94;m(\\cos{\\theta}) !!        e&#94;{im\\phi}  !!        where  P_l&#94;m(\\cos{\\theta}) is the normalized Associated !!        Legendre function. Thus, !!                       Y_l&#94;{-m} = (-1)&#94;m (Y_l&#94;m)&#94;*  !! !!   <h3>Usage</h3> !! !! !!        DOUBLE PRECISION V(3), Y(5*5) !!        V(1) = ... !!        V(2) = ... !!        V(3) = ... !!        CALL YLM(V,4,Y) !! !!   <h3>Argument Description</h3> !!     <ul> !!          <li> !!                  `V`      - `DOUBLE PRECISION` vector, dimension 3        (input)<br/> !!                   Must be given in Cartesian coordinates. !!                   Conversion of V to polar coordinates gives the !!                   angles \\theta and \\phi necessary for the calculation !!                   of the spherical harmonics. !!          </li> !!          <li> !!                   `LMAX`   - `INTEGER` value                               (input)<br/> !!                   upper bound of l for which spherical harmonics !!                   will be calculated<br/> !!                   constraint: `LMAX >= 0` !!          </li> !!          <li> !!                   `Y`      - `COMPLEX*16` array, dimension `(LMAX+1)**2`    (output)<br/> !!                   contains the calculated spherical harmonics<br/> !!                   `Y(1)` for l=0 (m = 0)<br/> !!                   `Y(2), ..., Y(4)` for l = 1 (m = -1, 0, 1)<br/> !!                   ...<br/> !!                   `Y(LMAX*LMAX+1), ..., Y((LMAX+1)*(LMAX+1))` for l = l_{\\text{max}} !!                            (m = -l,...,l)<br/> !!                   constraint: Dimension of `Y` \\geq (l_{\\text{max}} + 1)&#94;2 (not checked) !!          </li> !!        </ul> !! !!   <h3>Used Subroutines (Directly Called)</h3> !!           none !! !!   <h3>Indirectly Called Subroutines</h3> !!           none !! !!   <h3>Input/Output (Read/Write)</h3> !!           none !! !!   <h3>Machine Dependent Program Parts</h3> !!           Type `COMPLEX*16` is used which does not conform to the !!           FORTRAN 77 standard. !!           Also the non-standard type conversion function `DCMPLX()` !!           is used which combines two double precision values into !!           one double complex value. !! !!   <h3>Method</h3> !!           The basic algorithm used to calculate the spherical !!           harmonics for vector \\mathbf{V} is as follows: !! !! !!           Y(0,0) !!           Y(1,0) !!           Y(1,1) !!           Y(1,-1) = -Y(1,1) !!           DO L = 2, LMAX !!              Y(L,L)   = f(Y(L-1,L-1)) ... Formula 1 !!              Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 !!              DO M = L-2, 0, -1 !!                 Y(L,M) = f(Y(L-1,M),Y(L-2,M)) ... Formula 2 !!                 Y(L,-M)= (-1)**M*CONJG(Y(L,M)) !!              ENDDO !!           ENDDO !! !!   <h3>Formulas</h3> !!        Starting values: !!          Y_0&#94;0 = \\sqrt{\\dfrac{1}{4\\pi}} !!          Y_1&#94;0 = \\sqrt{\\dfrac{3}{4\\pi}}\\cos\\theta !!          Y_1&#94;1 = -\\sqrt{\\dfrac{3}{8\\pi}}\\sin\\theta e&#94;{i\\phi} !!        Formula 1: !!          Y_l&#94;l = -\\sqrt{\\dfrac{2l+1}{2l}}\\sin\\theta e&#94;{i\\phi}Y_{l-1}&#94;{l-1} !!        Formula 2: !!          Y_l&#94;m = \\sqrt{\\dfrac{(2l-1)(2l+1)}{(l-m)(l+m)}}\\cos\\theta Y_{l-1}&#94;m - !!                    \\sqrt{\\dfrac{(l-1+m)(l-1-m)(2l+1)}{(2l-3)(l-m)(l+m)}} Y_{l-2}&#94;m !!        Formula 3: (not used in the algorithm because of the division !!                    by \\sin\\theta which may be zero) !!          Y_l&#94;m = -\\sqrt{\\dfrac{4(m+1)(m+1)}{(l+m+1)(l-m)}}\\dfrac{\\cos\\theta}{\\sin\\theta}e&#94;{i\\phi}Y_1&#94;{m+1} - !!                    \\sqrt{\\dfrac{(l-m-1)(l+m+2)}{(l-m)(l+m+1)}}e&#94;{-2i\\phi}Y_l&#94;{m+2} !! ! !REVISION HISTORY: !   26. April 1994                                   Version 1.2 !   Taken 8 1 98 from SRC_lapw2 to SRC_telnes !   Updated November 2004 (Kevin Jorissen) !   cosmetics March 2005 (Kevin Jorissen) ! implicit none ! !   In/Output : ! integer , intent ( in ) :: LMAX !! Spherical harmonics are calculated for !! l = 0, 1, ..., l_{\\text{max}} real ( kind = dp ), intent ( in ) :: V_in ( 3 ) !! Vector, argument of the spherical harmonics (we calculate !! Y_l&#94;m(\\mathbf{v}/|\\mathbf{v}|)) complex ( kind = dp ), intent ( out ) :: Y ( * ) !! Array containing Y_l&#94;m(\\mathbf{v}) for several l,m ! !   Local variables : real ( kind = dp ), parameter :: pi = 3.1415926535897932384626433_dp ! INTEGER :: I2L , I4L2 , INDEX , INDEX2 , L , M , MSIGN real ( kind = dp ) :: A , B , C , AB , ABC , ABMAX , ABCMAX , V ( 3 ) real ( kind = dp ) :: D4LL1C , D2L13 real ( kind = dp ) :: COSTH , SINTH , COSPH , SINPH real ( kind = dp ) :: TEMP1 , TEMP2 , TEMP3 real ( kind = dp ) :: YLLR , YLL1R , YL1L1R , YLMR real ( kind = dp ) :: YLLI , YLL1I , YL1L1I , YLMI ! ! Y(0,0) ! do INDEX = 1 , 3 V ( INDEX ) = dble ( V_in ( INDEX )) enddo YLLR = 1.0_dp / sqrt ( 4.0_dp * PI ) YLLI = 0.0_dp Y ( 1 ) = CMPLX ( YLLR , YLLI , kind = dp ) ! ! continue only if spherical harmonics for (L .GT. 0) are desired ! IF ( LMAX . LE . 0 ) GOTO 999 ! ! calculate sin(Phi), cos(Phi), sin(Theta), cos(Theta) ! Theta, Phi ... polar angles of vector V ! ABMAX = MAX ( ABS ( V ( 1 )), ABS ( V ( 2 ))) IF ( ABMAX . GT . 0.0_dp ) THEN A = V ( 1 ) / ABMAX B = V ( 2 ) / ABMAX AB = SQRT ( A * A + B * B ) COSPH = A / AB SINPH = B / AB ELSE COSPH = 1.0_dp SINPH = 0.0_dp ENDIF ABCMAX = MAX ( ABMAX , ABS ( V ( 3 ))) IF ( ABCMAX . GT . dble ( 0 )) THEN A = V ( 1 ) / ABCMAX B = V ( 2 ) / ABCMAX C = V ( 3 ) / ABCMAX AB = A * A + B * B ABC = SQRT ( AB + C * C ) COSTH = C / ABC SINTH = SQRT ( AB ) / ABC ELSE COSTH = 1.0_dp SINTH = 0.0_dp ENDIF ! ! Y(1,0) ! Y ( 3 ) = CMPLX ( sqrt ( 3.0_dp ) * YLLR * COSTH , 0.0_dp , kind = dp ) ! ! Y(1,1) ( = -DCONJG(Y(1,-1))) ! TEMP1 = - SQRT ( 1.5_dp ) * YLLR * SINTH Y ( 4 ) = CMPLX ( TEMP1 * COSPH , TEMP1 * SINPH , kind = dp ) Y ( 2 ) = - CONJG ( Y ( 4 )) ! DO L = 2 , LMAX INDEX = L * L + 1 INDEX2 = INDEX + 2 * L MSIGN = 1 - 2 * MOD ( L , 2 ) ! ! YLL = Y(L,L) = f(Y(L-1,L-1)) ... Formula 1 ! YL1L1R = DBLE ( Y ( INDEX - 1 )) YL1L1I = DIMAG ( Y ( INDEX - 1 )) TEMP1 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L )) * SINTH YLLR = TEMP1 * ( COSPH * YL1L1R - SINPH * YL1L1I ) YLLI = TEMP1 * ( COSPH * YL1L1I + SINPH * YL1L1R ) Y ( INDEX2 ) = CMPLX ( YLLR , YLLI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! ! YLL1 = Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 ! (the coefficient for Y(L-2,L-1) in Formula 2 is zero) ! TEMP2 = SQRT ( DBLE ( 2 * L + 1 )) * COSTH YLL1R = TEMP2 * YL1L1R YLL1I = TEMP2 * YL1L1I Y ( INDEX2 ) = CMPLX ( YLL1R , YLL1I , kind = dp ) Y ( INDEX ) = - cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = -dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! I4L2 = INDEX2 - 4 * L + 2 I2L = INDEX2 - 2 * L D4LL1C = COSTH * SQRT ( DBLE ( 4 * L * L - 1 )) D2L13 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L - 3 )) ! DO M = L - 2 , 0 , - 1 ! ! YLM = Y(L,M) = f(Y(L-2,M),Y(L-1,M)) ... Formula 2 ! TEMP1 = 1.0_dp / SQRT ( DBLE (( L + M ) * ( L - M ))) TEMP2 = D4LL1C * TEMP1 TEMP3 = D2L13 * SQRT ( DBLE (( L + M - 1 ) * ( L - M - 1 ))) * TEMP1 YLMR = TEMP2 * DBLE ( Y ( I2L )) + TEMP3 * DBLE ( Y ( I4L2 )) YLMI = TEMP2 * DIMAG ( Y ( I2L )) + TEMP3 * DIMAG ( Y ( I4L2 )) Y ( INDEX2 ) = CMPLX ( YLMR , YLMI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) ! MSIGN = - MSIGN INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 I4L2 = I4L2 - 1 I2L = I2L - 1 ENDDO ENDDO ! 999 RETURN END subroutine ylm ! ! subroutine bessel_j ( x , lmax , jl ) !! Generates the !! [spherical bessel function of the first kind](http://mathworld.wolfram.com/SphericalBesselFunctionoftheFirstKind.html) !! for the given argument x and all possible indices from 0 to `lmax` !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: lmax integer :: l ! real ( kind = dp ), intent ( in ) :: x real ( kind = dp ), intent ( out ) :: jl ( 0 : lmax ) ! if ( x <= 0.0_dp ) then !! * If x is less than zero, return 0 for all !!   indices but 0 which is 1 ! jl = 0.0_dp jl ( 0 ) = 1.0_dp ! return ! end if ! !> * Explicitly calculate the first 2 functions so can use !>   recursive definition for later terms jl ( 0 ) = sin ( x ) / x if ( lmax <= 0 ) return jl ( 1 ) = ( jl ( 0 ) - cos ( x )) / x if ( lmax == 1 ) return ! do l = 2 , lmax !! * Define the rest of the functions as !!   j_l = (2l-1)j_{l-1}/x - j_{l-2} ! jl ( l ) = dble ( 2 * l - 1 ) * jl ( l - 1 ) / x - jl ( l - 2 ) ! enddo ! return ! end subroutine bessel_j ! ! subroutine writeResults ( ik ) !! Write out the \\langle f|U|i\\rangle matrix and !! changes in eigenvalues for a given k point !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index ! integer :: ibi , ibf !! Loop index over bands integer :: totalNumberOfElements !! Total number of matrix elements real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time ! character ( len = 300 ) :: text !! String to hold long section header character ( len = 300 ) :: Uelements !! File name for matrix elements output character ( len = 300 ) :: ikstr !! String version of k point index ! call cpu_time ( t1 ) !! * Start a timer ! call readEigenvalues ( ik ) !! * Read eigenvalues from [[pw_export_for_tme(program)]] ! write ( iostd , '(\" Writing Ufi(:,:).\")' ) !! * Write out a header to `output` file ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! write ( Uelements , '(\"/TMEs_kptI_\",a,\"_kptF_\",a)' ) trim ( ikstr ), trim ( ikstr ) !! * Determine what the file name should be based on the k point index ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) !! * Open the matrix elements output file ! write ( 17 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(a51, ES24.15E3)'' \", ES24.15E3)' ) solidDefect % omega !! * Output cell volume to `Uelements` file ! text = \"# Total number of <f|U|i> elements, Initial States (bandI, bandF), Final States (bandI, bandF)\" write ( 17 , '(a, \" Format : ''(5i10)''\")' ) trim ( text ) ! * Output header for next section ! totalNumberOfElements = ( iBandIfinal - iBandIinit + 1 ) * ( iBandFfinal - iBandFinit + 1 ) !! * Calculate the total number of matrix elements write ( 17 , '(5i10)' ) totalNumberOfElements , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal !! * Output the total number of elements and band limits ! write ( 17 , '(\"# Final Band, Initial Band, Delta energy, Complex <f|U|i>, |<f|U|i>|&#94;2 Format : ''(2i10,4ES24.15E3)''\")' ) ! * Output header for next section ! do ibf = iBandFinit , iBandFfinal do ibi = iBandIinit , iBandIfinal !! * Loop through the bands to output the change !!   in eigenvalues, matrix element, and norm !!   squared matrix element ! write ( 17 , 1001 ) ibf , ibi , eigvI ( ibi ) - eigvF ( ibf ), Ufi ( ibf , ibi , ik ), abs ( Ufi ( ibf , ibi , ik )) ** 2 ! enddo enddo ! close ( 17 ) !! * Close the matrix elements output file ! call cpu_time ( t2 ) !! * Stop the timer ! write ( iostd , '(\" Writing Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 !! * Write to `output` file how long it took to write the matrix ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! Define format for writing matrix ! return ! end subroutine writeResults ! ! subroutine readUfis ( ik ) !! Read in matrix elements for a given k point !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ibi , ibf !! Loop index over bands integer :: totalNumberOfElements !! Total number of matrix elements integer :: iDum !! Dummy variable to ignore input integer :: iEl !! Loop index over matrix elements ! real ( kind = dp ) :: rDum !! Dummy variable to ignore input real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time ! complex ( kind = dp ) :: cUfi !! Temporarily store value of each matrix element ! character ( len = 300 ) :: Uelements !! File name for matrix elements output character ( len = 300 ) :: ikstr !! String version of k point index ! call cpu_time ( t1 ) !! * Start a timer ! write ( iostd , '(\" Reading Ufi(:,:) of k-point: \", i4)' ) ik !! * Write out a header to the `output` file ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! write ( Uelements , '(\"/TMEs_kptI_\",a,\"_kptF_\",a)' ) trim ( ikstr ), trim ( ikstr ) !! * Determine what the file name should be based on the k point index ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) !! * Open the matrix elements file ! read ( 17 , * ) read ( 17 , * ) !! * Ignore the first two lines as they are comments ! read ( 17 , '(5i10)' ) totalNumberOfElements , iDum , iDum , iDum , iDum !! * Read in the total number of matrix elements ! read ( 17 , * ) !! * Ignore the next line as it is a comment ! do iEl = 1 , totalNumberOfElements !! * Read in the indices and value for each !!   matrix element, ignoring the change in !!   eigenvalues and norm squared matrix !!   element ! read ( 17 , 1001 ) ibf , ibi , rDum , cUfi , rDum Ufi ( ibf , ibi , ik ) = cUfi ! enddo ! close ( 17 ) ! call cpu_time ( t2 ) !! * Stop timer ! write ( iostd , '(\" Reading Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 !! * Write out time to read `Ufi` to `output` file ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! Define format to read in matrix elements ! return ! end subroutine readUfis ! ! subroutine calculateVfiElements () !! @todo Figure out what the purpose of this function is. For plotting? @endtodo !! !! <h2>Walkthrough</h2> !! implicit none ! integer :: ik !! Loop index over k points integer :: ib !! Loop index over bands integer :: nOfEnergies , iE ! real ( kind = dp ) :: eMin , eMax , E , av , sd , x , epsilon_if , A , DHifMin ! real ( kind = dp ), allocatable :: sumWk (:), sAbsVfiOfE2 (:), absVfiOfE2 (:) integer , allocatable :: nKsInEbin (:) ! character ( len = 300 ) :: text ! allocate ( DE ( iBandIinit : iBandIfinal , perfectCrystal % nKpts ), absVfi2 ( iBandIinit : iBandIfinal , perfectCrystal % nKpts ) ) !! * Allocate space for `DE` and `absVfi2` ! DE (:,:) = 0.0_dp absVfi2 (:,:) = 0.0_dp !! * Initialize `DE` and `absVfi2` to double zero ! do ik = 1 , perfectCrystal % nKpts !! * For each k point !!    * Read in the initial and final eigenvalues !!    * For each band between `iBandIinit` and `iBandIfinal` !!       * Calculate \\epsilon_{if} = \\epsilon_f - \\epsilon_i !!         as defined in paper !!       * Calculate !!         |\\Delta H_{if}|&#94;2 = \\dfrac{|\\langle\\Phi_f|\\Psi_i\\rangle|&#94;2 - |\\langle\\Phi_f|\\Psi_i\\rangle|&#94;4} !!                                {(1 - 2|\\langle\\Phi_f|\\Psi_i\\rangle|&#94;2)&#94;2}\\epsilon_{if} !!         (A8 in paper) !!         @note !!         Only numerator is calculated because the denominator !!         is approximately zero, assuming |\\langle\\Phi_f|\\Psi_i\\rangle| \\ll 1 !!         @endnote !!       * Calculate `DE` = E_i - E_f = \\sqrt{\\epsilon_{if}&#94;2 + 4|\\Delta H_{if}|&#94;2} ! eigvI (:) = 0.0_dp eigvF (:) = 0.0_dp ! call readEigenvalues ( ik ) ! do ib = iBandIinit , iBandIfinal ! epsilon_if = eigvF ( iBandFinit ) - eigvI ( ib ) absVfi2 ( ib , ik ) = epsilon_if ** 2 * ( abs ( Ufi ( iBandFinit , ib , ik )) ** 2 - abs ( Ufi ( iBandFinit , ib , ik )) ** 4 ) ! DE ( ib , ik ) = sqrt ( epsilon_if ** 2 - 4.0_dp * absVfi2 ( ib , ik )) ! enddo ! enddo ! eMin = minval ( DE (:,:) ) eMax = maxval ( DE (:,:) ) !! * Find the max and min of `DE` ! nOfEnergies = int (( eMax - eMin ) / eBin ) + 1 !! * Use the min and max values to calculate how many !!   energy bins result between the energies using !!   a bin size of `eBin` ! allocate ( absVfiOfE2 ( 0 : nOfEnergies ), nKsInEbin ( 0 : nOfEnergies ), sumWk ( 0 : nOfEnergies ) ) !! * Allocate space for `absVfiOfE2`, `nKsInEbin`, and `sumWk` ! absVfiOfE2 (:) = 0.0_dp nKsInEbin (:) = 0 sumWk (:) = 0.0_dp !! * Initialize all to double zero ! do ik = 1 , perfectCrystal % nKpts ! do ib = iBandIinit , iBandIfinal !! * For each k point and band !!    * Store `absVfi2` (|\\Delta H_{if}|&#94;2) if have min `DE` !!    * Find the \"index\" of the particular `DE` !!    * If |\\Delta H_{if}|&#94;2 > 0 for given k point, add the !!      value to a cumulative sum, weighted by the k point weight `wk`, !!      and keep track of the total weight and number of k points in !!      each bin ! if ( abs ( eMin - DE ( ib , ik )) < 1.0e-3_dp ) DHifMin = absVfi2 ( ib , ik ) !! @todo Figure out why `DHifMin` is needed @endtodo !! @todo Figure out why used difference rather than `== ! iE = int (( DE ( ib , ik ) - eMin ) / eBin ) ! if ( absVfi2 ( ib , ik ) > 0.0_dp ) then !! @todo Figure out why this test is here. All of these should be positive, right? @endtodo ! absVfiOfE2 ( iE ) = absVfiOfE2 ( iE ) + perfectCrystal % wk ( ik ) * absVfi2 ( ib , ik ) !! @note I think `absVfiOfE2` is the sum of the numerators weighted by k point @endnote ! sumWk ( iE ) = sumWk ( iE ) + perfectCrystal % wk ( ik ) ! nKsInEbin ( iE ) = nKsInEbin ( iE ) + 1 ! else write ( iostd , * ) 'lalala' , absVfi2 ( ib , ik ) endif ! enddo ! enddo ! allocate ( sAbsVfiOfE2 ( 0 : nOfEnergies ) ) !! * Allocate space for `sAbsVfiOfE2` ! sAbsVfiOfE2 = 0.0_dp !! * Initialize to zero ! open ( 11 , file = trim ( VfisOutput ) // 'ofKpt' , status = 'unknown' ) !! * Open `VfisVsEofKpt` file ! write ( 11 , '(\"# |<f|V|i>|&#94;2 versus energy for all the k-points.\")' ) !! * Output file header ! write ( text , '(\"# Energy (eV) shifted by half eBin, |<f|V|i>|&#94;2 (Hartree)&#94;2,\")' ) write ( 11 , '(a, \" k-point index. Format : ''(2ES24.15E3,i10)''\")' ) trim ( text ) !! * Output section header ! do ik = 1 , perfectCrystal % nKpts ! do ib = iBandIinit , iBandIfinal !! * For each k point and band, !!    * Figure out the \"index\" for `DE` !!    * Calculate |\\Delta H_{if}|&#94;2 average over k points !!    * Store |\\Delta H_{if}|&#94;2 for a given k point and band !!    * Write out the energy shifted by half a bin, |\\Delta H_{if}|&#94;2, !!      and the k point index to `VfisVsEofKpt` !!    * Write out unshifted energy, |\\Delta H_{if}|&#94;2, and the k point !!      index to some other file?? !!    * Calculate the standard deviation of |\\Delta H_{if}|&#94;2 ! iE = int (( DE ( ib , ik ) - eMin ) / eBin ) ! av = absVfiOfE2 ( iE ) / sumWk ( iE ) ! x = absVfi2 ( ib , ik ) ! write ( 11 , '(2ES24.15E3,i10)' ) ( eMin + ( iE + 0.5_dp ) * eBin ) * HartreeToEv , x , ik write ( 12 , '(2ES24.15E3,i10)' ) DE ( ib , ik ) * HartreeToEv , absVfi2 ( ib , ik ), ik !! @todo Figure out where unit 12 file is opened and what it is @endtodo !write(11, '(2ES24.15E3,i10)') (eMin + iE*eBin + eBin/2.0_dp), x, ik ! sAbsVfiOfE2 ( iE ) = sAbsVfiOfE2 ( iE ) + perfectCrystal % wk ( ik ) * ( x - av ) ** 2 / sumWk ( iE ) ! enddo ! enddo ! close ( 11 ) !! * Close `VfisVsEofKpt` file ! open ( 63 , file = trim ( VfisOutput ), status = 'unknown' ) !! * Open `VfisVsE` file ! write ( 63 , '(\"# Averaged |<f|V|i>|&#94;2 over K-points versus energy.\")' ) !! * Output file header ! write ( 63 , '(\"#                 Cell volume : \", ES24.15E3, \" (a.u.)&#94;3,   Format : ''(ES24.15E3)''\")' ) solidDefect % omega write ( 63 , '(\"#   Minimun transition energy : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eMin write ( 63 , '(\"# |DHif|&#94;2 at minimum Tr. En. : \", ES24.15E3, \" (Hartree&#94;2),Format : ''(ES24.15E3)''\")' ) DHifMin write ( 63 , '(\"#                  Energy bin : \", ES24.15E3, \" (Hartree),  Format : ''(ES24.15E3)''\")' ) eBin !! * Output cell volumn, min `DE`, |\\Delta H_{if}|&#94;2 at min `DE`, and bin size ! write ( text , '(\"# Energy (Hartree), averaged |<f|V|i>|&#94;2 over K-points (Hartree)&#94;2,\")' ) write ( 63 , '(a, \" standard deviation (Hartree)&#94;2. Format : ''(3ES24.15E3)''\")' ) trim ( text ) !! * Output section header ! do iE = 0 , nOfEnergies !! * For each energy !!    * Calculate the average and standard deviation !!      of |\\Delta H_{if}|&#94;2 !!    * Output the energy, average, and standard deviation ! E = iE * eBin !! @todo Figure out why use `eMin + iE*eBin` rather than `DE` @endtodo ! av = 0.0_dp ! sd = 0.0_dp ! if ( nKsInEbin ( iE ) > 0 ) then ! av = absVfiOfE2 ( iE ) / sumWk ( iE ) ! sd = sqrt ( sAbsVfiOfE2 ( iE )) ! endif ! write ( 63 , '(3ES24.15E3)' ) eMin + E , av , sd ! enddo ! close ( 63 ) !! * Close `VfisVsE` file ! return ! end subroutine calculateVfiElements ! ! subroutine readEigenvalues ( ik ) !! Read in the eigenvalues output from [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ib !! Loop index over bands ! character ( len = 300 ) :: ikstr !! String version of k point index ! call int2str ( ik , ikstr ) !! * Convert k point index to string ! open ( 72 , file = trim ( perfectCrystal % exportDir ) // \"/eigenvalues.\" // trim ( ikstr )) !! * Open the perfectCrystal `eigenvalues.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) read ( 72 , * ) !! * Ignore the first two lines as they are comments ! do ib = 1 , iBandIinit - 1 !! * Ignore eigenvalues for bands that are before `iBandIinit` ! read ( 72 , * ) ! enddo ! do ib = iBandIinit , iBandIfinal !! * Read in the eigenvalues from `iBandIinit` to `iBandIfinal` ! read ( 72 , '(ES24.15E3)' ) eigvI ( ib ) ! enddo ! close ( 72 ) !! * Close the solid defect `eigenvalues.ik` file ! open ( 72 , file = trim ( solidDefect % exportDir ) // \"/eigenvalues.\" // trim ( ikstr )) !! * Open the solid defect `eigenvalues.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) read ( 72 , * ) !! * Ignore the first two lines as they are comments ! do ib = 1 , iBandFinit - 1 !! * Ignore eigenvalues for bands that are before `iBandFinit` ! read ( 72 , * ) ! enddo ! do ib = iBandFinit , iBandFfinal !! * Read in the eigenvalues from `iBandFinit` to `iBandFfinal` ! read ( 72 , '(ES24.15E3)' ) eigvF ( ib ) ! enddo ! close ( 72 ) !! * Close the solid defect `eigenvalues.ik` file ! return ! end subroutine readEigenvalues ! ! subroutine finalizeCalculation () !! Stop timer, write out total time taken, and close the output file ! implicit none ! write ( iostd , '(\"-----------------------------------------------------------------\")' ) ! call cpu_time ( tf ) write ( iostd , '(\" Total time needed:                         \", f10.2, \" secs.\")' ) tf - t0 ! close ( iostd ) ! return ! end subroutine finalizeCalculation ! !===================================================================================================== ! Utility functions that simplify the code and may be used multiple times ! !--------------------------------------------------------------------------------------------------------------------------------- function wasRead ( inputVal , variableName , usage , abortExecution ) !! Determine if an input variable still has the default value. !! If it does, output an error message and possibly set the program !! to abort. Not all variables would cause the program to abort, !! so this program assumes that if you pass in the logical `abortExecution` !! then the variable is required and causes the program to abort !! if missing. !! !! I could not find a clean way to allow this function to receive !! different types of variables (integer, real, character, etc.), so !! I made the argument be an integer so that each type could be sent !! in a different way. Each case is set up so that the value is tested to !! see if it is less than zero to determine if the variable still has !! its default value !! !! * For strings, the default value is `''`, so pass in !! `LEN(trim(variable))-1` as this should be less than zero if !! the string still has the default value and greater than or equal !! to zero otherwise !! * For integers the default values are less than zero, so just pass as is !! * Real variables also have a negative default value, so just pass the !! value cast from real to integer !! implicit none ! integer , intent ( in ) :: inputVal !! Value to compare with 0 to see if a variable has been read; ! character ( len =* ), intent ( in ) :: variableName !! Name of the variable used in output message character ( len =* ), intent ( in ) :: usage !! Example of how the variable can be used ! logical , optional , intent ( inout ) :: abortExecution !! Optional logical for if the program should be aborted logical :: wasRead !! Whether or not the input variable was read from the input file; !! this is the return value ! !! <h2>Walkthrough</h2> !! wasRead = . true . !! * Default return value is true ! if ( inputVal < 0 ) then !! * If the input variable still has the default value !!    * output an error message !!    * set the program to abort if that variable was sent in !!    * set the return value to false to indicate that the !!      variable wasn't read ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"\", a, \"\"\" is not defined!\")' ) variableName write ( iostd , '(\" usage : \", a)' ) usage if ( present ( abortExecution )) then ! write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! wasRead = . false . ! endif ! return ! end function wasRead ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine int2str ( integ , string ) !! Write a given integer to a string, using only as many digits as needed ! implicit none integer :: integ character ( len = 300 ) :: string ! if ( integ < 10 ) then write ( string , '(i1)' ) integ else if ( integ < 100 ) then write ( string , '(i2)' ) integ else if ( integ < 1000 ) then write ( string , '(i3)' ) integ else if ( integ < 10000 ) then write ( string , '(i4)' ) integ endif ! string = trim ( string ) ! return ! end subroutine int2str ! end module TMEModule","tags":"","loc":"sourcefile/tme_module_v28.f90.html","title":"TME_Module_v28.f90 – Carrier Cross Sections"},{"text":"Contents Programs MjME Source Code Mj_Main.f90 Source Code program MjME !! Calculate some of the main variables in equations !! 42 and 43, calculate new displacements of atoms, !! and generate new QE input based on the new positions !! !! <h2>Walkthrough</h2> !! use MjModule use generalComputations !! Include the `generalComputations` module !! for call to `computeGeneralizedDisplacements` !! and `computeVariables` ! implicit none ! call cpu_time ( ti ) !! @todo Make sure that there is an end timer @endtodo ! call readInputs () !! * Initialize variables, read input, and check that !!   all required variables were read and have values !!   that make sense ! allocate ( genCoord ( nModes ) ) ! call computeGeneralizedDisplacements ( nOfqPoints , nModes , genCoord , nAtoms , atomM , phonD , atomD ) !! * Calculate \\delta q_j ! deallocate ( atomM , atomD ) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : modeF + 1 , nModes ) ) ! call computeVariables ( x , Sj , coth , wby2kT , phonF , genCoord , kT , s2L , nModes , modeF , & besOrderNofModeM ) !! * Compute main parts of equations 42 and 43 in paper !!   to make whole formula more manageable ! deallocate ( genCoord ) ! call displaceAtoms () !! * Calculate new positions of atoms for each mode !!   based on `maxDisplacement` and `phonD` ! !> * If a base QE input was read, then export the new QE !>   input files with the new postions !> * Otherwise, just write out the positions if ( readQEInput ) then ! call exportQEInput () ! else ! call writeNewAtomicPositions () ! endif ! end program MjME","tags":"","loc":"sourcefile/mj_main.f90.html","title":"Mj_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules MjModule Source Code Mj_Module_v1.f90 Source Code module MjModule ! use constants ! implicit none ! integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: un = 3 ! character ( len = 6 ), parameter :: output = 'status' ! ! integer :: ios integer :: modeF integer :: modeI integer :: nAtoms !! Number of atoms integer :: nModes !! Number of phonon modes integer :: nOfqPoints integer :: qPoint !! Read in from input file, but no default value set !! @todo Make sure default value is set for `qPoint` @endtodo ! real ( kind = dp ) :: kT real ( kind = dp ) :: maxDisplacement real ( kind = dp ) :: t1 real ( kind = dp ) :: t2 real ( kind = dp ) :: temperature real ( kind = dp ) :: tf real ( kind = dp ) :: ti ! character ( len = 256 ) :: equilibriumAtomicPositions character ( len = 256 ) :: newAtomicPositions character ( len = 256 ) :: phononsInput character ( len = 256 ) :: QEInput ! logical :: file_exists logical :: readQEInput ! ! integer , allocatable :: s2L (:) ! real ( kind = dp ), allocatable :: atomD (:,:) real ( kind = dp ), allocatable :: atomM (:) real ( kind = dp ), allocatable :: atomPosition (:,:) real ( kind = dp ), allocatable :: besOrderNofModeM (:,:) real ( kind = dp ), allocatable :: coth (:) real ( kind = dp ), allocatable :: genCoord (:) real ( kind = dp ), allocatable :: newAtomicPosition (:,:) real ( kind = dp ), allocatable :: phonD (:,:,:,:) real ( kind = dp ), allocatable :: phonF (:) real ( kind = dp ), allocatable :: phonQ (:,:) real ( kind = dp ), allocatable :: Sj (:) real ( kind = dp ), allocatable :: wby2kT (:) real ( kind = dp ), allocatable :: x (:) ! character ( len = 2 ), allocatable :: elements (:) ! namelist / MjInput / QEInput , phononsInput , temperature , equilibriumAtomicPositions , modeI , modeF , qPoint , maxDisplacement ! ! contains ! ! subroutine readInputs () !! Read input parameters and read phonon output !! !! <h2>Walkthrough</h2> !! use readInputFiles ! implicit none ! !> * Check if file output exists; if it does, delete it inquire ( file = output , exist = file_exists ) ! if ( file_exists ) then ! open ( unit = 11 , file = output , status = \"old\" ) ! close ( unit = 11 , status = \"delete\" ) ! endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! call initialize () !! * Set default values of input parameters ! READ ( 5 , MjInput , iostat = ios ) !! * Read input parameters ! call checkAndUpdateInput () !! * Check if input parameters were updated !!   and do some basic checks ! call readPhonons ( phononsInput , nOfqPoints , nAtoms , nModes , atomD , atomM , phonQ , phonF , phonD ) !! * Read the phonons output from QE or VASP ! call readAtomicPositions () !! * Read the equilibrium atomic positions ! return ! end subroutine readInputs ! ! subroutine initialize () !! Set default values for input parameters ! implicit none ! QEInput = '' phononsInput = '' equilibriumAtomicPositions = '' temperature = - 1.0_dp maxDisplacement = - 1.0_dp modeI = - 1 modeF = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () !! Check that the input variables don't still have their default !! values. The program will abort here if: !! * `equilibriumAtomicPositions` is not defined !! * `phononsInput` is not defined !! * `temperature` is not defined !! * `modeI` or `modeF` is not defined !! * `modeF < modeI` !! * `maxDisplacement` is not defined ! implicit none ! logical :: abortExecution = . false . ! write ( iostd , * ) ! if ( equilibriumAtomicPositions == '' ) then write ( iostd , '(\" equilibriumAtomicPositions is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Equilibrium Atomic Positions input : \", a)' ) trim ( equilibriumAtomicPositions ) endif ! if ( phononsInput == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( PhononsInput ) endif ! if ( QEInput == '' ) then write ( iostd , '(\" QEInput is not defined!\")' ) readQEInput = . false . else readQEInput = . true . write ( iostd , '(\" Quantum Espresso input : \", a)' ) trim ( QEInput ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Temperature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324d-5 * eVToHartree endif ! if ( modeI < 0 ) then write ( iostd , '(\" Variable modeI has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Initial mode : \", i5)' ) modeI endif ! if ( modeF < 0 ) then write ( iostd , '(\" Variable modeF has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Final mode : \", i5)' ) modeF endif ! if ( modeF < modeI ) then write ( iostd , '(\" Final mode is set smaller than initial one!\")' ) abortExecution = . true . endif ! if ( maxDisplacement < 0 ) then write ( iostd , '(\" Variable maxDisplacement has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum atomic displacement in each direction : \", f15.10)' ) maxDisplacement endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! return ! end subroutine checkAndUpdateInput ! subroutine readAtomicPositions () !! Read in the element and equilibrium position for !! each atom !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer :: iAtom !! Loop index over atoms ! open ( 1 , file = trim ( equilibriumAtomicPositions ), status = \"old\" ) !! * Open the `equilibriumAtomicPositions` file ! allocate ( elements ( nAtoms ), atomPosition ( 3 , nAtoms ) ) ! atomPosition (:,:) = 0.0_dp ! do iAtom = 1 , nAtoms !! * For each atom, read in the element and equilibrium position ! read ( 1 , * ) elements ( iAtom ), atomPosition ( 1 , iAtom ), atomPosition ( 2 , iAtom ), atomPosition ( 3 , iAtom ) ! enddo ! close ( 1 ) !! * Close the `equilibriumAtomicPositions` file ! return ! end subroutine readAtomicPositions ! ! subroutine displaceAtoms () !! For each mode, generate random displacements for the atoms !! based on the parameters `maxDisplacement` and `phonD` !! !! <h2>Walkthrough</h2> !! implicit none ! integer :: istat , iAtom , iMode , iRand real ( kind = dp ) :: ran , norm ! allocate ( newAtomicPosition ( 3 , nAtoms ) ) ! open ( unit = 12 , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! write ( iostd , * ) ! do iMode = modeI , modeF !! * For each mode, generate random displacements for the atoms !!   based on the parameters `maxDisplacement` and `phonD` ! write ( iostd , '(\" Calculating new atomic positions for mode :\", i10)' ) s2L ( iMode ) !! @todo Figure out if expect `modeI` and `modeF` to represent index of magnitude of argument `x` @endtodo ! do iAtom = 1 , nAtoms ! norm = sqrt ( sum ( phonD (:, iAtom , s2L ( iMode ), qPoint ) ** 2 )) ! read ( 12 ) iRand ran = mod ( abs ( iRand ), 10000000 ) / 1.0e7_dp ! newAtomicPosition (:, iAtom ) = atomPosition (:, iAtom ) + maxDisplacement * ran * phonD (:, iAtom , s2L ( iMode ), qPoint ) / norm ! enddo ! enddo ! close ( 12 ) ! end subroutine displaceAtoms ! ! subroutine writeNewAtomicPositions () !! Write `newAtomicPosition`s for each mode ! use miscUtilities ! implicit none ! integer :: iAtom , iMode ! character ( len = 300 ) :: s2LStr ! do iMode = modeI , modeF ! write ( iostd , '(\" Writing new atomic positions for mode :\", i10)' ) s2L ( iMode ) ! if ( s2L ( iMode ) < 10000 ) then call int2str ( s2L ( iMode ), s2LStr ) ! write ( newAtomicPositions , '(\"newPositionForMode\", a)' ) trim ( s2LStr ) ! else ! newAtomicPositions = 'newPositions' ! endif ! open ( 21 , file = trim ( newAtomicPositions ), status = 'unknown' ) ! do iAtom = 1 , nAtoms ! !write(6, '(i4, f15.12, 3f15.5, \" | \", 3f15.5)') iAtom, maxDisplacement*ran, & !          atomPosition(:,iAtom), atomPosition(:,iAtom) + maxDisplacement*ran*phonD(:,iAtom,s2L(iMode),qPoint)/norm write ( 21 , * ) elements ( iAtom ), newAtomicPosition (:, iAtom ) enddo ! close ( 21 ) ! enddo ! end subroutine writeNewAtomicPositions ! ! subroutine exportQEInput () !! Create QE input files for all different modes !! by copying all of the `QEInput` except the !! `newAtomicPosition`s for each mode !! !! <h2>Walkthrough</h2> !! use miscUtilities ! implicit none ! integer :: iAtom !! Loop index over atoms integer :: iMode !! Loop index over phonon modes character ( len = 300 ) :: line , fn , modeFolder , mkDir , s2LStr ! do iMode = modeI , modeF !! * For each mode between `modeI` and `modeF` !!   * If the folder for this mode doesn't already !!     exist, make it !!   * Copy the `QEInput` file into the new folder, !!     changing the positions to be the `newAtomicPosition` ! call int2str ( s2L ( iMode ), s2LStr ) ! write ( modeFolder , '(\"mode_\", a)' ) trim ( s2LStr ) ! inquire ( file = trim ( modeFolder ), exist = file_exists ) if ( . not . file_exists ) then ! write ( mkDir , '(\"mkdir -p \", a)' ) trim ( modeFolder ) call system ( mkDir ) ! endif ! fn = trim ( QEInput ) fn = fn ( INDEX ( QEInput , '/' , BACK = . TRUE .): INDEX ( QEInput , '.in' ) - 1 ) ! write ( iostd , '(\" Writing new QE input file for mode :\", i10)' ) s2L ( iMode ) ! write ( fn , '(a, \"_mode\", a, \".in\")' ) trim ( fn ), trim ( s2LStr ) ! fn = trim ( modeFolder ) // \"/\" // trim ( fn ) ! open ( 2 , file = trim ( fn ), status = \"unknown\" ) ! open ( 1 , file = trim ( QEInput ), status = \"old\" ) ! do !! @todo Make this loop more clear @endtodo ! read ( 1 , '(a)' , END = 100 ) line ! write ( 2 , '(a)' ) trim ( line ) ! if ( INDEX ( line , 'ATOMIC_POSITIONS' ) /= 0 ) then ! do iAtom = 1 , nAtoms ! read ( 1 , '(a)' ) line ! write ( 2 , * ) elements ( iAtom ), newAtomicPosition (:, iAtom ) ! enddo ! endif ! enddo 100 continue ! close ( 1 ) close ( 2 ) ! enddo ! end subroutine exportQEInput !  subroutine readMjs() !    ! !    implicit none !    ! !    integer :: i, iE0, iE, dummyI, nEMjs !    real(kind = dp) :: dummyD, E, MjsOfE, MjOfE0 !    character :: dummyC !    ! !    open(1, file=trim(MjsInput), status=\"old\") !    ! !    read(1, *) dummyC, nEMjs !    ! !    allocate ( Mjs(-nEnergies:nEnergies) ) !    ! !    Mjs = 1.0_dp !    ! !!    read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, MjsOfE0, dummyD !!    ! !!    E = E*eVToHartree !!    iE = int(E/deltaE) + 1 !!    ! !!    do i = 1, nEMjs - 1 !!      ! !!      iE0 = iE !!      read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, MjsOfE, dummyD !!      E = E*eVToHartree !!      iE = int(E/deltaE) + 1 !!      Mjs(iE0:iE) = MjsOfE0 !!      MjsOfE0 = MjsOfE !!      ! !!    enddo !!    ! !!    close(1) !!    ! !!    !do iE = -nEnergies, nEnergies !!    !  write(44,*) real(iE, dp)*deltaE*HartreeToEv, Mjs(iE) !!    !enddo !!    ! !    return !    ! !  end subroutine readMjs ! ! !===================================================================================================== ! Utility functions that simplify the code and may be used multiple times ! !--------------------------------------------------------------------------------------------------------------------------------- function wasRead ( inputVal , variableName , usage , abortExecution ) !! Determine if an input variable still has the default value. !! If it does, output an error message and possibly set the program !! to abort. Not all variables would cause the program to abort, !! so this program assumes that if you pass in the logical `abortExecution` !! then the variable is required and causes the program to abort !! if missing. !! !! I could not find a clean way to allow this function to receive !! different types of variables (integer, real, character, etc.), so !! I made the argument be an integer so that each type could be sent !! in a different way. Each case is set up so that the value is tested to !! see if it is less than zero to determine if the variable still has !! its default value !! !! * For strings, the default value is `''`, so pass in !! `LEN(trim(variable))-1` as this should be less than zero if !! the string still has the default value and greater than or equal !! to zero otherwise !! * For integers the default values are less than zero, so just pass as is !! * Real variables also have a negative default value, so just pass the !! value cast from real to integer !! implicit none ! integer , intent ( in ) :: inputVal !! Value to compare with 0 to see if a variable has been read; ! character ( len =* ), intent ( in ) :: variableName !! Name of the variable used in output message character ( len =* ), intent ( in ) :: usage !! Example of how the variable can be used ! logical , optional , intent ( inout ) :: abortExecution !! Optional logical for if the program should be aborted logical :: wasRead !! Whether or not the input variable was read from the input file; !! this is the return value ! !! <h2>Walkthrough</h2> !! wasRead = . true . !! * Default return value is true ! if ( inputVal < 0 ) then !! * If the input variable still has the default value !!    * output an error message !!    * set the program to abort if that variable was sent in !!    * set the return value to false to indicate that the !!      variable wasn't read ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"\", a, \"\"\" is not defined!\")' ) variableName write ( iostd , '(\" usage : \", a)' ) usage if ( present ( abortExecution )) then ! write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! wasRead = . false . ! endif ! return ! end function wasRead ! end module MjModule","tags":"","loc":"sourcefile/mj_module_v1.f90.html","title":"Mj_Module_v1.f90 – Carrier Cross Sections"},{"text":"Contents Programs lineShapeFunction Source Code LSF_zeroth_Main.f90 Source Code program lineShapeFunction ! use mpi use lsf use generalComputations !! Include the `generalComputations` module !! for call to `computeGeneralizedDisplacements` !! and `computeVariables` ! implicit none ! integer :: lll , iPhonon ! character ( len = 2 ) :: charI ! call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) !! * Initialize mpi and set up processes ! if ( myid == root ) then !! * If root process !!    * Start a timer !!    * Read input, check all variables needed and initialize the calculation !!    * Calculate \\delta q_j !!    * Compute main parts of equations 42 and 43 in paper !!      to make whole formula more manageable !!    * Initialize or read LSF from file ! call cpu_time ( ti ) ! Start a timer ! call readInputs () ! Read input, check all variables needed and initialize the calculation ! allocate ( genCoord ( nModes ) ) ! call computeGeneralizedDisplacements ( nOfqPoints , nModes , genCoord , nAtoms , atomM , phonD , atomD ) ! Calculate \\delta q_j ! deallocate ( atomM , phonD , atomD ) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) ! call computeVariables ( x , Sj , coth , wby2kT , phonF , genCoord , kT , s2L , nModes , maximumNumberOfPhonons , & besOrderNofModeM ) ! Compute main parts of equations 42 and 43 in paper ! to make whole formula more manageable ! deallocate ( genCoord ) ! call initializeLSF () ! Initialize or read LSF from file ! endif ! !----------------------------------------------------------------------------------------------------------- !> * Allocate space for variables and broadcast to all processes so can move forward !>   with calculation call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then ! allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !allocate( Vfis(-nEnergies:nEnergies) ) ! endif ! call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) !call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( 3 <= maximumNumberOfPhonons ) then ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! end if ! !----------------------------------------------------------------------------------------------------------- ! do iPhonon = minimumNumberOfPhonons , MIN0 ( maximumNumberOfPhonons , 4 ) !! * For each possible phonon number less than 5 !!    * Calculate the line shape function explicitly by !!      summing contributions from using different numbers of bands !!    * For more than 2 phonons, split up the possible configurations !!      among the processes for speed then sum !!    * Calculate minimum energy bin size such that no bin is empty !!    * Output resulting line shape function !! @todo Redo the loop for less than 5 phonons to be more clear and streamlined @endtodo ! if ( ( ( iPhonon == 1 . or . iPhonon == 2 ) . and . myid == root ) . or . iPhonon > 2 ) then if ( iPhonon > 2 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! endif ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then call cpu_time ( t1 ) ! call lsfMbyOneBand ( iPhonon ) ! if ( iPhonon > 1 ) then ! call lsfMbyTwoBands ( iPhonon ) ! else if ( iPhonon > 2 ) then ! call parallelIsFsBy3 () ! endif ! endif ! if ( iPhonon > 2 ) then ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( iPhonon ) ! endif ! if ( iPhonon > 3 ) then ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfDeterministicFourPhononsByFourBands () ! endif ! if ( iPhonon > 2 ) then ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) !! @todo Change this to have `size(iEbinsByBands)` @endtodo CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! endif !! @todo Add `else iEbinsByPhonons = iEbinsByBands` to remove if below @endtodo !! @todo Maybe change variable names to be clearer @endtodo ! if ( myid == root ) then ! call cpu_time ( t2 ) ! write ( iostd , '(i2, \" modes, time needed :,\" , f10.2, \" secs.\")' ) iPhonon , t2 - t1 flush ( iostd ) ! if ( iPhonon > 2 ) then ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByPhonons , de ) !! @todo Figure out how getting `de` is \"calculating DOS\" and if not where DOS is @endtodo !! @todo Figure out why DOS isn't in sum as in formula @endtodo ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! Add so that can continue from file if needed ! else ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( iPhonon , iEbinsByBands , de ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! Add so that can continue from file if needed ! endif ! write ( iostd , * ) 'DE' , iPhonon , de flush ( iostd ) ! charI = '' write ( charI , \"(i2.2)\" ) iPhonon ! open ( 1 , file = 'lsfVsEwithUpTo' // trim ( charI ) // 'phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , iPhonon ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! if ( iPhonon < 3 ) then ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de ! else ! write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de ! endif ! enddo ! close ( 1 ) ! endif ! endif ! enddo ! if ( maximumNumberOfPhonons >= 5 ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then ! if ( istat /= 0 ) then ! write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' ! else ! write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' ! endif ! flush ( iostd ) ! endif ! if ( istat /= 0 ) close ( un ) ! ! allocate ( lsfbyPhononsPerProc(-nEnergies:nEnergies) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons !! * For each possible phonon number greater than or equal to 5 !!    * Calculate the contribution to the line shape function of splitting !!      up the phonons in 1-3 bands explicitly, splitting up the possible !!      configurations among the processes for speed then summing all !!      contributions ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! If I'm root, figure out how the Monte Carlo ! steps should be split up among the processes !! @todo Move the behavior of splitting up Monte Carlo steps to a subroutine @endtodo ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC ! do i = numprocs - 1 , 1 , - 1 ! iModeIs ( i ) = i * iMint + 1 ! if ( iMmod > 0 ) then ! iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 ! endif ! iModeFs ( i - 1 ) = iModeIs ( i ) - 1 ! enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m !! @todo Move this to a subroutine @endtodo ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! !> @todo Replace this with `binomialCoefficient(kPhonons-1, kPhonons-nBands)` @endtodo times = 1.0_dp mi = l - 1 ! do ni = m - 1 , m - l + 1 , - 1 ! times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 ! enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = nModes ! do iMode = 2 , l ! weight = weight * ( nModes - iMode + 1 ) / iMode ! enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m ! elseif ( m < 100 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m ! elseif ( m < 1000 ) then ! write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m ! else ! write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m ! endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de ! enddo ! close ( 5000 ) ! endif ! enddo ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then !! * Write out the configuration with the most phonons ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! deallocate ( lsfVsEbyBands , iEbinsByBands , pj ) ! if ( 3 <= maximumNumberOfPhonons ) then ! deallocate ( iModeIs , iModeFs ) ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! end if ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"sourcefile/lsf_zeroth_main.f90.html","title":"LSF_zeroth_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules lsf Source Code LSF_zeroth_Module_v35.f90 Source Code module lsf ! use constants ! implicit none ! integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: un = 3 integer , parameter :: root = 0 ! character ( len = 6 ), parameter :: output = 'status' ! ! integer ( kind = int32 ) :: ierr integer ( kind = int32 ) :: ios integer ( kind = int32 ) :: istat integer ( kind = int32 ) :: myid integer ( kind = int32 ) :: numprocs integer :: i integer :: iE integer :: iMint integer :: iMmod integer :: iMode integer :: l integer :: m integer :: maximumNumberOfPhonons integer :: mi integer :: minimumNumberOfPhonons integer :: nAtoms integer :: nEnergies integer :: ni integer :: nMC integer :: nModes integer :: nOfqPoints integer :: nProcMax integer :: printsteps ! real ( kind = dp ) :: de real ( kind = dp ) :: deltaE real ( kind = dp ) :: E real ( kind = dp ) :: kT real ( kind = dp ) :: maxEnergy real ( kind = dp ) :: t1 real ( kind = dp ) :: t2 real ( kind = dp ) :: tf real ( kind = dp ) :: ti real ( kind = dp ) :: temperature real ( kind = dp ) :: times !real(kind = dp) :: vg !real(kind = dp) :: volume real ( kind = dp ) :: weight ! character ( len = 256 ) :: continueLSFfromFile !character(len = 256) :: crossSectionOutput character ( len = 256 ) :: fn character ( len = 256 ) :: phononsInputFormat character ( len = 256 ) :: phononsInput !character(len = 256) :: VfisInput ! logical :: file_exists ! ! integer , allocatable :: iEbinsByBands (:) integer , allocatable :: iEbinsByPhonons (:) integer , allocatable :: iModeFs (:) integer , allocatable :: iModeIs (:) integer , allocatable :: pj (:) integer , allocatable :: pj0s (:,:) integer , allocatable :: pms (:,:) integer , allocatable :: s2L (:) ! real ( kind = dp ), allocatable :: atomD (:,:) real ( kind = dp ), allocatable :: atomM (:) real ( kind = dp ), allocatable :: besOrderNofModeM (:,:) real ( kind = dp ), allocatable :: coth (:) real ( kind = dp ), allocatable :: genCoord (:) real ( kind = dp ), allocatable :: lsfbyPhononsPerProc (:) real ( kind = dp ), allocatable :: lsfVsE (:) real ( kind = dp ), allocatable :: lsfVsEbyBands (:) real ( kind = dp ), allocatable :: lsfVsEbyPhonons (:) real ( kind = dp ), allocatable :: phonD (:,:,:,:) real ( kind = dp ), allocatable :: phonF (:) real ( kind = dp ), allocatable :: phonQ (:,:) real ( kind = dp ), allocatable :: Sj (:) !real(kind = dp), allocatable :: Vfis(:) real ( kind = dp ), allocatable :: wby2kT (:) real ( kind = dp ), allocatable :: x (:) ! !  namelist /elphscat/ VfisInput, PhononsInput, temperature, maxEnergy, continueLSFfromFile, volume, & namelist / lsfInput / phononsInput , phononsInputFormat , temperature , & continueLSFfromFile , maximumNumberOfPhonons , nMC ! ! contains ! ! subroutine readInputs () !! Read input parameters and read phonon output !! !! <h2>Walkthrough</h2> !! use readInputFiles !! * Include `readInputFiles` module for reading !! phonons input ! implicit none ! !> * Check if output file exists; if it does delete it inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! call initialize () !! * Set default values of input parameters ! READ ( 5 , lsfInput , iostat = ios ) !! * Read input parameters ! call checkAndUpdateInput () !! * Check if input parameters were updated and do some basic checks ! !> * Read the phonons output from QE or VASP if ( trim ( phononsInputFormat ) == 'VASP' ) then ! call readPhonons ( phononsInput , nOfqPoints , nAtoms , nModes , atomD , atomM , phonQ , phonF , phonD ) ! else if ( trim ( phononsInputFormat ) == 'QE' ) then ! call readPhononsQE () ! else ! write ( iostd , '(\" Unknown phonons input format : \", (a) )' ) trim ( phononsInputFormat ) write ( iostd , '(\" Phonons input format implemened are : ''VASP'' and ''QE''\")' ) write ( iostd , '(\" Program stops!\")' ) stop ! endif ! !    call readVfis() ! return ! end subroutine readInputs ! ! subroutine initializeLSF () !! Allocate and initialize `lsfVsE` and !! `minimumNumberOfPhonons`. If a file was !! given to continue from, read in both !! variables from the file. ! implicit none ! real ( kind = dp ) :: dummyD integer :: dummyI character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! allocate ( lsfVsE ( - nEnergies : nEnergies ) ) ! minimumNumberOfPhonons = 1 lsfVsE (:) = 0.0_dp ! if ( trim ( continueLSFfromFile ) /= '' ) then ! inquire ( file = trim ( continueLSFfromFile ), exist = file_exists ) if ( file_exists ) then ! open ( unit = 11 , file = trim ( continueLSFfromFile ), status = \"old\" ) ! read ( 11 , '(a1, i10, a9, i5, a8)' ) dummyC1 , dummyI , dummyC9 , minimumNumberOfPhonons , dummyC8 ! minimumNumberOfPhonons = minimumNumberOfPhonons + 1 !! @todo Figure out why increase `minimumNumberOfPhonons` by 1 ! write ( iostd , '(\" Minimum number of phonons : \", i5)' ) minimumNumberOfPhonons ! do iE = - nEnergies , nEnergies ! read ( 11 , * ) dummyD , lsfVsE ( iE ) ! enddo ! close ( 11 ) ! endif ! endif ! return ! end subroutine initializeLSF ! ! subroutine initialize () !! Set default values for input parameters ! implicit none ! !VfisInput = '' phononsInput = '' phononsInputFormat = '' temperature = - 1.0_dp minimumNumberOfPhonons = 1 maximumNumberOfPhonons = - 1 nMC = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () !! Check that the input variables don't still have their default !! values. The program will abort here if: !!   * `phononsInput` is undefined !!   * `phononsInputFormat` is undefined !!   * `temperature` is undefined !!   * `maximumNumberOfPhonons` is undefined !!   * number of Monte Carlo steps (`nMc`) is not !!     set and `maximumNumberOfPhonons` is greater !!     than 4 !! !! This subroutine also sets `maxEnergy` and `nEnergies` !! and calculates `kT` and `deltaE`. ! implicit none ! logical :: abortExecution = . false . ! if ( trim ( phononsInput ) == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( phononsInput ) endif ! if ( trim ( phononsInputFormat ) == '' ) then write ( iostd , '(\" PhononsInputFormat is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input format : \", a)' ) trim ( phononsInputFormat ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Tempetature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324e-5_dp * eVToHartree endif ! if ( maximumNumberOfPhonons < 0 ) then write ( iostd , '(\" Variable maximumNumberOfPhonons has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum number of phonons : \", i5)' ) maximumNumberOfPhonons endif ! if ( nMC < 0 ) then if ( maximumNumberOfPhonons > 4 ) then write ( iostd , '(\" For calculations with configurations with more than 4 phonon modes \")' ) write ( iostd , '(\" the number of Monte Carlo steps ''nMC'' must be set.\")' ) abortExecution = . true . endif else if ( maximumNumberOfPhonons > 4 ) then write ( iostd , '(\" Number of Monte Carlo steps : \", i15)' ) nMC else write ( iostd , '(\" The number of Monte Carlo steps ''nMC'' is set to : \", i15, \" but\")' ) nMC write ( iostd , '(\" will not be used since the Monte Carlo sheme is used for calculations\")' ) write ( iostd , '(\" with configurations with more that 4 phonon modes.\")' ) endif endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" * Please check the input. * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! maxEnergy = 1 0.0_dp * eVToHartree ! nEnergies = 5040 ! 2520 ! 10080 deltaE = maxEnergy / real ( nEnergies , dp ) ! write ( iostd , '(\" The resolution in energy is :\", f10.2, \" meV.\")' ) deltaE * 100 0.0_dp * HartreeToEv ! flush ( iostd ) ! return ! end subroutine checkAndUpdateInput ! ! subroutine readPhononsQE () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! !write(6,*) trim(phononsInput) open ( 1 , file = trim ( phononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms , nModes ! write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes : \", i5)' ) nModes flush ( iostd ) ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp !The unit is in Bohr do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC read ( 1 , * ) ! do iMode = 1 , nModes ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , freqInTHz phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyC , phonD ( 1 , iAtom , iMode , iq ), dummyD , phonD ( 2 , iAtom , iMode , iq ), dummyD , phonD ( 3 , iAtom , iMode , iq ), dummyC write ( 6 , * ) phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhononsQE ! ! !  subroutine readVfis() !! @todo Remove all of these comments @endtodo !    ! !    implicit none !    ! !    integer :: i, iE0, iE, dummyI, nEVfi !    real(kind = dp) :: dummyD, E, VfiOfE, VfiOfE0 !    character :: dummyC !    ! !    open(1, file=trim(VfisInput), status=\"old\") !    ! !    read(1, *) dummyC, nEVfi !    ! !    allocate ( Vfis(-nEnergies:nEnergies) ) !    ! !    Vfis = 0.0_dp !    ! !    read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, VfiOfE0, dummyD !    ! !    E = E*eVToHartree !    iE = int(E/deltaE) + 1 !    ! !    do i = 1, nEVfi - 1 !      ! !      iE0 = iE !      read(1, '(d22.14,i5,4d22.14)' ) E, dummyI, dummyD, VfiOfE, dummyD !      E = E*eVToHartree !      iE = int(E/deltaE) + 1 !      Vfis(iE0:iE) = VfiOfE0 !      VfiOfE0 = VfiOfE !      ! !    enddo !    ! !    close(1) !    ! !    !do iE = -nEnergies, nEnergies !    !  write(44,*) real(iE, dp)*deltaE*HartreeToEv, Vfis(iE) !    !enddo !    ! !    return @endtodo !    ! !  end subroutine readVfis ! ! subroutine lsfDeterministicFourPhononsByFourBands () !! Explicitly calculate the line shape function for !! four phonons in four bands ! implicit none ! integer :: ic integer :: iMode1 , iMode2 , iMode3 , iMode4 integer :: pm1 , pm2 , pm3 , pm4 ! real ( kind = dp ) :: t1 , t2 ! if ( myid == root ) then write ( iostd , * ) 'Four modes' flush ( iostd ) endif ! call cpu_time ( t1 ) ! ic = 0 do iMode1 = iModeIs ( myid ), iModeFs ( myid ) !! @todo Figure out if `iModeFs(myid)` has a max of `nModes-3` or `nModes-nBands+1` do iMode2 = iMode1 + 1 , nModes - 2 !write(iostd, '(\"myID \", i15, \" iMode1 = \", i5, \" / \", i5, \" in each proc. iMode2 =\", i5, \" / \", i5)') myid, & !           iMode1-iModeIs(myid)+1, iModeFs(myid)-iModeIs(myid)+1,iMode2 - iMode1+1 + 1, nModes - 2 - iMode1+1 + 1 do iMode3 = iMode2 + 1 , nModes - 1 do iMode4 = iMode3 + 1 , nModes !! Pick four bands, ! do pm1 = - 1 , 1 , 2 do pm2 = - 1 , 1 , 2 do pm3 = - 1 , 1 , 2 do pm4 = - 1 , 1 , 2 !! pick a combination of \\pm1 in each band, ! pj (:) = 0 pj ( iMode1 ) = pm1 pj ( iMode2 ) = pm2 pj ( iMode3 ) = pm3 pj ( iMode4 ) = pm4 ! call lsfOfConfigurationPj () !! calculate the lsf of the configuration, and repeat !! until all possible combinations have been done ! ic = ic + 1 !! @todo Figure out what the purpose of `ic` is @endtodo ! enddo enddo enddo enddo ! enddo enddo enddo enddo ! call cpu_time ( t2 ) ! return ! end subroutine lsfDeterministicFourPhononsByFourBands ! ! subroutine lsfOfConfigurationPj () !! Calculate a portion of the line shape function F !! for a given set \\{p_j\\} !! !! <h2>Background</h2> !! !! The line shape function is defined in the paper as !! F = \\dfrac{1}{\\Omega_k}\\sum_{p_j}\\left[\\left(\\prod_{j=1}&#94;{M}F_j\\right) !!       \\sum_{j=1}&#94;M\\left(p_j + \\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)} !!       \\dfrac{I_{p_j+1}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right]}{I_{p_j}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right]}\\right) !!       D(\\omega_j)\\right] !! This function calculates !! \\sum_{p_j}\\left[\\left(\\prod_{j=1}&#94;{M}F_j\\right) !!   \\sum_{j=1}&#94;M\\left(p_j + \\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)} !!   \\dfrac{I_{p_j+1}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right]}{I_{p_j}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right]}\\right)\\right] !! The F_j terms are calculated based on (42) from the paper !! F_j = \\exp\\left[\\dfrac{p_j\\hbar\\omega_j}{2kT} - !!   S_j\\coth\\left(\\dfrac{\\hbar\\omega_j}{2kT}\\right)\\right] !!   I_{p_j}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right] !! !! <h2>Walkthrough</h2> !! implicit none ! integer :: iE , j ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio ! prodFj = 1.0_dp sumOverj = 0.0_dp do j = 1 , nModes !! * For each phonon mode !!    * Get the modified Bessel function I_{p_j} !!    * If the number of additional phonons p_j > 0 !!      and I_{p_j} > 10&#94;{-15}, F_j = 0 !!    * Otherwise, calculate F_j from (42) !!    * Multiply F_j on running product to get \\prod_{j=1}&#94;{M}F_j !!    * Calculate I_{p_j+1}(x)I_{p_j}(x) !!    * Add results to running total to get innermost sum in (43) in paper !!      (see Background for details) ! Fj = 1.0_dp ! besPj = besOrderNofModeM ( abs ( pj ( j )), j ) ! !> @todo Change this to merge if statements @endtodo !if ( pj(j) > 0 .and. besPj > 1.0e-15_dp ) then !  ! !  Fj = 0.0_dp !  ! if ( pj ( j ) > 0 ) then ! if ( besPj > 1.0e-15_dp ) then ! Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj ! else ! Fj = 0.0_dp !! @todo Figure out why don't just exit here because will be multiplying by 0 @endtodo ! endif ! else ! Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj ! endif ! prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( j ) / ( abs ( pj ( j )) + 1 ) ! Small argument approximation: ! I_{p_j}(x) \\approx (x/2)&#94;{p_j}/\\Gamma(p_j+1) ! which means ! I_{p_j+1}(x)/I_{p_j}(x) \\approx \\dfrac{(x/2)&#94;{p_j+1}}{(x/2)&#94;{p_j}}\\dfrac{\\Gamma(p_j+1)}{\\Gamma(p_j+2)} !   = x/2\\dfrac{p_j!}{(p_j+1)!} = x/2(n+1) ! if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( j )) + 1 , j ) / besPj !! @todo Redo `besRatio` if statement to be more clear that it is if/else @endtodo ! sumOverj = sumOverj + ( abs ( pj ( j )) + x ( j ) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) !! * Calculate the energy gained by the extra phonons ! !> * Calculate the energy index iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 !! * Increment the number of energies in the calculated bin ! lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj !! * Combine terms to get the middle portion of (43) in the paper (see Background for details) ! return ! end subroutine lsfOfConfigurationPj ! ! subroutine calculatePlusMinusStates ( l ) !! Get all of the possible binary numbers with !! l digits and store them in `pms`. !! !! @note The binary numbers are reversed before stored, but I don't know why. @endnote ! implicit none ! integer , intent ( in ) :: l ! integer :: iDec , other ( 0 : l - 1 ) ! do iDec = 0 , 2 ** l - 1 ! other (:) = 0 ! call decimalToOther ( iDec , l , 2 , other ) ! pms ( iDec ,:) = other (:) !! @todo Send slice instead of using `other` @endtodo ! enddo ! return ! end subroutine calculatePlusMinusStates ! ! subroutine distrubutePhononsInBands ( m , l ) !! Generate all possible ways to distribute `m` phonons in `l` bands !! such that each band has at least one phonon (only plus no minuses) !! !! @todo Figure out if there is a better way in general to do this @endtodo !! @todo Write a recursive function to replace explicit loops @endtodo !! @todo Fix typo in `distrubute` @endtodo !! @todo Change `l` to `nBands` and `m` to `kPhonons` or something similar @endtodo ! implicit none ! integer , intent ( in ) :: m , l ! integer :: i , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 , i11 , i12 ! if ( l == 1 ) then ! If there's only one band, all phonons go in the band ! pj0s ( 1 , 1 ) = m ! else if ( l == m - 1 ) then ! do i = 1 , l pj0s ( i ,:) = 1 pj0s ( i , i ) = m - ( l - 1 ) enddo ! else if ( l == m ) then ! If there are the same number of bands and phonons, ! one phonon goes in each band ! pj0s ( 1 ,:) = 1 ! else if ( l == 2 ) then ! do i = 1 , m - 1 ! pj0s ( i , 1 ) = i pj0s ( i , 2 ) = m - i ! enddo ! else if ( l == 3 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) !! @todo Add a condition to exit inner loop if `i1 + i2 + i3 > m` @endtodo ! if ( i1 + i2 + i3 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 ! i = i + 1 !! @todo Add a condition to exit inner loop if `i > size of pj0s` @endtodo ! endif ! enddo enddo enddo ! !write(6,*) 'l = 3, i = ', i - 1 ! else if ( l == 4 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 ! i = i + 1 ! endif ! enddo enddo enddo enddo !write(6,*) 'l = 4, i = ', i - 1 ! else if ( l == 5 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo ! !write(6,*) 'l = 5, i = ', i - 1 ! else if ( l == 6 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 6, i = ', i - 1 ! else if ( l == 7 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 7, i = ', i ! else if ( l == 8 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 8, i = ', i ! else if ( l == 9 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 10 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 11 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 12 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) do i12 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 + i12 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 pj0s ( i , 12 ) = i12 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo endif ! return ! end subroutine distrubutePhononsInBands ! ! subroutine lsfWithMphonons ( m , l , tTimes ) !! Pick `nMC` groups of bands, then calculate the !! line shape function for all possible configurations !! in those bands and sum to get an estimate of the !! total line shape function for m phonons in !! l bands !! !! @todo Make sure that Monte Carlo makes sense here @endtodo !! @todo Figure out if there are any methods that would be better/faster @endtodo !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: m , l , tTimes ! integer :: ii ! integer :: iMC , iM , i , pick , j , picks ( l ), iE , iDes , iRand , steps ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio , randy ! logical :: picked !! if ( myid == root ) then write ( iostd , '(i4,\" phonons by\", i3, \" bands started.\")' ) m , l flush ( iostd ) endif ! printSteps = int ( ( iModeFs ( myid ) - iModeIs ( myid ) + 1.01_dp ) / 10 ) ! do iMC = iModeIs ( myid ), iModeFs ( myid ) ! if ( mod ( iMC - iModeIs ( myid ) + 1 , printSteps ) == 0 ) then if ( myid == root ) then steps = iModeFs ( myid ) - iModeIs ( myid ) + 1 write ( iostd , '(i4,\" phonons by\", i3,\" bands.\", i12,\" over \",i12,\" MC iters per processor done.\")' ) m , l , iMC , steps flush ( iostd ) endif endif ! picks (:) = 0 ! !> * Randomly pick l bands from possible modes !> @todo Figure out a better way to do this as it is crazy inefficient @endtodo if ( istat == 0 ) then ! do iM = 1 , l picked = . false . !! @todo Remove as not needed @endtodo 10 read ( un ) iRand iRand = mod ( abs ( iRand ), nModes ) + 1 do i = 1 , iM - 1 if ( picks ( i ) == iRand ) goto 10 enddo picks ( iM ) = iRand ! enddo ! else ! do iM = 1 , l picked = . false . ! 11 CALL RANDOM_NUMBER ( randy ) ! pick = int ( nModes * randy ) + 1 do i = 1 , l if ( pick . eq . picks ( i ) ) picked = . true . !! @todo Fix the possible bug here @endtodo enddo if ( picked ) goto 11 picks ( iM ) = pick enddo ! endif ! do ii = 1 , tTimes !! * Calculate the line shape function for each possible !!   configuration in the chosen bands !! @todo Move some of this to another subroutine @endtodo ! do iDes = 0 , 2 ** l - 1 ! pj (:) = 0 ! do iM = 1 , l pj ( picks ( iM )) = pj0s ( ii , iM ) * ( - 1 ) ** ( pms ( iDes , iM - 1 )) enddo ! if ( abs ( sum ( abs ( pj ( picks (:)))) - m ) > 0 ) then if ( myid == root ) then write ( iostd , * ) 'ERROR' , m , sum ( abs ( pj ( picks (:)))), pj ( picks (:)) do iM = 1 , l if ( abs ( pj ( picks ( iM ))) < 1 ) then write ( iostd , * ) 'ERROR 1' , picks ( iM ) write ( iostd , * ) 'ERROR 2' , pj ( picks ( iM )) flush ( iostd ) endif enddo endif endif ! prodFj = 1.0_dp sumOverj = 0.0_dp ! do j = 1 , nModes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( j )), j ) if ( pj ( j ) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( j ) * wby2kT ( j ) - Sj ( j ) * coth ( j )) * besPj endif ! prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( j ) / ( abs ( pj ( j )) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( j )) + 1 , j ) / besPj ! sumOverj = sumOverj + ( abs ( pj ( j )) + x ( j ) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) ! iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! enddo ! enddo ! enddo ! if ( myid == root ) then write ( iostd , '(\"---------------------------------------------\")' ) write ( iostd , '(i4,\" phonons by\", i3, \" bands done.\")' ) m , l flush ( iostd ) endif ! return ! end subroutine lsfWithMphonons ! ! subroutine decimalToOther ( iDec , n , iBase , other ) !! Convert an input number in base 10 to an !! n digit number in base `iBase`. The number !! is returned in the length `n` vector `other`. !! !! @todo Figure out why array is reversed @endtodo ! implicit none ! integer , intent ( in ) :: n , iBase integer :: iDec , m integer :: other ( 0 : n - 1 ), j ! m = iDec do j = n - 1 , 1 , - 1 other ( j ) = int ( m / ( iBase ** j )) m = mod ( iDec , iBase ** j ) enddo other ( 0 ) = mod ( m , iBase ) ! return ! end subroutine decimalToOther ! ! subroutine calculateDE ( maxM , iEbins , de ) !! Calculate the maximum number of bins the !! energy spectrum can be split into such that !! no bin is empty then return the size `de` of !! the resulting bin ! implicit none ! integer , intent ( in ) :: maxM , iEbins ( - nEnergies : nEnergies ) real ( dp ), intent ( out ) :: de ! integer :: iE , j , ic , ib , iEmMax , nSteps , jMax , iEstep ! integer , allocatable :: tmpB (:), iEsteps (:) ! logical :: empty ! allocate ( tmpB ( nEnergies ) ) ! !> * Generate factors of `nEnergies` !> @todo Figure out if there is a clearer or faster way to do this @endtodo !> @todo Maybe move this to a subroutine @endtodo ic = 1 do j = 1 , nEnergies if ( mod ( nEnergies , j ) == 0 ) then tmpB ( ic ) = int (( dble ( nEnergies ) + 1.e-8_dp ) / j ) ic = ic + 1 endif enddo ! nSteps = ic - 1 allocate ( iEsteps ( nSteps ) ) iEsteps (:) = tmpB ( nSteps : 1 : - 1 ) deallocate ( tmpB ) ! iEmMax = int ( maxM * maxval ( phonF (:)) / deltaE ) + 1 ! j = 1 do while ( ( iEmMax > iEsteps ( j ) ) . and . ( j < nSteps ) ) j = j + 1 enddo ! jMax = j - 1 if ( jMax > nSteps ) jMax = nSteps ! empty = . true . !! @todo Switch the `.true.` and `.false.` assignments to make more sense @endtodo j = jMax do while ( ( empty . eqv . . true . ) . and . ( j > 1 ) ) !! * Find the smallest factor (step) that can use such that !!   none of the energy bins are empty ! empty = . true . iEstep = iEsteps ( j ) do iE = 1 , iEmMax - 1 , iEstep ib = sum ( iEbins ( iE : iE + iEstep - 1 ) ) if ( ib < 1 ) then empty = . false . endif enddo j = j - 1 ! enddo ! j = j + 2 ! iEstep = iEsteps ( j ) de = deltaE * real ( iEstep , dp ) ! deallocate ( iEsteps ) ! return ! end subroutine calculateDE ! ! subroutine lsfMbyOneBand ( M ) !! Calculate the line shape function for !! various sets \\{p_j\\} where all p_j !! are zero except one that has values !! -M, M ! implicit none ! integer , intent ( in ) :: M !! Number of phonons ! integer :: iMode1 , pm1 ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do iMode1 = 1 , nModes ! do pm1 = - M , M , 2 * M ! pj (:) = 0 pj ( iMode1 ) = pm1 ! call lsfOfConfigurationPj () ! enddo ! enddo ! call cpu_time ( t2 ) ! write ( iostd , '(\" LSF of: \", i4, \" phonons using one band done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) ! return ! end subroutine lsfMbyOneBand ! ! subroutine lsfMbyTwoBands ( m ) !! Calculate the line shape function for !! various sets \\{p_j\\} where all p_j !! are zero except two that have values !! such that the total number of phonons (plus or minus) in !! the two bands is 3 ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , iMode2 , pm1 , pm2 , l ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do l = 1 , m - 1 ! do iMode1 = 1 , nModes - 1 do iMode2 = iMode1 + 1 , nModes ! do pm1 = - l , l , 2 * l do pm2 = - ( m - l ), ( m - l ), 2 * ( m - l ) ! pj (:) = 0 pj ( iMode1 ) = pm1 pj ( iMode2 ) = pm2 ! call lsfOfConfigurationPj () ! enddo enddo ! enddo enddo ! enddo ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using two bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyTwoBands ! ! subroutine lsfMbyThreeBands ( m ) !! Calculate the line shape function for m phonons in 3 bands !! !! <h2>Background</h2> !! !! The number of ways to put `kPhonons` in `nBands` so that !! all bands have at least one phonon is the same as first putting !! a phonon in each band, then counting how many ways you can !! distribute the rest of the phonons. In other words, since the !! number of ways to distribute k phonons into n bands !! (empty or not) is !! {n+k-1\\choose k} !! and each of our n bands needs at least one phonon, we just !! replace the available phonons to distribute k with k-n !! to get !! {n+(k-n)-1\\choose (k-n)} = {k-1\\choose k-n} !! See [this Quora article](https://www.quora.com/What-is-the-number-of-ways-to-distribute-8-identical-balls-in-3-different-boxes-none-being-empty) for more details. !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: m ! real ( dp ) :: t1 , t2 , times3 integer :: iMode1 , iMode2 , iMode3 , ni , mi , iDes , ii ! call cpu_time ( t1 ) ! !> * Determine the length of the `pj0s` array !> @todo Replace this with `binomialCoefficient(kPhonons-1, kPhonons-nBands)` @endtodo times3 = 1.0_dp mi = 2 do ni = m - 1 , m - 3 + 1 , - 1 times3 = times3 * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times3 + 1.e-3_dp ), 3 ) ) pj0s (:,:) = 0 ! call distrubutePhononsInBands ( m , 3 ) !! * Generate all of the possible configurations for !!   m phonons in 3 bands ! allocate ( pms ( 0 : 2 ** 3 - 1 , 0 : 3 - 1 ) ) pms (:,:) = 0 ! call calculatePlusMinusStates ( 3 ) !! * Generate all possible binary numbers with 3 digits ! do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , nModes - 1 do iMode3 = iMode2 + 1 , nModes !! * Pick 3 bands, ! do ii = 1 , int ( times3 + 1.e-3_dp ) !! pick a phonon distribution configuration, ! do iDes = 0 , 2 ** 3 - 1 !! pick a distribution of positive and negative signs, ! pj (:) = 0 ! pj ( iMode1 ) = pj0s ( ii , 1 ) * ( - 1 ) ** ( pms ( iDes , 1 - 1 )) pj ( iMode2 ) = pj0s ( ii , 2 ) * ( - 1 ) ** ( pms ( iDes , 2 - 1 )) pj ( iMode3 ) = pj0s ( ii , 3 ) * ( - 1 ) ** ( pms ( iDes , 3 - 1 )) ! call lsfOfConfigurationPj () !! calculate the lsf of the configuration, and repeat !! until all possible combinations have been calculated ! enddo ! enddo ! enddo enddo enddo ! deallocate ( pj0s , pms ) ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using three bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyThreeBands ! ! subroutine writeLSFandCrossSection () !! Write out the line shape function versus energy !! !! @todo Change the name of this subroutine to just `writeLSF` @endtodo !! @todo Remove all of the extra stuff from this subroutine @endtodo ! implicit none ! integer :: iE real ( kind = dp ) :: E !, vg ! open ( 1 , file = 'lsfVsE' , status = 'unknown' ) ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) ! !write(1,'(F16.8,2E18.6e3)') E*HartreeToEv, lsfVsE(iE), twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg write ( 1 , '(F16.8,E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ) !, twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! enddo ! close ( 1 ) ! return ! end subroutine writeLSFandCrossSection ! ! subroutine init_random_seed () ! implicit none ! integer ( kind = int32 ), allocatable :: seed (:) integer ( kind = int32 ) :: n !, i, n, dt(8), pid integer :: t ! call random_seed ( size = n ) ! allocate ( seed ( n )) ! ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. ! call system_clock ( t ) ! seed = 5347 ! !    if (t == 0) then !      call date_and_time(values=dt) !      t = (dt(1) - 1970) * 365 * 24 * 60 * 60 * 1000 & !          + dt(2) * 31 * 24 * 60 * 60 * 1000 & !          + dt(3) * 24 * 60 * 60 * 1000 & !          + dt(5) * 60 * 60 * 1000 & !          + dt(6) * 60 * 1000 + dt(7) * 1000 & !          + dt(8) !    end if !    pid = getpid() !    t = ieor(t, int(pid, kind(t))) !    do i = 1, n !      seed(i) = lcg(t) !    end do !    ! call random_seed ( put = seed ) ! end subroutine init_random_seed ! ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. ! integer function lcg ( s ) ! integer :: s ! if ( s == 0 ) then s = 104729 else !s = mod(s, 4294967296) s = mod ( s , 4294967 ) end if ! !s = mod(s * 279470273, 4294967291) s = mod ( s * 279470273 , 4294967 ) ! lcg = int ( mod ( s , huge ( 0 )), kind ( 0 )) ! end function lcg ! ! subroutine parallelIsFsBy3 () !! Figure out what mode each process should start (`iModeIs`) !! and finish on (`iModeFs`) so that the resulting states are !! balanced between the processes !! !! @note !! If the number of processors is greater than the number of !! modes, only `nModes-2` processes will actually be used !! @endnote !! !! @todo Merge this with `parallelIsFsBy4` @endtodo ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = nModes / 6.0_dp totalStates = totalStates * ( nModes - 1 ) * ( nModes - 2 ) ! totalStates = binomialCoefficient(nModes, nPhonons) !! @todo Write a binomialCoefficient function @endtodo ! !write(iostd, *) 'totalStates', totalStates if ( nModes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = nModes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) / 2.0_dp ! states = binomialCoefficient(iState-1, nPhonons-1) parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 2.0_dp ! parTotal2 = parTotal + binomialCoefficient(iState-2, nPhonons-1) ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = nModes - iState + 1 iModeIs ( iproc + 1 ) = nModes - iState + 2 ! iproc = iproc + 1 totalStates = totalStates - parTotal !! @todo Change this to use available states instead of totalStates @endtodo parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = nModes - 2 ! else ! nProcMax = nModes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy3 ! ! subroutine parallelIsFsBy4 () !! Figure out what mode each process should start (`iModeIs`) !! and finish on (`iModeFs`) so that the resulting states are !! balanced between the processes !! !! @note !! If the number of processors is greater than the number of !! modes, only `nModes-2` processes will actually be used !! @endnote ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = nModes / 2 4.0_dp totalStates = totalStates * ( nModes - 1 ) * ( nModes - 2 ) * ( nModes - 3 ) ! !write(iostd, *) 'totalStates', totalStates if ( nModes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = nModes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 6.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) * real ( iState - 4 , dp ) / 6.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = nModes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = nModes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = nModes - 2 ! else ! nProcMax = nModes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy4 ! ! end module lsf","tags":"","loc":"sourcefile/lsf_zeroth_module_v35.f90.html","title":"LSF_zeroth_Module_v35.f90 – Carrier Cross Sections"},{"text":"Contents Programs lineShapeFunction Source Code LSF_linear_Main.f90 Source Code program lineShapeFunction ! use mpi use lsf ! implicit none ! call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! if ( myid == root ) then ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call readPhonons () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call readMjs () ! call initializeLSF () ! endif ! call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( modes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !    allocate( Vfis(-nEnergies:nEnergies) ) endif ! call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( s2L , size ( s2L ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) !  call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( myid == root ) then ! !if ( maximumNumberOfPhonons > 0 ) then if ( ( minimumNumberOfPhonons < 2 ) . and . ( maximumNumberOfPhonons > 0 ) . and . ( modes > 0 ) ) then ! ! One phonon ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call lsfMbyOneBand ( 1 ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 1 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 1 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 1 , file = 'lsfVsEwithUpTo1phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 1 ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 1 ) ! endif ! if ( ( minimumNumberOfPhonons < 3 ) . and . ( maximumNumberOfPhonons > 1 ) . and . ( modes > 1 ) ) then ! ! Two phonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call cpu_time ( t1 ) ! call lsfMbyOneBand ( 2 ) call lsfMbyTwoBands ( 2 ) ! call cpu_time ( t2 ) ! write ( iostd , '(\" 2 modes, time needed :,\" , f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 2 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 2 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 2 , file = 'lsfVsEwithUpTo2phonons' , status = 'unknown' ) ! !      write(2,'(\"# \", i5, \" phonons\")') 2 write ( 2 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 2 do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 2 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 2 ) ! endif ! !   call lsfDeterministicOneAndTwoBands() ! !deallocate ( lsfVsEbyPhonons ) ! endif ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! !if ( maximumNumberOfPhonons > 2 ) then if ( ( minimumNumberOfPhonons < 4 ) . and . ( maximumNumberOfPhonons > 2 ) . and . ( modes > 2 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then ! call lsfMbyOneBand ( 3 ) call lsfMbyTwoBands ( 3 ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 3 ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 3 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 3 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo3phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 3 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 3 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! !if ( maximumNumberOfPhonons > 3 ) then if ( ( minimumNumberOfPhonons < 5 ) . and . ( maximumNumberOfPhonons > 3 ) . and . ( modes > 3 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( 4 ) call lsfMbyTwoBands ( 4 ) ! call parallelIsFsBy3 () ! !write(6,*) '3' !do i = 0, nProcMax - 1 !  write(6,*) i, iModeIs(i), iModeFs(i) !enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 4 ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !if ( myid == root ) then !  write(6,*) '4' !  do i = 0, nProcMax - 1 !    write(6,*) i, iModeIs(i), iModeFs(i) !  enddo !endif ! call lsfDeterministicFourPhononsByFourBands () ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 4 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 4 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo4phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 4 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 4 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! if ( ( maximumNumberOfPhonons > 4 ) . and . ( modes > 4 ) ) then !if ( ( minimumNumberOfPhonons < 6 ) .and. ( maximumNumberOfPhonons > 4 ) ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then if ( istat /= 0 ) then write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' else write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' endif flush ( iostd ) endif ! if ( istat /= 0 ) close ( un ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) allocate ( lsfbyPhononsPerProc ( - nEnergies : nEnergies ) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC do i = numprocs - 1 , 1 , - 1 iModeIs ( i ) = i * iMint + 1 if ( iMmod > 0 ) then iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 endif iModeFs ( i - 1 ) = iModeIs ( i ) - 1 enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 do ni = m - 1 , m - l + 1 , - 1 times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = modes ! do iMode = 2 , l weight = weight * ( modes - iMode + 1 ) / iMode enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m elseif ( m < 100 ) then write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m elseif ( m < 1000 ) then write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m else write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !        write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de enddo close ( 5000 ) ! endif ! enddo ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"sourcefile/lsf_linear_main.f90.html","title":"LSF_linear_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules lsf Source Code LSF_linear_Module_v1.f90 Source Code module lsf ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: int64 = selected_int_kind ( 15 ) integer , parameter :: iostd = 16 , un = 3 integer , parameter :: root = 0 ! real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: THzToHartree = 1.0_dp / 657 9.683920729_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp ! integer ( kind = int32 ) :: myid , numprocs , ios , istat , ierr integer :: iMode , l , m , nMC , nProcMax integer :: iMint , iMmod , i , printsteps , iE , ni , mi integer :: nAtoms , nOfqPoints , nModes , minimumNumberOfPhonons , maximumNumberOfPhonons , nEnergies ! real ( kind = dp ) :: ti , tf , t1 , t2 real ( kind = dp ) :: weight , times , de , E ! , vg real ( kind = dp ) :: temperature , maxEnergy , deltaE , kT ! , volume ! integer , allocatable :: iModeIs (:), iModeFs (:) integer , allocatable :: pj (:), pj0s (:,:), pms (:,:), s2L (:) integer , allocatable :: iEbinsByBands (:), iEbinsByPhonons (:) ! real ( kind = dp ), allocatable :: atomD (:,:), atomM (:), phonQ (:,:), phonF (:), genCoord (:), Mjs (:,:) real ( kind = dp ), allocatable :: wby2kT (:), phonD (:,:,:,:), x (:), Sj (:), coth (:), besOrderNofModeM (:,:) real ( kind = dp ), allocatable :: lsfVsEbyBands (:), lsfVsE (:), lsfVsEbyPhonons (:), lsfbyPhononsPerProc (:) ! integer :: modes ! character ( len = 6 ), parameter :: output = 'status' !  character(len = 256) :: MjsInput, PhononsInput, crossSectionOutput, fn, continueLSFfromFile character ( len = 256 ) :: MjsInput , phononsInput , fn , continueLSFfromFile , equilibriumAtomicPositions ! logical :: file_exists ! !  namelist /elphscat/ MjsInput, PhononsInput, crossSectionOutput, temperature, maxEnergy, continueLSFfromFile, volume, & namelist / lsfInput / MjsInput , equilibriumAtomicPositions , phononsInput , & continueLSFfromFile , maximumNumberOfPhonons , nMC , & temperature , maxEnergy , & modes ! ! contains ! ! subroutine readInputs () ! implicit none ! ! Check if file output exists. If it does, delete it. ! inquire ( file = output , exist = file_exists ) if ( file_exists ) then open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! ! Open new output file. ! open ( iostd , file = output , status = 'new' ) ! call initialize () ! READ ( 5 , lsfInput , iostat = ios ) ! call checkAndUpdateInput () ! return ! end subroutine readInputs ! ! subroutine initializeLSF () ! implicit none ! real ( kind = dp ) :: dummyD integer :: dummyI character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 ! allocate ( lsfVsE ( - nEnergies : nEnergies ) ) ! minimumNumberOfPhonons = 1 lsfVsE (:) = 0.0_dp ! if ( continueLSFfromFile /= '' ) then ! inquire ( file = trim ( continueLSFfromFile ), exist = file_exists ) if ( file_exists ) then ! open ( unit = 11 , file = trim ( continueLSFfromFile ), status = \"old\" ) ! read ( 11 , '(a1, i10, a9, i5, a8)' ) dummyC1 , dummyI , dummyC9 , minimumNumberOfPhonons , dummyC8 ! minimumNumberOfPhonons = minimumNumberOfPhonons + 1 write ( iostd , '(\" Minimum number of phonons : \", i5)' ) minimumNumberOfPhonons ! do iE = - nEnergies , nEnergies read ( 11 , * ) dummyD , lsfVsE ( iE ) enddo close ( 11 ) ! endif endif ! return ! end subroutine initializeLSF ! ! subroutine initialize () ! implicit none ! MjsInput = '' phononsInput = '' !crossSectionOutput = '' temperature = - 1.0_dp deltaE = - 1.0_dp minimumNumberOfPhonons = 1 maximumNumberOfPhonons = - 1 nMC = - 1 modes = - 1 ! return ! end subroutine initialize ! ! subroutine checkAndUpdateInput () ! implicit none ! logical :: abortExecution = . false . ! if ( MjsInput == '' ) then write ( iostd , '(\" MjsInput is not defined!\")' ) write ( iostd , '(\" A default value will be used. MjsInput = VfisVsE\")' ) MjsInput = 'VfisVsE' else write ( iostd , '(\" Mjs elements input : \", a)' ) trim ( MjsInput ) endif ! if ( phononsInput == '' ) then write ( iostd , '(\" PhononsInput is not defined!\")' ) abortExecution = . true . else write ( iostd , '(\" Phonons input : \", a)' ) trim ( PhononsInput ) endif ! if ( temperature < 0.0_dp ) then write ( iostd , '(\" Variable temperature has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Tempetature : \", f10.2, \" Kelvin.\")' ) temperature kT = temperature * 8.6173324d-5 * eVToHartree endif ! !    if ( deltaE < 0 ) then !      write(iostd, '(\" Variable deltaE has not been set.\")') !    else !      write(iostd, '(\" DeltaE : \", f10.5, \" eV.\")') deltaE !      deltaE = deltaE*eVToHartree !    endif ! if ( maximumNumberOfPhonons < 0 ) then write ( iostd , '(\" Variable maximumNumberOfPhonons has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Maximum number of phonons : \", i5)' ) maximumNumberOfPhonons endif if ( nMC < 0 ) then write ( iostd , '(\" Variable nMC has not been set.\")' ) abortExecution = . true . else write ( iostd , '(\" Number of Monte Carlo steps : \", i15)' ) nMC endif ! if ( modes < 0 ) then write ( iostd , '(\" Variable modes has not been set.\")' ) write ( iostd , '(\" All modes will be used.\")' ) endif ! if ( abortExecution ) then write ( iostd , '(\" *************************** \")' ) write ( iostd , '(\" * Program stops!          * \")' ) write ( iostd , '(\" *************************** \")' ) stop endif ! maxEnergy = 1 0.0_dp * eVToHartree ! nEnergies = 5040 ! 2520 ! 10080 deltaE = maxEnergy / real ( nEnergies , dp ) ! write ( iostd , * ) 'nEnergies' , nEnergies write ( iostd , * ) 'maxEnergy' , maxEnergy , 'deltaE' , deltaE ! flush ( iostd ) ! return ! end subroutine checkAndUpdateInput ! ! subroutine readPhonons () ! implicit none ! integer :: iAtom , iMode , iq real ( kind = dp ) :: dummyD , freqInTHz ! CHARACTER :: dummyC ! !write(6,*) trim(PhononsInput) open ( 1 , file = trim ( PhononsInput ), status = \"old\" ) ! read ( 1 , * ) nOfqPoints , nAtoms ! nModes = 3 * nAtoms - 3 ! write ( iostd , '(\" Number of atoms    : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes    : \", i5)' ) nModes if ( modes < 0 ) then modes = nModes write ( iostd , '(\" Number of modes to be used : \", i5)' ) modes endif flush ( iostd ) ! read ( 1 , * ) ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) enddo ! read ( 1 , * ) ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) ! flush ( iostd ) ! return ! end subroutine readPhonons ! ! subroutine computeGeneralizedDisplacements () ! implicit none ! integer :: iq , iMode , iAtom ! allocate ( genCoord ( nModes ) ) ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) ! enddo ! enddo ! enddo ! !    open(11, file='generalizedDisplacements', status='unknown') !    ! !    write(11, '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2\")') !    ! !    do iMode = 1, nModes !     write(11, '(i4,1x,3E20.10E3)') iMode, phonF(iMode)*1.0e3_dp*HartreeToEv, genCoord(iMode), genCoord(iMode)*genCoord(iMode) !    enddo !    ! !    close(11) ! deallocate ( atomM , phonD , atomD ) ! return ! end subroutine computeGeneralizedDisplacements ! ! subroutine computeVariables () ! implicit none ! integer :: i , j , nm , nb ! real ( kind = dp ), allocatable :: bi (:), di (:), bk (:), dk (:) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ) ) ! x = 0.0_dp Sj = 0.0_dp coth = 0.0_dp wby2kT = 0.0_dp ! Sj (:) = 0.5_dp * phonF (:) * genCoord (:) * genCoord (:) wby2kT (:) = phonF (:) / ( 2.0_dp * kT ) coth (:) = cosh ( wby2kT (:)) / sinh ( wby2kT (:)) x (:) = Sj (:) / sinh ( wby2kT (:)) ! allocate ( s2L ( nModes ) ) s2L (:) = 0 ! do iMode = 1 , nModes s2L ( iMode ) = iMode enddo ! call arrangeLargerToSmaller () ! open ( 11 , file = 'modes' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2,  Sj/sinh(wby2kT)\")' ) ! do iMode = 1 , nModes ! write ( 11 , '(i4,1x,4E20.10E3)' ) s2L ( iMode ), phonF ( s2L ( iMode )) * 1.0e3_dp * HartreeToEv , & genCoord ( s2L ( iMode )), genCoord ( s2L ( iMode )) ** 2 , x ( s2L ( iMode )) ! enddo ! close ( 11 ) ! deallocate ( genCoord ) ! nb = maximumNumberOfPhonons allocate ( besOrderNofModeM ( 0 : nb + 1 , nModes ) ) allocate ( bi ( 0 : nb + 1 ), di ( 0 : nb + 1 ) ) allocate ( bk ( 0 : nb + 1 ), dk ( 0 : nb + 1 ) ) ! do j = 1 , nModes ! bi (:) = 0.0_dp ! nm = nb + 1 call iknb ( nb + 1 , x ( j ), nm , bi ) ! , di, bk, dk) ! do i = 0 , nb + 1 ! besOrderNofModeM ( i , j ) = bi ( i ) ! enddo ! !write(6,*) j, x(j) !, (besOrderNofModeM(i,j), i = 0, 5) ! nb + 1) !, phonF(j) ! enddo ! return ! end subroutine computeVariables ! ! subroutine arrangeLargerToSmaller () ! implicit none ! integer :: i , iMode ! real ( kind = dp ), allocatable :: temp (:) real ( kind = dp ) :: tmpr integer :: tmpi ! allocate ( temp ( nModes ) ) ! temp (:) = 0.0_dp temp (:) = x (:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! if ( exp(wby2kT(i))*bessi(1,x(i)) < exp(wby2kT(i+1))*bessi(1,x(i+1)) ) then ! !          tmpi = s2L(i) !          s2L(i) = s2L(i+1) !          s2L(i+1) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! tmpr = Sj ( i ) Sj ( i ) = Sj ( i + 1 ) Sj ( i + 1 ) = tmpr ! tmpr = x ( i ) x ( i ) = x ( i + 1 ) x ( i + 1 ) = tmpr ! tmpr = coth ( i ) coth ( i ) = coth ( i + 1 ) coth ( i + 1 ) = tmpr ! tmpr = wby2kT ( i ) wby2kT ( i ) = wby2kT ( i + 1 ) wby2kT ( i + 1 ) = tmpr ! tmpr = phonF ( i ) phonF ( i ) = phonF ( i + 1 ) phonF ( i + 1 ) = tmpr ! endif ! enddo ! enddo ! deallocate ( temp ) ! return ! end subroutine arrangeLargerToSmaller ! ! subroutine readMjs () ! implicit none ! integer :: i , iE0 , iE , numOfMjs real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , MjOfE , MjOfE0 , eBin , DHifMin , eifMin , volume character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 character ( len = 256 ) :: modeFolder ! allocate ( Mjs ( modes , - nEnergies : nEnergies ) ) ! Mjs (:,:) = 0.0_dp ! do iMode = 1 , modes ! if ( s2L ( iMode ) < 10 ) then write ( modeFolder , '(\"mode_\", i1, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 100 ) then write ( modeFolder , '(\"mode_\", i2, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 1000 ) then write ( modeFolder , '(\"mode_\", i3, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) else if ( s2L ( iMode ) < 10000 ) then write ( modeFolder , '(\"mode_\", i4, \"/\", a)' ) s2L ( iMode ), trim ( MjsInput ) endif ! ! inquire ( file = trim ( modeFolder ), exist = file_exists ) if ( . not . file_exists ) then ! write ( iostd , '(\" File : \", a, \" does not exist!\")' ) trim ( modeFolder ) ! else ! write ( iostd , '(\" Reading file : \", a)' ) trim ( modeFolder ) ! open ( 1 , file = trim ( modeFolder ), status = \"old\" ) ! read ( 1 , * ) read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 read ( 1 , * ) ! read ( 1 , '(i10)' ) numOfMjs ! read ( 1 , '(3ES24.15E3)' ) Ee , MjOfE0 , dummyD1 ! Mjs ( iMode , 1 ) = MjOfE0 !energy(1) = Ee ! iE = int ( Ee / de ) + 1 ! do i = 2 , numOfMjs ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE read ( 1 , '(3ES24.15E3)' ) Ee , MjOfE , dummyD2 !          energy(i) = Ee iE = int ( Ee / de ) + 1 !Vfis(iE0:iE) = VfiOfE0 Mjs ( iMode , i ) = MjOfE !VfiOfE0 = VfiOfE ! write ( 6 , * ) iMode , Mjs ( iMode , i ) enddo ! close ( 1 ) ! endif ! enddo ! !do iE = 0, numOfVfis ! -nEnergies, nEnergies !  write(44,*) energy(iE)*HartreeToEv, Vfis(iE), lsf(iE) !enddo ! !close(44) ! return ! end subroutine readMjs ! ! subroutine lsfDeterministicFourPhononsByFourBands () ! implicit none ! integer :: ic integer :: iMode1 , iMode2 , iMode3 , iMode4 integer :: pm1 , pm2 , pm3 , pm4 ! real ( kind = dp ) :: t1 , t2 ! if ( myid == root ) then write ( iostd , * ) 'Four modes' flush ( iostd ) endif ! ! Four modes ! call cpu_time ( t1 ) ! ic = 0 do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , modes - 2 do iMode3 = iMode2 + 1 , modes - 1 do iMode4 = iMode3 + 1 , modes ! do pm1 = - 1 , 1 , 2 do pm2 = - 1 , 1 , 2 do pm3 = - 1 , 1 , 2 do pm4 = - 1 , 1 , 2 ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 pj ( s2L ( iMode2 )) = pm2 pj ( s2L ( iMode3 )) = pm3 pj ( s2L ( iMode4 )) = pm4 ! call lsfOfConfigurationPj () ! ic = ic + 1 ! enddo enddo enddo enddo ! enddo enddo enddo enddo ! call cpu_time ( t2 ) ! return ! end subroutine lsfDeterministicFourPhononsByFourBands ! ! subroutine lsfOfConfigurationPj () ! implicit none ! integer :: iE , j ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio ! prodFj = 1.0_dp sumOverj = 0.0_dp do j = 1 , modes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( s2L ( j ))), s2L ( j )) if ( pj ( s2L ( j )) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj endif prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( s2L ( j )) / ( abs ( pj ( s2L ( j ))) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( s2L ( j ))) + 1 , s2L ( j )) / besPj sumOverj = sumOverj + ( abs ( pj ( s2L ( j ))) + x ( s2L ( j )) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! return ! end subroutine lsfOfConfigurationPj ! ! subroutine calculatePlusMinusStates ( l ) ! implicit none ! integer , intent ( in ) :: l ! integer :: iDes , other ( 0 : l - 1 ) ! do iDes = 0 , 2 ** l - 1 ! other (:) = 0 ! call decimalToOther ( iDes , l , 2 , other ) ! pms ( iDes ,:) = other (:) ! enddo ! return ! end subroutine calculatePlusMinusStates ! ! subroutine distrubutePhononsInBands ( m , l ) ! implicit none ! integer , intent ( in ) :: m , l ! integer :: i , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 , i11 , i12 ! if ( l == 1 ) then ! pj0s ( 1 , 1 ) = m ! else if ( l == m - 1 ) then ! do i = 1 , l pj0s ( i ,:) = 1 pj0s ( i , i ) = m - ( l - 1 ) enddo ! else if ( l == m ) then ! pj0s ( 1 ,:) = 1 ! else if ( l == 2 ) then ! do i = 1 , m - 1 ! pj0s ( i , 1 ) = i pj0s ( i , 2 ) = m - i ! enddo ! else if ( l == 3 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 ! i = i + 1 ! endif ! enddo enddo enddo ! !write(6,*) 'l = 3, i = ', i - 1 ! else if ( l == 4 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 ! i = i + 1 ! endif ! enddo enddo enddo enddo !write(6,*) 'l = 4, i = ', i - 1 ! else if ( l == 5 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo ! !write(6,*) 'l = 5, i = ', i - 1 ! else if ( l == 6 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 6, i = ', i - 1 ! else if ( l == 7 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 7, i = ', i ! else if ( l == 8 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo ! !write(6,*) 'l = 8, i = ', i ! else if ( l == 9 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 10 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 11 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo ! else if ( l == 12 ) then ! i = 1 do i1 = 1 , m - ( l - 1 ) do i2 = 1 , m - ( l - 1 ) do i3 = 1 , m - ( l - 1 ) do i4 = 1 , m - ( l - 1 ) do i5 = 1 , m - ( l - 1 ) do i6 = 1 , m - ( l - 1 ) do i7 = 1 , m - ( l - 1 ) do i8 = 1 , m - ( l - 1 ) do i9 = 1 , m - ( l - 1 ) do i10 = 1 , m - ( l - 1 ) do i11 = 1 , m - ( l - 1 ) do i12 = 1 , m - ( l - 1 ) ! if ( i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 + i12 == m ) then ! pj0s ( i , 1 ) = i1 pj0s ( i , 2 ) = i2 pj0s ( i , 3 ) = i3 pj0s ( i , 4 ) = i4 pj0s ( i , 5 ) = i5 pj0s ( i , 6 ) = i6 pj0s ( i , 7 ) = i7 pj0s ( i , 8 ) = i8 pj0s ( i , 9 ) = i9 pj0s ( i , 10 ) = i10 pj0s ( i , 11 ) = i11 pj0s ( i , 12 ) = i12 ! i = i + 1 ! endif ! enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo endif ! return ! end subroutine distrubutePhononsInBands ! ! subroutine lsfWithMphonons ( m , l , tTimes ) ! implicit none ! integer , intent ( in ) :: m , l , tTimes ! integer :: ii ! integer :: iMC , iM , i , pick , j , picks ( l ), iE , iDes , iRand , steps ! real ( kind = dp ) :: E , Fj , prodFj , sumOverj , besPj , besRatio , randy ! logical :: picked ! if ( myid == root ) then write ( iostd , '(i4,\" phonons by\", i3, \" bands started.\")' ) m , l flush ( iostd ) endif ! printSteps = int ( ( iModeFs ( myid ) - iModeIs ( myid ) + 1.01_dp ) / 10 ) ! do iMC = iModeIs ( myid ), iModeFs ( myid ) ! if ( mod ( iMC - iModeIs ( myid ) + 1 , printSteps ) == 0 ) then if ( myid == root ) then steps = iModeFs ( myid ) - iModeIs ( myid ) + 1 write ( iostd , '(i4,\" phonons by\", i3,\" bands.\", i12,\" over \",i12,\" MC iters per processor done.\")' ) m , l , iMC , steps flush ( iostd ) endif endif ! picks (:) = 0 ! if ( istat == 0 ) then ! do iM = 1 , l picked = . false . 10 read ( un ) iRand iRand = mod ( abs ( iRand ), modes ) + 1 do i = 1 , iM - 1 if ( picks ( i ) == iRand ) goto 10 enddo picks ( iM ) = iRand ! enddo ! else ! do iM = 1 , l picked = . false . ! 11 CALL RANDOM_NUMBER ( randy ) ! pick = int ( modes * randy ) + 1 do i = 1 , l if ( pick . eq . picks ( i ) ) picked = . true . enddo if ( picked ) goto 11 picks ( iM ) = pick enddo ! endif ! do ii = 1 , tTimes ! do iDes = 0 , 2 ** l - 1 ! pj (:) = 0 ! do iM = 1 , l pj ( s2L ( picks ( iM ))) = pj0s ( ii , iM ) * ( - 1 ) ** ( pms ( iDes , iM - 1 )) enddo ! if ( abs ( sum ( abs ( pj ( picks (:)))) - m ) > 0 ) then if ( myid == root ) then write ( iostd , * ) 'ERROR' , m , sum ( abs ( pj ( s2L ( picks (:))))), pj ( s2L ( picks (:))) do iM = 1 , l if ( abs ( pj ( picks ( iM ))) < 1 ) then write ( iostd , * ) 'ERROR 1' , picks ( iM ) write ( iostd , * ) 'ERROR 2' , pj ( s2L ( picks ( iM ))) flush ( iostd ) endif enddo endif endif ! prodFj = 1.0_dp sumOverj = 0.0_dp ! do j = 1 , modes ! Fj = 1.0_dp besPj = besOrderNofModeM ( abs ( pj ( s2L ( j ))), s2L ( j )) if ( pj ( s2L ( j )) > 0 ) then if ( besPj > 1.0e-15_dp ) then Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj else Fj = 0.0_dp endif else Fj = exp ( pj ( s2L ( j )) * wby2kT ( s2L ( j )) - Sj ( s2L ( j )) * coth ( s2L ( j ))) * besPj endif ! prodFj = prodFj * Fj ! besRatio = 0.5_dp * x ( s2L ( j )) / ( abs ( pj ( s2L ( j ))) + 1 ) if ( besPj > 1.0e-15_dp ) besRatio = besOrderNofModeM ( abs ( pj ( s2L ( j ))) + 1 , s2L ( j )) / besPj ! sumOverj = sumOverj + ( abs ( pj ( s2L ( j ))) + x ( s2L ( j )) * besRatio ) ! enddo ! E = sum ( pj (:) * phonF (:)) ! iE = 0 if ( abs ( E ) > 1.0e-6_dp * evToHartree ) then iE = int ( abs ( E ) / deltaE ) + 1 if ( E < 0.0_dp ) iE = - iE endif ! iEbinsByBands ( iE ) = iEbinsByBands ( iE ) + 1 lsfVsEbyBands ( iE ) = lsfVsEbyBands ( iE ) + prodFj * sumOverj ! enddo ! enddo ! enddo ! if ( myid == root ) then write ( iostd , '(\"---------------------------------------------\")' ) write ( iostd , '(i4,\" phonons by\", i3, \" bands done.\")' ) m , l flush ( iostd ) endif ! return ! end subroutine lsfWithMphonons ! ! subroutine decimalToOther ( iDec , n , iBase , other ) ! implicit none ! integer , intent ( in ) :: n , iBase integer :: iDec , m integer :: other ( 0 : n - 1 ), j ! m = iDec do j = n - 1 , 1 , - 1 other ( j ) = int ( m / ( iBase ** j )) m = mod ( iDec , iBase ** j ) enddo other ( 0 ) = mod ( m , iBase ) ! return ! end subroutine decimalToOther ! ! subroutine calculateDE ( maxM , iEbins , de ) ! implicit none ! integer , intent ( in ) :: maxM , iEbins ( - nEnergies : nEnergies ) real ( dp ), intent ( out ) :: de ! integer :: iE , j , ic , ib , iEmMax , nSteps , jMax , iEstep ! integer , allocatable :: tmpB (:), iEsteps (:) ! logical :: empty ! allocate ( tmpB ( nEnergies ) ) ! ic = 1 do j = 1 , nEnergies if ( mod ( nEnergies , j ) == 0 ) then tmpB ( ic ) = int (( dble ( nEnergies ) + 1.e-8_dp ) / j ) ic = ic + 1 endif enddo ! nSteps = ic - 1 allocate ( iEsteps ( nSteps ) ) iEsteps (:) = tmpB ( nSteps : 1 : - 1 ) deallocate ( tmpB ) ! iEmMax = int ( maxM * maxval ( phonF (:)) / deltaE ) + 1 ! j = 1 do while ( ( iEmMax > iEsteps ( j ) ) . and . ( j < nSteps ) ) j = j + 1 enddo ! jMax = j - 1 if ( jMax > nSteps ) jMax = nSteps ! empty = . true . j = jMax do while ( ( empty . eqv . . true . ) . and . ( j > 1 ) ) ! empty = . true . iEstep = iEsteps ( j ) do iE = 1 , iEmMax - 1 , iEstep ib = sum ( iEbins ( iE : iE + iEstep - 1 ) ) if ( ib < 1 ) then empty = . false . endif enddo j = j - 1 ! enddo ! j = j + 2 ! iEstep = iEsteps ( j ) de = deltaE * real ( iEstep , dp ) ! deallocate ( iEsteps ) ! return ! end subroutine calculateDE ! ! subroutine lsfMbyOneBand ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , pm1 ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do iMode1 = 1 , modes ! do pm1 = - m , m , 2 * m ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 ! call lsfOfConfigurationPj () ! enddo ! enddo ! call cpu_time ( t2 ) ! write ( iostd , '(\" LSF of: \", i4, \" phonons using one band done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) ! return ! end subroutine lsfMbyOneBand ! ! subroutine lsfMbyTwoBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! integer :: iMode1 , iMode2 , pm1 , pm2 , l ! real ( dp ) :: t1 , t2 ! call cpu_time ( t1 ) ! do l = 1 , m - 1 ! do iMode1 = 1 , modes - 1 do iMode2 = iMode1 + 1 , modes ! do pm1 = - l , l , 2 * l do pm2 = - ( m - l ), ( m - l ), 2 * ( m - l ) ! pj (:) = 0 pj ( s2L ( iMode1 )) = pm1 pj ( s2L ( iMode2 )) = pm2 ! call lsfOfConfigurationPj () ! enddo enddo ! enddo enddo ! enddo ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using two bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyTwoBands ! ! subroutine lsfMbyThreeBands ( m ) ! implicit none ! integer , intent ( in ) :: m ! real ( dp ) :: t1 , t2 , times3 integer :: iMode1 , iMode2 , iMode3 , ni , mi , iDes , ii ! call cpu_time ( t1 ) ! times3 = 1.0_dp mi = 2 do ni = m - 1 , m - 3 + 1 , - 1 times3 = times3 * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times3 + 1.e-3_dp ), 3 ) ) pj0s (:,:) = 0 ! call distrubutePhononsInBands ( m , 3 ) ! allocate ( pms ( 0 : 2 ** 3 - 1 , 0 : 3 - 1 ) ) pms (:,:) = 0 ! call calculatePlusMinusStates ( 3 ) ! do iMode1 = iModeIs ( myid ), iModeFs ( myid ) do iMode2 = iMode1 + 1 , modes - 1 do iMode3 = iMode2 + 1 , modes ! do ii = 1 , int ( times3 + 1.e-3_dp ) ! do iDes = 0 , 2 ** 3 - 1 ! pj (:) = 0 ! pj ( s2L ( iMode1 )) = pj0s ( ii , 1 ) * ( - 1 ) ** ( pms ( iDes , 1 - 1 )) pj ( s2L ( iMode2 )) = pj0s ( ii , 2 ) * ( - 1 ) ** ( pms ( iDes , 2 - 1 )) pj ( s2L ( iMode3 )) = pj0s ( ii , 3 ) * ( - 1 ) ** ( pms ( iDes , 3 - 1 )) ! call lsfOfConfigurationPj () ! enddo ! enddo ! enddo enddo enddo ! deallocate ( pj0s , pms ) ! call cpu_time ( t2 ) ! if ( myid == root ) then write ( iostd , '(\" LSF of: \", i4, \" phonons using three bands done in: \", f10.2, \" secs.\")' ) m , t2 - t1 flush ( iostd ) endif ! return ! end subroutine lsfMbyThreeBands ! ! subroutine writeLSFandCrossSection () ! implicit none ! integer :: iE real ( kind = dp ) :: E !, vg ! open ( 1 , file = 'lsfVsE' , status = 'unknown' ) ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) ! !write(1,'(F16.8,2E18.6e3)') E*HartreeToEv, lsfVsE(iE), twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg write ( 1 , '(F16.8,E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ) !, twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! enddo ! close ( 1 ) ! return ! end subroutine writeLSFandCrossSection ! ! subroutine init_random_seed () ! implicit none ! integer ( kind = int32 ), allocatable :: seed (:) integer ( kind = int32 ) :: n !, i, n, dt(8), pid integer :: t ! call random_seed ( size = n ) ! allocate ( seed ( n )) ! ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. ! call system_clock ( t ) ! seed = 5347 ! !    if (t == 0) then !      call date_and_time(values=dt) !      t = (dt(1) - 1970) * 365 * 24 * 60 * 60 * 1000 & !          + dt(2) * 31 * 24 * 60 * 60 * 1000 & !          + dt(3) * 24 * 60 * 60 * 1000 & !          + dt(5) * 60 * 60 * 1000 & !          + dt(6) * 60 * 1000 + dt(7) * 1000 & !          + dt(8) !    end if !    pid = getpid() !    t = ieor(t, int(pid, kind(t))) !    do i = 1, n !      seed(i) = lcg(t) !    end do !    ! call random_seed ( put = seed ) ! end subroutine init_random_seed ! ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. ! integer function lcg ( s ) ! integer :: s ! if ( s == 0 ) then s = 104729 else !s = mod(s, 4294967296) s = mod ( s , 4294967 ) end if ! !s = mod(s * 279470273, 4294967291) s = mod ( s * 279470273 , 4294967 ) ! lcg = int ( mod ( s , huge ( 0 )), kind ( 0 )) ! end function lcg ! ! subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !c*********************************************************************72 !c !cc IKNB compute Bessel function In(x) and Kn(x). !c !c  Discussion: !c !c    Compute modified Bessel functions In(x) and Kn(x), !c    and their derivatives. !c !c  Licensing: !c !c    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !c    they give permission to incorporate this routine into a user program !c    provided that the copyright is acknowledged. !c !c  Modified: !c !c    17 July 2012 !c !c  Author: !c !c    Shanjie Zhang, Jianming Jin !c !c  Reference: !c !c    Shanjie Zhang, Jianming Jin, !c    Computation of Special Functions, !c    Wiley, 1996, !c    ISBN: 0-471-11963-6, !c    LC: QA351.C45. !c !c  Parameters: !c !c    Input, integer N, the order of In(x) and Kn(x). !c !c    Input, double precision X, the argument. !c !c    Output, integer NM, the highest order computed. !c !c    Output, double precision BI(0:N), DI(0:N), BK(0:N), DK(0:N), !c    the values of In(x), In'(x), Kn(x), Kn'(x). !c implicit none integer , intent ( in ) :: n !      double precision :: a0 double precision :: bi ( 0 : n ) !      double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: f0 double precision :: f1 !      double precision :: g !      double precision :: g0 !      double precision :: g1 integer :: k !      integer :: k0 !      integer :: l integer :: m , ik !      integer :: msta1 !      integer :: msta2 integer :: nm double precision :: pi !      double precision :: r double precision :: s0 double precision :: sk0 !      double precision :: vt double precision :: x , ifact pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n if ( x . le . 1.0D-15 ) then do k = 0 , n ifact = 1.0_dp do ik = 2 , k ifact = ifact * ik enddo bi ( k ) = ( 0.5_dp * x ) ** k / ifact end do return end if if ( n . eq . 0 ) then nm = 1 end if m = msta1 ( x , 200 ) if ( m . lt . nm ) then nm = m else m = msta2 ( x , nm , 15 ) end if bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 if ( k . le . nm ) then bi ( k ) = f end if if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then sk0 = sk0 + 4.0D+00 * f / k end if bs = bs + 2.0D+00 * f f0 = f1 f1 = f end do s0 = exp ( x ) / ( bs - f ) do k = 0 , nm bi ( k ) = s0 * bi ( k ) end do return end SUBROUTINE iknb ! ! SUBROUTINE iknb2 ( n , x , nm , bi , di , bk , dk ) ! !    ============================================================ !    Purpose: Compute modified Bessel functions In(x) and Kn(x), !             and their derivatives !    Input:   x --- Argument of In(x) and Kn(x) ( 0 ó x ó 700 ) !             n --- Order of In(x) and Kn(x) !    Output:  BI(n) --- In(x) !             DI(n) --- In'(x) !             BK(n) --- Kn(x) !             DK(n) --- Kn'(x) !             NM --- Highest order computed !    Routines called: !             MSTA1 and MSTA2 for computing the starting point !             for backward recurrence !    =========================================================== ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( OUT ) :: nm REAL ( dp ), INTENT ( OUT ) :: bi ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: di ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: bk ( 0 : n ) REAL ( dp ), INTENT ( OUT ) :: dk ( 0 : n ) ! REAL ( dp ), PARAMETER :: pi = 3.141592653589793_dp , el = 0.5772156649015329_dp REAL ( dp ) :: a0 , bkl , bs , f , f0 , f1 , g , g0 , g1 , r , s0 , sk0 , vt INTEGER :: k , k0 , l , m ! nm = n IF ( x <= 1.0D-50 ) THEN DO k = 0 , n bi ( k ) = 0.0D0 di ( k ) = 0.0D0 bk ( k ) = 1.0D+300 dk ( k ) = - 1.0D+300 END DO bi ( 0 ) = 1.0D0 di ( 1 ) = 0.5D0 RETURN END IF IF ( n == 0 ) nm = 1 m = msta1 ( x , 200 ) IF ( m < nm ) THEN nm = m ELSE m = msta2 ( x , nm , 15 ) END IF !write(6,*)'mmmmmmmmm', m bs = 0.0D0 sk0 = 0.0D0 f0 = 0.0D0 f1 = 1.0D-100 DO k = m , 0 , - 1 f = 2 * ( k + 1 ) / x * f1 + f0 IF ( k <= nm ) bi ( k ) = f IF ( k /= 0 . AND . k == 2 * INT ( k / 2 )) sk0 = sk0 + 4.0D0 * f / k bs = bs + 2.0D0 * f f0 = f1 f1 = f END DO !s0 = EXP(x) / (bs-f) !write(6,*) f, f1 s0 = EXP ( x ) / ( bs - f1 ) bi ( 0 : nm ) = s0 * bi ( 0 : nm ) IF ( x <= 8.0D0 ) THEN bk ( 0 ) = - ( LOG ( 0.5D0 * x ) + el ) * bi ( 0 ) + s0 * sk0 bk ( 1 ) = ( 1.0D0 / x - bi ( 1 ) * bk ( 0 )) / bi ( 0 ) ELSE a0 = SQRT ( pi / ( 2.0D0 * x )) * EXP ( - x ) k0 = 16 IF ( x >= 2 5.0 ) k0 = 10 IF ( x >= 8 0.0 ) k0 = 8 IF ( x >= 20 0.0 ) k0 = 6 DO l = 0 , 1 bkl = 1.0D0 vt = 4 * l r = 1.0D0 DO k = 1 , k0 r = 0.125D0 * r * ( vt - ( 2 * k - 1 ) ** 2 ) / ( k * x ) bkl = bkl + r END DO bk ( l ) = a0 * bkl END DO END IF g0 = bk ( 0 ) g1 = bk ( 1 ) DO k = 2 , nm g = 2 * ( k - 1 ) / x * g1 + g0 bk ( k ) = g g0 = g1 g1 = g END DO di ( 0 ) = bi ( 1 ) dk ( 0 ) = - bk ( 1 ) DO k = 1 , nm di ( k ) = bi ( k - 1 ) - k / x * bi ( k ) dk ( k ) = - bk ( k - 1 ) - k / x * bk ( k ) END DO RETURN ! END SUBROUTINE iknb2 ! ! FUNCTION msta1 ( x , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that the magnitude of !                Jn(x) at that point is about 10&#94;(-MP) !       Input :  x     --- Argument of Jn(x) !                MP    --- Value of magnitude !       Output:  MSTA1 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , f , f0 , f1 INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) n0 = INT ( 1.1 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - mp IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn ! RETURN ! END FUNCTION msta1 ! ! FUNCTION msta2 ( x , n , mp ) RESULT ( fn_val ) ! !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that all Jn(x) has MP !                significant digits !       Input :  x  --- Argument of Jn(x) !                n  --- Order of Jn(x) !                MP --- Significant digit !       Output:  MSTA2 --- Starting point !       =================================================== ! REAL ( dp ), INTENT ( IN ) :: x INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( IN ) :: mp INTEGER :: fn_val ! REAL ( dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj INTEGER :: it , n0 , n1 , nn ! a0 = ABS ( x ) hmp = 0.5_dp * mp ejn = envj ( n , a0 ) IF ( ejn <= hmp ) THEN obj = mp n0 = INT ( 1.1 * a0 ) ELSE obj = hmp + ejn n0 = n END IF !!!!!!!! if ( n0 < 1 ) n0 = 1 !!!!!!!! f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj ! DO it = 1 , 20 nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) f = envj ( nn , a0 ) - obj IF ( ABS ( nn - n1 ) < 1 ) EXIT n0 = n1 f0 = f1 n1 = nn f1 = f END DO ! fn_val = nn + 10 ! RETURN ! END FUNCTION msta2 ! ! FUNCTION envj ( n , x ) RESULT ( fn_val ) ! INTEGER , INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val ! fn_val = 0.5_dp * LOG10 ( 6.28_dp * n ) - n * LOG10 ( 1.36_dp * x / n ) ! RETURN ! END FUNCTION envj ! ! subroutine parallelIsFsBy3 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = modes / 6.0_dp totalStates = totalStates * ( modes - 1 ) * ( modes - 2 ) ! if ( modes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = modes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) / 2.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 2.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = modes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = modes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = modes - 2 ! else ! nProcMax = modes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! write ( 6 , * ) iModeIs (:), iModeFs (:) ! return ! end subroutine parallelIsFsBy3 ! ! subroutine parallelIsFsBy4 () ! implicit none ! real ( dp ) :: parTotal , parTotal2 , totalStates , states , averageStatesPerProc integer :: i , iState , iproc ! totalStates = modes / 2 4.0_dp totalStates = totalStates * ( modes - 1 ) * ( modes - 2 ) * ( modes - 3 ) ! if ( modes > numprocs ) then ! nProcMax = numprocs ! parTotal = 0 iproc = 0 iModeIs ( iproc ) = 1 iState = modes ! do while ( ( iState > 1 ) . and . ( nProcMax - iproc > 1 ) ) ! states = real ( iState - 1 , dp ) * real ( iState - 2 , dp ) * real ( iState - 3 , dp ) / 6.0_dp parTotal = parTotal + states parTotal2 = parTotal + real ( iState - 2 , dp ) * real ( iState - 3 , dp ) * real ( iState - 4 , dp ) / 6.0_dp ! averageStatesPerProc = totalStates / ( nProcMax - iproc ) - 0.01_dp if ( ( parTotal > averageStatesPerProc ) . or . ( parTotal2 > averageStatesPerProc ) ) then iModeFs ( iproc ) = modes - iState + 1 iproc = iproc + 1 iModeIs ( iproc ) = modes - iState + 2 totalStates = totalStates - parTotal parTotal = 0 endif ! iState = iState - 1 ! enddo ! iModeFs ( iproc ) = modes - 2 ! else ! nProcMax = modes - 2 ! do i = 0 , nProcMax - 1 iModeIs ( i ) = i + 1 iModeFs ( i ) = i + 1 enddo endif ! return ! end subroutine parallelIsFsBy4 ! ! end module lsf","tags":"","loc":"sourcefile/lsf_linear_module_v1.f90.html","title":"LSF_linear_Module_v1.f90 – Carrier Cross Sections"},{"text":"Contents Programs crossSection Source Code Sigma_Main.f90 Source Code program crossSection !! Combine the results of TME and LSF !! into the cross section ! use sigma_module ! implicit none ! call readInputs () !! * Read input, initializing and checking all variables of the calculation ! call calculateSigma () !! * Calculate \\sigma(E) ! call writeSigma () !! * Output \\sigma(E) ! end program crossSection","tags":"","loc":"sourcefile/sigma_main.f90.html","title":"Sigma_Main.f90 – Carrier Cross Sections"},{"text":"Contents Modules sigma_module Source Code Sigma_Module_v4.f90 Source Code module sigma_module ! implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: int32 = selected_int_kind ( 5 ) integer , parameter :: iostd = 16 integer , parameter :: nOfEnergyBins = 5040 ! ! real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: maxEnergy = 1 0.0_dp real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi ! character ( len = 11 ), parameter :: output = 'sigmaStatus' ! integer ( kind = int32 ) :: ios integer :: m integer :: nEnergies integer :: numOfVfis ! real ( kind = dp ) :: volume real ( kind = dp ) :: de real ( kind = dp ) :: eifMin real ( kind = dp ) :: DHifMin ! real ( kind = dp ), allocatable :: E (:) real ( kind = dp ), allocatable :: energy (:) real ( kind = dp ), allocatable :: lorentz (:) real ( kind = dp ), allocatable :: lorentzByPhonon (:) real ( kind = dp ), allocatable :: lsf (:) real ( kind = dp ), allocatable :: lsfVsE (:) real ( kind = dp ), allocatable :: lsfVsEbyPhonon (:) real ( kind = dp ), allocatable :: sigma (:) real ( kind = dp ), allocatable :: sigmaByPhonon (:) real ( kind = dp ), allocatable :: Vfis (:) ! character ( len = 256 ) :: VfisInput character ( len = 256 ) :: LSFinput character ( len = 256 ) :: crossSectionOutput ! logical :: file_exists ! namelist / elphscat / VfisInput , LSFinput , crossSectionOutput ! ! contains ! ! subroutine readInputs () !! Read input parameters and read LSF and TME output !! !! <h2>Walkthrough</h2> !! implicit none ! !> * Check if an output file exists; if it does, delete it inquire ( file = output , exist = file_exists ) ! if ( file_exists ) then ! open ( unit = 11 , file = output , status = \"old\" ) ! close ( unit = 11 , status = \"delete\" ) ! endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! call initialize () !! * Set default values of input parameters ! READ ( 5 , elphscat , iostat = ios ) !! * Read in input parameters ! call checkInputAndUpdateParameters () !! * Check if input parameters were updated !!   and do some basic checks ! call readLSF () !! * Read the LSF output ! call readVfis () !! * Read the TME output ! return ! end subroutine readInputs ! ! subroutine initialize () !! Set default values for input parameters ! implicit none ! VfisInput = '' LSFinput = '' crossSectionOutput = '' ! de = maxEnergy * eVToHartree / real ( nOfEnergyBins , dp ) ! return ! end subroutine initialize ! ! subroutine checkInputAndUpdateParameters () !! Check that the input variables don't still have their default !! values. If the input files are not defined, end the program. ! implicit none ! if ( VfisInput == '' ) then write ( iostd , '(\" Vfi elements input (input variable VfisInput) is not defined!\")' ) else inquire ( file = trim ( VfisInput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" Vfi elements input : \", a)' ) trim ( VfisInput ) else write ( iostd , '(\" Vfi elements input : \", a, \" does not exist!\")' ) trim ( VfisInput ) endif endif ! if ( LSFinput == '' ) then write ( iostd , '(\" LSF input (input variable LSFinput) is not defined!\")' ) else inquire ( file = trim ( LSFinput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" LSF input : \", a)' ) trim ( LSFinput ) else write ( iostd , '(\" LSF input : \", a, \" does not exist!\")' ) trim ( LSFinput ) endif endif ! if ( crossSectionOutput == '' ) then write ( iostd , '(\" crossSectionOutput is not defined! File name : crossSection, will be used.\")' ) crossSectionOutput = 'crossSection' else write ( iostd , '(\" Cross section output file name : \", a)' ) trim ( crossSectionOutput ) endif ! if ( ( VfisInput == '' ) . or . ( LSFinput == '' ) ) then ! write ( iostd , '(\" One or both of the input files is not defined! \")' ) write ( iostd , '(\" ********************************************** \")' ) write ( iostd , '(\" *               Program stops!               * \")' ) write ( iostd , '(\" *       Please check the output file.        * \")' ) write ( iostd , '(\" ********************************************** \")' ) ! stop ! endif ! flush ( iostd ) ! return ! end subroutine checkInputAndUpdateParameters ! ! subroutine readLSF () !! Read LSF output !! !! <h2>Walkthrough</h2> !! implicit none ! character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 !! @todo Merge these dummy characters @endtodo ! real ( kind = dp ) :: ee !! Energy in eV ! integer :: iE !! Loop index over energies ! open ( 1 , file = trim ( LSFinput ), status = 'old' ) !! * Open the LSF output file ! read ( 1 , '(a1, i10, a9, i5, a8)' ) dummyC1 , nEnergies , dummyC9 , m , dummyC8 !! * Read in the number of energies and ?? ! allocate ( E ( - nEnergies : nEnergies ), lsfVsE ( - nEnergies : nEnergies ), lsfVsEbyPhonon ( - nEnergies : nEnergies ) ) ! do iE = - nEnergies , nEnergies !! * For each energy, read in the energy value as well as `lsfVsE` and `lsfVsEbyPhonon` ! read ( 1 , '(F16.8,2E18.6e3)' ) ee , lsfVsE ( iE ), lsfVsEbyPhonon ( iE ) E ( iE ) = ee * eVToHartree ! enddo ! close ( 1 ) ! end subroutine readLSF ! ! subroutine readVfis () !! Read TME output, get `Vfis` and `lsf` using the same index, !! and output the results to two output files !! !! @note !! This subroutine does not line up with what is output from the TME program, !! so I'm not 100% sure where the input is coming from or what it's supposed !! to be !! @endnote !! !! <h2>Walkthrough</h2> !! implicit none ! integer :: i , iE0 , iE real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , VfiOfE , VfiOfE0 , eBin character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 !! @todo Merge dummy variables @endtodo ! open ( 1 , file = trim ( VfisInput ), status = \"old\" ) ! !read(1, '(a1, i10, a9, f15.4, a16)') dummyC1, nEVfi, dummyC9, volume, dummyC16 ! read ( 1 , * ) !! * Ignore the first line as it is a comment ! read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 !! * Read cell volume ! read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 !! * Read minimum transition energy ! read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 !! * Read |\\Delta H_{if}|&#94;2 at min transition energy ! read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 !! * Read energy bin size ! read ( 1 , * ) !! * Ignore the next line as it is a comment ! read ( 1 , '(i10)' ) numOfVfis !! * Read in `nOfEnergies`? ! allocate ( Vfis ( 0 : numOfVfis ), energy ( 0 : numOfVfis ), lsf ( 0 : numOfVfis ) ) ! Vfis (:) = 0.0_dp energy (:) = 0.0_dp lsf (:) = 0.0_dp ! read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE0 , dummyD1 Vfis ( 1 ) = VfiOfE0 energy ( 1 ) = Ee !! * Read in the initial values of energy and `Vfis` ! iE = int ( Ee / de ) + 1 !! * Calculate the energy index ! do i = 2 , numOfVfis !! * For each energy !!    * Read in energy and `VFiOfE` !!    * Calculate the indices needed to get `VFis` !!      and `lsfVsE` using the same index !!    * Average `lsf` over those indices and store !!      in a single index matching that of `Vfis` ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE ! read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE , dummyD2 ! energy ( i ) = Ee ! iE = int ( Ee / de ) + 1 ! !Vfis(iE0:iE) = VfiOfE0 Vfis ( i ) = VfiOfE !VfiOfE0 = VfiOfE ! lsf ( i - 1 ) = sum ( lsfVsE ( iE0 : iE )) / ( iE - iE0 + 1 ) ! write ( 26 , * ) E ( iE0 ), Ee , lsf ( i ) ! sum(lsfVsE(iE0:iE))/(iE-iE0+1) !! @todo Figure out where this file is opened @endtodo ! enddo ! close ( 1 ) close ( 26 ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies !! * For each energy, output the energy in eV, `Vfis` and `lsf` ! write ( 44 , * ) energy ( iE ) * HartreeToEv , Vfis ( iE ), lsf ( iE ) !! @todo Figure out where this file is opened @endtodo ! enddo ! close ( 44 ) ! return ! end subroutine readVfis ! ! subroutine calculateSigma () ! implicit none ! integer :: iE real ( kind = dp ) :: vg , sigma0 ! allocate ( sigma ( numOfVfis ) ) ! , sigmaByPhonon(-nEnergies:nEnergies) ) !allocate( sigma(-nEnergies:nEnergies), sigmaByPhonon(-nEnergies:nEnergies) ) ! iE = int ( eifMin / de ) + 1 !! * Calculate the index for the min energy ! write ( 6 , * ) eifMin , eifMin * HartreeToEv , iE !! * Output the min energy in Hartree and eV as well as energy index !! @todo Figure out where this file is opened @endtodo ! sigma0 = twoPi * abCM ** 2 * volume * DHifMin * lsfVsE ( iE ) / sqrt ( 2.0_dp * E ( iE )) !! * Calculate min energy \\sigma !! @todo Figure out what `abCM` is @endtodo ! !do iE = 1, numOfVfis ! -nEnergies, nEnergies - 1 !  if ( (E(iE) < eifMin).and.(E(iE+1) > eifMin) ) sigma0 = twoPi*abCM**2*volume*DHifMin*lsfVsE(iE)/sqrt(2.0_dp*E(iE)) !enddo ! write ( 6 , * ) eifMin * HartreeToEv , sigma0 !! * Output the minimum energy and the cross section at that energy ! sigma (:) = 0.0_dp ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies !! * Calculate \\sigma(E) = \\dfrac{2\\pi*\\text{abCM}&#94;2*\\Omega}{\\hbar v_g}|M_e&#94;{BO}|&#94;2|_{if} ! vg = 1.0_dp ! if ( energy ( iE ) > 0.0_dp ) vg = sqrt ( 2.0_dp * energy ( iE )) ! !write(6,*) iE, energy(iE), vg, Vfis(iE), lsf(iE) sigma ( iE ) = twoPi * abCM ** 2 * volume * Vfis ( iE ) * lsf ( iE ) / vg !sigma(iE)         = twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg !sigmaByPhonon(iE) = twoPi*abCM**2*volume*Vfis(iE)*lsfVsEbyPhonon(iE)/vg ! enddo ! return ! end subroutine calculateSigma ! ! subroutine writeSigma () !! Write the energy and \\sigma(E) ! implicit none ! integer :: iE ! open ( 2 , file = trim ( crossSectionOutput ), status = 'unknown' ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies ! write ( 2 , * ) energy ( iE ) * HartreeToEv , sigma ( iE ) !, sigmaByPhonon(iE) !write(2,*) E(iE), sigma(iE), sigmaByPhonon(iE) ! enddo ! close ( 2 ) ! return ! end subroutine writeSigma ! ! end module sigma_module","tags":"","loc":"sourcefile/sigma_module_v4.f90.html","title":"Sigma_Module_v4.f90 – Carrier Cross Sections"},{"text":"Contents Modules constants Source Code constants.f90 Source Code module constants implicit none ! integer , parameter :: dp = selected_real_kind ( 15 , 307 ) !! Used to make reals double precision integer , parameter :: iostd = 16 !! Unit number for output file ! real ( kind = dp ), parameter :: abCM = 0.529177219217e-8_dp real ( kind = dp ), parameter :: eVToHartree = 1.0_dp / 2 7.21138386_dp real ( kind = dp ), parameter :: HartreeToEv = 2 7.21138386_dp real ( kind = dp ), parameter :: pi = 3.1415926535897932_dp real ( kind = dp ), parameter :: THzToHartree = 1.0_dp / 657 9.683920729_dp real ( kind = dp ), parameter :: twopi = 2.0_dp * pi ! end module constants","tags":"","loc":"sourcefile/constants.f90.html","title":"constants.f90 – Carrier Cross Sections"},{"text":"Contents Modules generalComputations Source Code generalComputations.f90 Source Code module generalComputations ! use constants ! implicit none ! contains ! subroutine computeGeneralizedDisplacements ( nOfqPoints , nModes , genCoord , nAtoms , atomM , phonD , atomD ) !! Calculate the generalized displacements !! by dotting the phonon displacements with !! the atom displacements !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: nAtoms !! Number of atoms in system integer , intent ( in ) :: nModes !! Number of phonon modes integer , intent ( in ) :: nOfqPoints !! Number of q points integer :: iAtom !! Loop index over atoms integer :: iMode !! Loop index over phonon modes integer :: iq !! Loop index over q points ! real ( kind = dp ), intent ( in ) :: atomD ( 3 , nAtoms ) !! Equilibrium displacements in defect versus pristine real ( kind = dp ), intent ( in ) :: atomM ( nAtoms ) !! Atom masses real ( kind = dp ), intent ( out ) :: genCoord ( nModes ) !! Generalized coordinates \\delta q_j real ( kind = dp ), intent ( in ) :: phonD ( 3 , nAtoms , nModes , nOfqPoints ) !! Phonon displacements ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms !! * For each q point, mode, and atom combination, calculate !!   the generalized displacement as !!   \\sum_{\\text{mode}} \\sqrt{1823m}\\mathbf{\\Delta r}_{\\text{phonon}}\\cdot\\mathbf{\\Delta r}_{\\text{atom}} ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) !! @note The `1822.88833218_dp` is a conversion factor from atomic mass units to Hartree @endnote !! @todo Make mass conversion factor a constant parameter for clarity @endtodo ! enddo ! enddo ! enddo ! return ! end subroutine computeGeneralizedDisplacements ! subroutine computeVariables ( x , Sj , coth , wby2kT , phonF , genCoord , kT , s2L , nModes , maximumNumberOfPhonons , besOrderNofModeM ) !! Calculate biggest portions of equations 42 and 43 to make !! entire equation more manageable !! !! <h2>Walkthrough</h2> !! use miscUtilities !! Include `miscUtilities` module for call to !! `arrangeLargerToSmaller` ! implicit none ! integer , intent ( in ) :: maximumNumberOfPhonons integer , intent ( in ) :: nModes !! Number of phonon modes integer , intent ( out ) :: s2L ( nModes ) integer :: i , j , nm integer :: nb !! Final phonon mode integer :: iMode !! Loop index over phonon modes ! real ( kind = dp ), intent ( out ) :: besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) real ( kind = dp ), intent ( out ) :: coth ( nModes ) !! Hyperbolic cotangent real ( kind = dp ), intent ( in ) :: genCoord ( nModes ) !! Generalized coordinates \\delta q_j real ( kind = dp ), intent ( in ) :: kT real ( kind = dp ), intent ( in ) :: phonF ( nModes ) !! Phonon frequencies in Hartree real ( kind = dp ), intent ( out ) :: Sj ( nModes ) !! S_j in equation 44 in paper real ( kind = dp ), intent ( out ) :: wby2kT ( nModes ) !! \\omega/2kT real ( kind = dp ), intent ( out ) :: x ( nModes ) !! Argument to modified Bessel function real ( kind = dp ), allocatable :: bi (:) ! x = 0.0_dp Sj = 0.0_dp coth = 0.0_dp wby2kT = 0.0_dp ! Sj (:) = 0.5_dp * phonF (:) * genCoord (:) * genCoord (:) !! * Calculate !!   S_j = \\dfrac{\\omega_j}{2\\hbar}N\\delta q_j&#94;2 !!   where \\omega_i\\rightarrow`phonF(j)`, !!   \\delta q_j\\rightarrow`genCoord(j)`, and N !!   is the number of atoms per supercell !! @note This is equation 44 in the paper @endnote !! @todo Figure out why there is no N in this equation in the code @endtodo ! wby2kT (:) = phonF (:) / ( 2.0_dp * kT ) !! * Calculate \\hbar\\omega_j/2kT that is the argument !!   to hyperbolic trig functions !! @note This is mainly from equations 42 and 43 in the paper @endnote ! coth (:) = cosh ( wby2kT (:)) / sinh ( wby2kT (:)) !! * Calculate \\coth(\\hbar\\omega_j/2kT) !! @note This is in equation 42 in the paper @endnote !! @todo Figure out if this needs to be another variable @endtodo ! x (:) = Sj (:) / sinh ( wby2kT (:)) !! * Calculate the argument to the modified Bessel functions !!   \\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)} ! s2L (:) = 0 ! do iMode = 1 , nModes !! * Create an array of the indices that will be rearranged ! s2L ( iMode ) = iMode ! enddo ! call arrangeLargerToSmaller ( nModes , x , s2L ) !! * Rearrange the indices based on ordering the arguments (`x`) !!   largest to smallest ! open ( 11 , file = 'modes' , status = 'unknown' ) ! write ( 11 , '(\"#Mode, frequency (eV),        genCoord(Mode),     genCoord(Mode)&#94;2,  Sj/sinh(wby2kT)\")' ) !! @todo Frequency should actually be in eV/\\hbar. Check that that's the case. @endtodo ! do iMode = 1 , nModes !! * Write out the index, \\omega_j in eV, \\delta q_j, \\delta q_j&#94;2, !!   and S_j/\\sinh(\\hbar\\omega_j/2kT) for each phonon mode ! write ( 11 , '(i4,1x,4E20.10E3)' ) s2L ( iMode ), phonF ( s2L ( iMode )) * 1.0e3_dp * HartreeToEv , & genCoord ( s2L ( iMode )), genCoord ( s2L ( iMode )) ** 2 , x ( s2L ( iMode )) ! enddo ! close ( 11 ) ! nb = maximumNumberOfPhonons !! @todo Figure out why this is assigned to another variable @endtodo ! allocate ( bi ( 0 : nb + 1 ) ) !! @todo Figure out if still need `di`, `bk`, and `dk` @endtodo ! do j = 1 , nModes ! bi (:) = 0.0_dp ! nm = nb + 1 !! @todo Figure out if need to have this in loop. Why change `nm` in `iknb`? @endtodo ! call iknb ( nb + 1 , x ( j ), nm , bi ) !! @todo Figure out if should send `nm` as it is immediately modified and not used here @endtodo ! do i = 0 , nb + 1 !! * Store the modified Bessel function for each mode and order !! @todo Possibly change `besOrderNofModeM` to `modBesOrderNofModeM` @endtodo !! @todo Figure out why this loop is here. Can not just pass `besOrderNofModeM(:,j)` @endtodo ! besOrderNofModeM ( i , j ) = bi ( i ) ! enddo ! !write(6,*) j, x(j) !, (besOrderNofModeM(i,j), i = 0, 5) ! nb + 1) !, phonF(j) ! enddo ! deallocate ( bi ) ! return ! end subroutine computeVariables ! ! subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) !! author: Shanjie Zhang, Jianming Jin !! date: 17 July 2012 ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !*********************************************************************72 ! !! IKNB compute Bessel function In(x) and Kn(x). !! !!  <h2>Discussion</h2> !! !!    Compute modified Bessel functions In(x) and Kn(x), !!    and their derivatives. !! !!  <h2>Licensing</h2> !! !!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !!    they give permission to incorporate this routine into a user program !!    provided that the copyright is acknowledged. !! !! !!  <h2>Reference</h2> !! !!    Shanjie Zhang, Jianming Jin, !!    Computation of Special Functions, !!    Wiley, 1996, !!    ISBN: 0-471-11963-6, !!    LC: QA351.C45. !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: n !! Order of I_n(x) and K_n(x) integer , intent ( inout ) :: nm !! The highest order computed integer :: ik integer :: k !    integer :: k0 !    integer :: l integer :: m !    integer :: msta1 !    integer :: msta2 ! !    double precision :: a0 double precision :: bi ( 0 : n ) !! I_n(x) !    double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: fact double precision :: f0 double precision :: f1 !    double precision :: g !    double precision :: g0 !    double precision :: g1 double precision :: pi !    double precision :: r double precision :: s0 double precision :: sk0 !    double precision :: vt double precision :: x !! The argument ! pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n ! if ( x . le . 1.0D-15 ) then !! * If x < 10&#94;{-15}, use the limiting value for  a small argument !!   I_n(x) \\approx \\left(\\dfrac{x}{2}\\right)&#94;2\\Gamma(n+1) !!   where \\Gamma(n+1) = n! to calculate multiple orders of the !!   modified Bessel function (up to n) for a single value of x ! do k = 0 , n ! For each order ! fact = 1.0_dp ! do ik = 2 , k ! Calculate the factorial ! fact = fact * ik ! enddo ! bi ( k ) = ( 0.5_dp * x ) ** k / fact ! Calculate I_n(x) ! enddo ! return ! endif ! if ( n . eq . 0 ) then ! nm = 1 ! end if ! m = msta1 ( x , 200 ) !! * Otherwise, get the starting order m such !!   that J_n(x)\\approx10&#94;{-200} ! if ( m . lt . nm ) then !! * If m is less than the max order to be !!   calculated, set the max to m ! nm = m ! else !! * Otherwise, set m to the starting order such !!   that all J_{nm}(x) have 15 significant digits ! m = msta2 ( x , nm , 15 ) ! end if ! bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 ! do k = m , 0 , - 1 ! f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 ! if ( k . le . nm ) then ! bi ( k ) = f ! end if ! if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then ! sk0 = sk0 + 4.0D+00 * f / k ! end if ! bs = bs + 2.0D+00 * f ! f0 = f1 ! f1 = f ! enddo ! s0 = exp ( x ) / ( bs - f ) ! do k = 0 , nm ! bi ( k ) = s0 * bi ( k ) ! end do ! return end subroutine iknb ! ! function msta1 ( x , mp ) result ( fn_val ) !! Determine the starting point for backward !! recurrence such that the magnitude of !! J_n(x) at that point is about !! 10&#94;{-\\text{mp}} !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: mp !! Magnitude integer :: fn_val !! Starting point integer :: it !! Loop index integer :: n0 , n1 , nn !! Order of Bessel function ! real ( kind = dp ), intent ( in ) :: x !! Argument of J_n(x) real ( kind = dp ) :: a0 !! |x| real ( kind = dp ) :: f , f0 , f1 !! -\\log(J_n(x)) - \\text{mp} ! a0 = abs ( x ) ! n0 = int ( 1.1 * a0 ) + 1 ! f0 = envj ( n0 , a0 ) - mp !! * Get initial guess for f = -log(J_{n_0}(a_0)) - \\text{mp} ! n1 = n0 + 5 ! f1 = envj ( n1 , a0 ) - mp !! * Get next guess for f ! do it = 1 , 20 !! * Recursively minimize f ! nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) ! f = envj ( nn , a0 ) - mp ! if ( abs ( nn - n1 ) < 1 ) exit ! n0 = n1 ! f0 = f1 ! n1 = nn ! f1 = f ! enddo ! fn_val = nn ! return ! end function msta1 ! ! function msta2 ( x , n , mp ) result ( fn_val ) !! Determine the starting point for backward !! recurrence such that all J_n(x) has mp !! significant digits !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: n !! Order of J_n(x) integer , intent ( in ) :: mp !! Significant digit integer :: fn_val !! Starting point integer :: it , n0 , n1 , nn ! real ( kind = dp ), intent ( in ) :: x !! Argument of J_n(x) real ( kind = dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj ! a0 = ABS ( x ) ! hmp = 0.5_dp * mp ! ejn = envj ( n , a0 ) ! if ( ejn <= hmp ) then ! obj = mp ! n0 = int ( 1.1 * a0 ) ! else ! obj = hmp + ejn ! n0 = n ! endif ! if ( n0 < 1 ) n0 = 1 ! f0 = envj ( n0 , a0 ) - obj ! n1 = n0 + 5 ! f1 = envj ( n1 , a0 ) - obj ! do it = 1 , 20 ! nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) ! f = envj ( nn , a0 ) - obj ! if ( abs ( nn - n1 ) < 1 ) exit ! n0 = n1 ! f0 = f1 ! n1 = nn ! f1 = f ! enddo ! fn_val = nn + 10 ! return ! end function msta2 ! ! function envj ( n , x ) result ( fn_val ) !! Estimates -\\log(J_n(x)) from the estimate !! J_n(x) \\approx \\dfrac{1}{\\sqrt{2\\pi n}}\\left(\\dfrac{ex}{2n}\\right)&#94;n ! implicit none ! integer , intent ( in ) :: n !! Order of Bessel function real ( kind = dp ), intent ( in ) :: x !! Argument real ( kind = dp ) :: fn_val !! -\\log(J_n(x)) ! fn_val = 0.5_dp * log10 ( 6.28_dp * n ) - n * log10 ( 1.36_dp * x / n ) ! 6.28 = 2\\pi and 1.36 = e/2 ! return ! end function envj ! end module generalComputations","tags":"","loc":"sourcefile/generalcomputations.f90.html","title":"generalComputations.f90 – Carrier Cross Sections"},{"text":"Contents Modules miscUtilities Source Code miscUtilities.f90 Source Code module miscUtilities ! use constants ! implicit none ! contains ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine int2str ( integ , string ) !! Write a given integer to a string, using only as many digits as needed ! implicit none integer :: integ character ( len = 300 ) :: string ! if ( integ < 10 ) then write ( string , '(i1)' ) integ else if ( integ < 100 ) then write ( string , '(i2)' ) integ else if ( integ < 1000 ) then write ( string , '(i3)' ) integ else if ( integ < 10000 ) then write ( string , '(i4)' ) integ endif ! string = trim ( string ) ! return ! end subroutine int2str ! !--------------------------------------------------------------------------------------------------------------------------------- subroutine arrangeLargerToSmaller ( nModes , x , s2L ) !! Sort `s2L` based on descending order !! of `x` !! !! @todo Change this to a more efficient algorithm @endtodo ! implicit none ! integer , intent ( in ) :: nModes !! Number of phonon modes integer , intent ( inout ) :: s2L ( nModes ) !! Indexes phonon information that come in !! in order (1, 2, 3, ...) and are rearranged !! here so that they are the indices in order !! of the magnitude of the argument `x` integer :: i , iMode ! real ( kind = dp ), intent ( in ) :: x ( nModes ) !! Argument to modified Bessel function real ( kind = dp ) :: temp ( nModes ) real ( kind = dp ) :: tmpr integer :: tmpi ! temp (:) = 0.0_dp temp (:) = x (:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! tmpi = s2L ( i ) s2L ( i ) = s2L ( i + 1 ) s2L ( i + 1 ) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! endif ! enddo ! enddo ! return ! end subroutine arrangeLargerToSmaller ! end module miscUtilities","tags":"","loc":"sourcefile/miscutilities.f90.html","title":"miscUtilities.f90 – Carrier Cross Sections"},{"text":"Contents Modules readInputFiles Source Code readInputFiles.f90 Source Code module readInputFiles ! use constants ! implicit none ! contains ! subroutine readPhonons ( phononsInput , nOfqPoints , nAtoms , nModes , atomD , atomM , phonQ , phonF , phonD ) !! Read the number of atoms and q points and !! get the phonon information like frequency !! and displacements !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( out ) :: nOfqPoints !! Number of q points integer , intent ( out ) :: nAtoms !! Number of atoms in system integer , intent ( out ) :: nModes !! Number of phonon modes integer :: iAtom !! Loop index over atoms integer :: iMode !! Loop index over phonon modes integer :: iq !! Loop index over q points ! real ( kind = dp ), allocatable , intent ( out ) :: atomD (:,:) !! Atom displacements when comparing defective and perfect crystals real ( kind = dp ), allocatable , intent ( out ) :: atomM (:) !! Atom masses real ( kind = dp ), allocatable , intent ( out ) :: phonD (:,:,:,:) real ( kind = dp ), allocatable , intent ( out ) :: phonF (:) real ( kind = dp ), allocatable , intent ( out ) :: phonQ (:,:) real ( kind = dp ) :: dummyD !! Dummy variable to ignore input real ( kind = dp ) :: freqInTHz !! Input frequency in THz ! character ( len = 256 ), intent ( in ) :: phononsInput !! QE/VASP phonon output file name character :: dummyC !! Dummy variable to ignore input ! open ( 1 , file = trim ( phononsInput ), status = \"old\" ) !! * Open `phononsInput` file ! read ( 1 , * ) nOfqPoints , nAtoms !! * Read in the number of q points and number of atoms ! nModes = 3 * nAtoms - 3 !! * Calculate the number of phonon modes write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes : \", i5)' ) nModes flush ( iostd ) !! * Write the number of atoms, q points, and modes to the output file ! read ( 1 , * ) !! * Ignore the next line as it is blank ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms !! * For each atom, read in the displacement (either pristine-defect !!   or defect-pristine) and the atom mass ! read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) ! enddo ! read ( 1 , * ) !! * Ignore the next line as it is blank ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints !! * For each q point !!    * Read in the coordinates in q-space !!    * For each phonon mode !!      * Read in the phonon frequency in THz !!      * Convert the frequency to Hartree !!      * Read in the atom displacements ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) !! * Close `phononsInput` file ! flush ( iostd ) ! return ! end subroutine readPhonons ! end module readInputFiles","tags":"","loc":"sourcefile/readinputfiles.f90.html","title":"readInputFiles.f90 – Carrier Cross Sections"},{"text":"type, public :: atom Define a new type to represent an atom in the structure. \n Each different type of atom in the structure will be another\n variable with the type atom . Todo Consider changing atom type to element since it holds more than one atom Contents Variables iRAugMax numOfAtoms numProjs lmMax nMax symbol projAngMom bes_J_qr F F1 F2 r rab wae wps Source Code atom Components Type Visibility Attributes Name Initial integer, public :: iRAugMax Maximum radius of beta projector (outer radius to integrate);\n for PAW augmentation charge may extend a bit further; I think this\n is the max index for the augmentation sphere, so I'm changing the \n name; last name was iRc integer, public :: numOfAtoms Number of atoms of a specific type in the structure integer, public :: numProjs Number of projectors integer, public :: lmMax Number of channels integer, public :: nMax Number of radial mesh points character(len=2), public :: symbol Element name for the given atom type integer, public, allocatable :: projAngMom (:) Angular momentum of each projector real(kind=dp), public, allocatable :: bes_J_qr (:,:) real(kind=dp), public, allocatable :: F (:,:) real(kind=dp), public, allocatable :: F1 (:,:,:) real(kind=dp), public, allocatable :: F2 (:,:,:) real(kind=dp), public, allocatable :: r (:) Radial mesh real(kind=dp), public, allocatable :: rab (:) Derivative of radial mesh real(kind=dp), public, allocatable :: wae (:,:) All electron wavefunction real(kind=dp), public, allocatable :: wps (:,:) Psuedowavefunction Source Code type :: atom !! Define a new type to represent an atom in the structure. !! Each different type of atom in the structure will be another !! variable with the type `atom`. !! @todo Consider changing `atom` type to `element` since it holds more than one atom @endtodo ! ! Define scalar integers integer :: iRAugMax !! Maximum radius of beta projector (outer radius to integrate); !! for PAW augmentation charge may extend a bit further; I think this !! is the max index for the augmentation sphere, so I'm changing the !! name; last name was `iRc` integer :: numOfAtoms !! Number of atoms of a specific type in the structure integer :: numProjs !! Number of projectors integer :: lmMax !! Number of channels integer :: nMax !! Number of radial mesh points ! ! Define scalar character character ( len = 2 ) :: symbol !! Element name for the given atom type ! ! Define matrix/vector integer integer , allocatable :: projAngMom (:) !! Angular momentum of each projector ! ! Define matrix/vector reals real ( kind = dp ), allocatable :: bes_J_qr (:,:) real ( kind = dp ), allocatable :: F (:,:) real ( kind = dp ), allocatable :: F1 (:,:,:) real ( kind = dp ), allocatable :: F2 (:,:,:) real ( kind = dp ), allocatable :: r (:) !! Radial mesh real ( kind = dp ), allocatable :: rab (:) !! Derivative of radial mesh real ( kind = dp ), allocatable :: wae (:,:) !! All electron wavefunction real ( kind = dp ), allocatable :: wps (:,:) !! Psuedowavefunction ! end type atom","tags":"","loc":"type/atom.html","title":"atom – Carrier Cross Sections "},{"text":"type, public :: crystal Contents Variables nKpts numOfPWs nIons numOfTypes nProjs numOfGvecs nBands nSpins npws atomTypeIndex omega bg wk xk posIon wfc beta cProj cCrossProj paw_Wfc pawK crystalType exportDir atoms Source Code crystal Components Type Visibility Attributes Name Initial integer, public :: nKpts Number of k points integer, public :: numOfPWs Total number of plane waves integer, public :: nIons Total number of atoms in system integer, public :: numOfTypes Number of different types of atoms integer, public :: nProjs Number of projectors integer, public :: numOfGvecs Number of G vectors FFT grid was read from input file but not used, so removed integer, public :: nBands Number of bands integer, public :: nSpins Number of spins integer, public, allocatable :: npws (:) Number of plane waves per k point integer, public, allocatable :: atomTypeIndex (:) Index of the given atom type real(kind=dp), public :: omega Cell volume real(kind=dp), public :: bg (3,3) real(kind=dp), public, allocatable :: wk (:) real(kind=dp), public, allocatable :: xk (:,:) real(kind=dp), public, allocatable :: posIon (:,:) complex(kind=dp), public, allocatable :: wfc (:,:) complex(kind=dp), public, allocatable :: beta (:,:) complex(kind=dp), public, allocatable :: cProj (:,:,:) complex(kind=dp), public, allocatable :: cCrossProj (:,:,:) complex(kind=dp), public, allocatable :: paw_Wfc (:,:) complex(kind=dp), public, allocatable :: pawK (:,:,:) character(len=2), public :: crystalType 'PC' for pristine crystal and 'SD' for solid defect character(len=200), public :: exportDir Export directory from pw_export_for_TME type( atom ), public, allocatable :: atoms (:) Source Code type :: crystal integer :: nKpts !! Number of k points integer :: numOfPWs !! Total number of plane waves integer :: nIons !! Total number of atoms in system integer :: numOfTypes !! Number of different types of atoms integer :: nProjs !! Number of projectors integer :: numOfGvecs !! Number of G vectors !integer :: fftxMax, fftxMin, fftyMax, fftyMin, fftzMax, fftzMin !! FFT grid was read from `input` file but not used, so removed integer :: nBands !! Number of bands integer :: nSpins !! Number of spins integer , allocatable :: npws (:) !! Number of plane waves per k point integer , allocatable :: atomTypeIndex (:) !! Index of the given atom type !integer, allocatable :: groundState(:) ! Was read from `input` file but not used, so removed ! real ( kind = dp ) :: omega !! Cell volume !real(kind = dp) :: at(3,3) ! Was read from `input` file but not used, so removed real ( kind = dp ) :: bg ( 3 , 3 ) real ( kind = dp ), allocatable :: wk (:) real ( kind = dp ), allocatable :: xk (:, :) real ( kind = dp ), allocatable :: posIon (:,:) ! complex ( kind = dp ), allocatable :: wfc (:,:) complex ( kind = dp ), allocatable :: beta (:,:) complex ( kind = dp ), allocatable :: cProj (:,:,:) complex ( kind = dp ), allocatable :: cCrossProj (:,:,:) complex ( kind = dp ), allocatable :: paw_Wfc (:,:) complex ( kind = dp ), allocatable :: pawK (:,:,:) ! character ( len = 2 ) crystalType !! 'PC' for pristine crystal and 'SD' for solid defect character ( len = 200 ) :: exportDir !! Export directory from [[pw_export_for_tme(program)]] ! TYPE ( atom ), allocatable :: atoms (:) ! !    integer :: Jmax, maxL, iTypes, nn, nm !    integer :: i, j, n1, n2, n3, n4, n, id !    ! !    ! !    real(kind = dp), allocatable :: eigvI(:), eigvF(:) !    real(kind = dp), allocatable :: DE(:,:), absVfi2(:,:) !    ! !    complex(kind = dp), allocatable :: Ufi(:,:,:) !    ! !    integer, allocatable :: igvs(:,:,:), pwGvecs(:,:), iqs(:) !    integer, allocatable :: pwGs(:,:), nIs(:,:), nFs(:,:), ngs(:,:) ! end type crystal","tags":"","loc":"type/crystal.html","title":"crystal – Carrier Cross Sections "},{"text":"type, public :: vec Contents Variables ind igN igM Source Code vec Components Type Visibility Attributes Name Initial integer, public :: ind integer, public, allocatable :: igN (:) integer, public, allocatable :: igM (:) Source Code type :: vec ! integer :: ind integer , allocatable :: igN (:) integer , allocatable :: igM (:) end type vec","tags":"","loc":"type/vec.html","title":"vec – Carrier Cross Sections "},{"text":"public subroutine write_restart_wfc(iuni, exportDir, ik, nk, kunit, ispin, nspin, scal, wf0, t0, wfm, tm, ngw, gamma_only, nbnd, igl, ngwl) Uses mp_wave mp mp_pools mp_world io_global iotk_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: iuni character(len=256), intent(in) :: exportDir integer, intent(in) :: ik integer, intent(in) :: nk integer, intent(in) :: kunit integer, intent(in) :: ispin integer, intent(in) :: nspin real(kind=DP), intent(in) :: scal complex(kind=DP), intent(in) :: wf0 (:,:) logical, intent(in) :: t0 complex(kind=DP), intent(in) :: wfm (:,:) logical, intent(in) :: tm integer, intent(in) :: ngw logical, intent(in) :: gamma_only integer, intent(in) :: nbnd integer, intent(in) :: igl (:) integer, intent(in) :: ngwl Contents Variables i j ierr idum nkl nkr nkbl iks ike nkt ikt igwx ig npool ipmask ipsour wtmp igltot section_name twrite ierr_iotk attr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: ierr integer, public :: idum = 0 integer, public :: nkl integer, public :: nkr integer, public :: nkbl integer, public :: iks integer, public :: ike integer, public :: nkt integer, public :: ikt integer, public :: igwx integer, public :: ig integer, public :: npool integer, public :: ipmask (nproc) integer, public :: ipsour complex(kind=DP), public, ALLOCATABLE :: wtmp (:) integer, public, ALLOCATABLE :: igltot (:) character(len=20), public :: section_name = 'wfc' logical, public :: twrite = .true. integer, public :: ierr_iotk character(len=iotk_attlenx), public :: attr","tags":"","loc":"proc/write_restart_wfc.html","title":"write_restart_wfc – Carrier Cross Sections"},{"text":"subroutine write_export(pp_file, exportDir, kunit) Uses iotk_module kinds pwcom start_k control_flags global_version becmod uspp wavefunctions_module io_files io_files io_base_export io_global ions_base mp_pools mp mp_world upf_module pseudo_types radial_grids wvfct paw_variables paw_onecenter paw_symmetry uspp_param uspp scf Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: pp_file character(len=256), intent(in) :: exportDir integer, intent(in) :: kunit Contents Variables fmt_name fmt_version i j k ig ik ibnd na ngg ig_ ierr kisort xyz tmp npool nkbl nkl nkr npwx_g im ink inb ms ike iks npw_g ispin local_pw ngk_g itmp_g rtmp_g rtmp_gg itmp1 igwk l2g_new igk_l2g text wfc_scal twf0 twfm file_exists attr upf grid nnTyp groundState Source Code write_export Variables Type Visibility Attributes Name Initial character(len=5), public, parameter :: fmt_name = \"QEXPT\" character(len=5), public, parameter :: fmt_version = \"1.1.0\" integer, public :: i integer, public :: j integer, public :: k integer, public :: ig integer, public :: ik integer, public :: ibnd integer, public :: na integer, public :: ngg integer, public :: ig_ integer, public :: ierr integer, public, ALLOCATABLE :: kisort (:) real(kind=DP), public :: xyz (3) real(kind=DP), public :: tmp (3) integer, public :: npool integer, public :: nkbl integer, public :: nkl integer, public :: nkr integer, public :: npwx_g integer, public :: im integer, public :: ink integer, public :: inb integer, public :: ms integer, public :: ike integer, public :: iks integer, public :: npw_g integer, public :: ispin integer, public :: local_pw integer, public, ALLOCATABLE :: ngk_g (:) integer, public, ALLOCATABLE :: itmp_g (:,:) real(kind=DP), public, ALLOCATABLE :: rtmp_g (:,:) real(kind=DP), public, ALLOCATABLE :: rtmp_gg (:) integer, public, ALLOCATABLE :: itmp1 (:) integer, public, ALLOCATABLE :: igwk (:,:) integer, public, ALLOCATABLE :: l2g_new (:) integer, public, ALLOCATABLE :: igk_l2g (:,:) character(len=300), public :: text real(kind=DP), public :: wfc_scal logical, public :: twf0 logical, public :: twfm logical, public :: file_exists character(len=iotk_attlenx), public :: attr type(pseudo_upf), public :: upf type(radial_grid_type), public :: grid integer, public, allocatable :: nnTyp (:) integer, public, allocatable :: groundState (:) Source Code SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export","tags":"","loc":"proc/write_export.html","title":"write_export – Carrier Cross Sections"},{"text":"public function wasRead(inputVal, variableName, usage, abortExecution) Determine if an input variable still has the default value.\n If it does, output an error message and possibly set the program\n to abort. Not all variables would cause the program to abort,\n so this program assumes that if you pass in the logical abortExecution then the variable is required and causes the program to abort \n if missing. I could not find a clean way to allow this function to receive\n different types of variables (integer, real, character, etc.), so\n I made the argument be an integer so that each type could be sent\n in a different way. Each case is set up so that the value is tested to\n see if it is less than zero to determine if the variable still has\n its default value For strings, the default value is '' , so pass in LEN(trim(variable))-1 as this should be less than zero if\n the string still has the default value and greater than or equal \n to zero otherwise For integers the default values are less than zero, so just pass as is Real variables also have a negative default value, so just pass the\n value cast from real to integer Default return value is true If the input variable still has the default value output an error message set the program to abort if that variable was sent in set the return value to false to indicate that the \n  variable wasn't read Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputVal Value to compare with 0 to see if a variable has been read; character(len=*), intent(in) :: variableName Name of the variable used in output message character(len=*), intent(in) :: usage Example of how the variable can be used logical, intent(inout), optional :: abortExecution Optional logical for if the program should be aborted Return Value logical Whether or not the input variable was read from the input file;\n this is the return value Walkthrough Contents Source Code wasRead Source Code function wasRead ( inputVal , variableName , usage , abortExecution ) !! Determine if an input variable still has the default value. !! If it does, output an error message and possibly set the program !! to abort. Not all variables would cause the program to abort, !! so this program assumes that if you pass in the logical `abortExecution` !! then the variable is required and causes the program to abort !! if missing. !! !! I could not find a clean way to allow this function to receive !! different types of variables (integer, real, character, etc.), so !! I made the argument be an integer so that each type could be sent !! in a different way. Each case is set up so that the value is tested to !! see if it is less than zero to determine if the variable still has !! its default value !! !! * For strings, the default value is `''`, so pass in !! `LEN(trim(variable))-1` as this should be less than zero if !! the string still has the default value and greater than or equal !! to zero otherwise !! * For integers the default values are less than zero, so just pass as is !! * Real variables also have a negative default value, so just pass the !! value cast from real to integer !! implicit none ! integer , intent ( in ) :: inputVal !! Value to compare with 0 to see if a variable has been read; ! character ( len =* ), intent ( in ) :: variableName !! Name of the variable used in output message character ( len =* ), intent ( in ) :: usage !! Example of how the variable can be used ! logical , optional , intent ( inout ) :: abortExecution !! Optional logical for if the program should be aborted logical :: wasRead !! Whether or not the input variable was read from the input file; !! this is the return value ! !! <h2>Walkthrough</h2> !! wasRead = . true . !! * Default return value is true ! if ( inputVal < 0 ) then !! * If the input variable still has the default value !!    * output an error message !!    * set the program to abort if that variable was sent in !!    * set the return value to false to indicate that the !!      variable wasn't read ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"\", a, \"\"\" is not defined!\")' ) variableName write ( iostd , '(\" usage : \", a)' ) usage if ( present ( abortExecution )) then ! write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! wasRead = . false . ! endif ! return ! end function wasRead","tags":"","loc":"proc/wasread.html","title":"wasRead – Carrier Cross Sections"},{"text":"public subroutine initializeCalculation(solidDefect, pristineCrystal, elementsPath, VfisOutput, ki, kf, eBin, iBandIinit, iBandIfinal, iBandFinit, iBandFfinal, calculateVfis, t0) Initialize the calculation by starting timer,\n setting start values for variables to be read from .in file, removing any existing output in the output directory,\n and opening a clean output file Walkthrough Start a timer Check if file output exists,\n and delete it if it does Open new output file Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: solidDefect type( crystal ), intent(inout) :: pristineCrystal character(len=300), intent(out) :: elementsPath character(len=200), intent(out) :: VfisOutput integer, intent(out) :: ki integer, intent(out) :: kf real(kind=dp), intent(out) :: eBin integer, intent(out) :: iBandIinit integer, intent(out) :: iBandIfinal integer, intent(out) :: iBandFinit integer, intent(out) :: iBandFfinal logical, intent(out) :: calculateVfis real(kind=dp), intent(out) :: t0 Contents Variables fileExists Source Code initializeCalculation Variables Type Visibility Attributes Name Initial logical, public :: fileExists Whether or not the output file already exists Source Code subroutine initializeCalculation ( solidDefect , pristineCrystal , elementsPath , VFisOutput , ki , kf , eBin , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , calculateVFis , t0 ) !! Initialize the calculation by starting timer, !! setting start values for variables to be read from !! `.in` file, removing any existing output in the output directory, !! and opening a clean output file !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( out ) :: ki , kf , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! real ( kind = dp ), intent ( out ) :: eBin , t0 ! character ( len = 200 ), intent ( out ) :: VfisOutput character ( len = 300 ), intent ( out ) :: elementsPath ! logical , intent ( out ) :: calculateVfis logical :: fileExists !! Whether or not the output file already exists TYPE ( crystal ), intent ( inout ) :: solidDefect , pristineCrystal ! solidDefect % exportDir = '' perfectCrystal % exportDir = '' elementsPath = '' VfisOutput = '' ! ki = - 1 kf = - 1 ! eBin = - 1.0_dp ! iBandIinit = - 1 iBandIfinal = - 1 iBandFinit = - 1 iBandFfinal = - 1 ! calculateVfis = . false . ! perfectCrystal % crystalType = 'PC' solidDefect % crystalType = 'SD' ! call cpu_time ( t0 ) !! * Start a timer ! inquire ( file = output , exist = fileExists ) !! * Check if file output exists, if ( fileExists ) then !! and delete it if it does open ( unit = 11 , file = output , status = \"old\" ) close ( unit = 11 , status = \"delete\" ) endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! return ! end subroutine initializeCalculation","tags":"","loc":"proc/initializecalculation.html","title":"initializeCalculation – Carrier Cross Sections"},{"text":"public subroutine readInput(perfectCrystal, solidDefect, elementsPath, iBandIinit, iBandIfinal, iBandFinit, iBandFfinal, ki, kf, calculateVfis, VfisOutput) Delete any previous output, initialize input variables,\n start a timer, and read in the input files Used to group the variables read in from the .in file Read input from command line (or input file if use < TME_Input.md ) Check that all required variables were input and have values that make sense Read perfect crystal inputs Read solid defect inputs Calculate the number of plane waves as the maximum of the number of PC and SD plane waves Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: perfectCrystal Holds all of the information on the perfect crystal type( crystal ), intent(inout) :: solidDefect Holds all of the information on the defective crystal character(len=300), intent(inout) :: elementsPath integer, intent(inout) :: iBandIinit integer, intent(inout) :: iBandIfinal integer, intent(inout) :: iBandFinit integer, intent(inout) :: iBandFfinal integer, intent(inout) :: ki integer, intent(inout) :: kf logical, intent(inout) :: calculateVfis character(len=200), intent(inout) :: VfisOutput Contents Variables exportDirSD exportDirPC Source Code readInput Variables Type Visibility Attributes Name Initial character(len=200), public :: exportDirSD character(len=200), public :: exportDirPC Source Code subroutine readInput ( perfectCrystal , solidDefect , elementsPath , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput ) !! Delete any previous output, initialize input variables, !! start a timer, and read in the input files !! implicit none ! integer , intent ( inout ) :: ki , kf , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal ! character ( len = 300 ), intent ( inout ) :: elementsPath character ( len = 200 ), intent ( inout ) :: VfisOutput character ( len = 200 ) :: exportDirSD character ( len = 200 ) :: exportDirPC ! logical , intent ( inout ) :: calculateVfis ! TYPE ( crystal ), intent ( inout ) :: perfectCrystal !! Holds all of the information on the perfect crystal TYPE ( crystal ), intent ( inout ) :: solidDefect !! Holds all of the information on the defective crystal ! NAMELIST / TME_Input / exportDirSD , exportDirPC , elementsPath , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput , eBin !! Used to group the variables read in from the .in file ! ! READ ( 5 , TME_Input , iostat = ios ) !! * Read input from command line (or input file if use `< TME_Input.md`) solidDefect % exportDir = exportDirSD perfectCrystal % exportDir = exportDirPC ! call checkInitialization () !! * Check that all required variables were input and have values that make sense ! call readQEExport ( perfectCrystal ) !! * Read perfect crystal inputs call readQEExport ( solidDefect ) !! * Read solid defect inputs ! numOfPWs = max ( perfectCrystal % numOfPWs , solidDefect % numOfPWs ) !! * Calculate the number of plane waves as the maximum of the number of PC and SD plane waves ! return ! end subroutine readInput","tags":"","loc":"proc/readinput.html","title":"readInput – Carrier Cross Sections"},{"text":"public subroutine checkInitialization() Check to see if variables from .in file still\n have the values set in initializeCalculation or if they have values that aren't allowed Walkthrough Todo Change checkInitialization() to have arguments to make clear that these variables are getting changed Set the default value of abort execution so that the program\n will only abort if there is an issue with the inputs Write out a header to the output file If the SD export directory variable was read Check if the SD export directory exists If the SD export directory doesn't exist Output an error message and set abortExecution to true Output the given SD export directory If the PC export directory variable was read Check if the PC export directory exists If the PC export directory doesn't exist Output an error message and set abortExecution to true Output the given PC export directory If the elements path was not read, set the default value to ./ Check if the elements path folder exists already If the elements path folder doesn't already exist Write the mkdir command to a string Execute the command to create the directory Output the elements path If iBandIinit was read, output its value If iBandIfinal was read, output its value If iBandFinit was read, output its value If iBandFfinal was read, output its value If calculateVfis is true and iBandFinit and iBandFfinal are not equal Output an error message and set abortExecution to true Output the value of calculateVfis If the VfisOutput file name is blank Output a warning message and set the default value to VfisVsE Output the value of VfisOutput Todo Remove everything with ki and kf because never used If the value of eBin was not read Output a warning message and set the default value to 0.01 eV Output the value of eBin Convert eBin from eV to Hartree If abortExecution was ever set to true Output an error message and stop the program Make the output file available for other processes Arguments None Contents Variables fileExists abortExecution Source Code checkInitialization Variables Type Visibility Attributes Name Initial logical, public :: fileExists Whether or not the exported directory from pw_export_for_TME exists logical, public :: abortExecution Source Code subroutine checkInitialization () !! Check to see if variables from .in file still !! have the values set in [[TMEModule(module):initializeCalculation(subroutine)]] !! or if they have values that aren't allowed !! !! <h2>Walkthrough</h2> !! !! @todo Change `checkInitialization()` to have arguments to make clear that these variables are getting changed @endtodo !! implicit none ! logical :: fileExists !! Whether or not the exported directory from [[pw_export_for_TME(program)]] !! exists logical :: abortExecution ! abortExecution = . false . !! * Set the default value of abort execution so that the program !! will only abort if there is an issue with the inputs ! write ( iostd , '(\" Inputs : \")' ) !! * Write out a header to the output file ! if ( wasRead ( LEN ( trim ( solidDefect % exportDir )) - 1 , 'exportDirSD' , 'exportDirSD = ''./Export/''' , abortExecution ) ) then !! * If the SD export directory variable was read !!    * Check if the SD export directory exists !!    * If the SD export directory doesn't exist !!       * Output an error message and set `abortExecution` to true !!    * Output the given SD export directory ! inquire ( file = trim ( solidDefect % exportDir ), exist = fileExists ) ! if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" exportDirSD :\", a, \" does not exist !\")' ) trim ( solidDefect % exportDir ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"exportDirSD = ''\", a, \"''\")' ) trim ( solidDefect % exportDir ) ! endif ! ! if ( wasRead ( LEN ( trim ( perfectCrystal % exportDir )) - 1 , 'exportDirPC' , 'exportDirPC = ''./Export/''' , abortExecution ) ) then !! * If the PC export directory variable was read !!    * Check if the PC export directory exists !!    * If the PC export directory doesn't exist !!       * Output an error message and set `abortExecution` to true !!    * Output the given PC export directory ! inquire ( file = trim ( perfectCrystal % exportDir ), exist = fileExists ) ! if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" exportDirPC :\", a, \" does not exist !\")' ) trim ( perfectCrystal % exportDir ) write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"exportDirPC = ''\", a, \"''\")' ) trim ( perfectCrystal % exportDir ) ! endif ! if ( . not . wasRead ( LEN ( elementsPath ) - 1 , 'elementsPath' , 'elementsPath = ''./''' ) ) then !! * If the elements path was not read, set the default value to `./` ! write ( iostd , '(\" The current directory will be used as elementsPath.\")' ) elementsPath = './' ! endif ! inquire ( file = trim ( elementsPath ), exist = fileExists ) !! * Check if the elements path folder exists already ! if ( . not . fileExists ) then !! * If the elements path folder doesn't already exist !!    * Write the `mkdir` command to a string !!    * Execute the command to create the directory ! write ( mkDir , '(\"mkdir -p \", a)' ) trim ( elementsPath ) ! call system ( mkDir ) ! endif ! write ( iostd , '(\"elementsPath = ''\", a, \"''\")' ) trim ( elementsPath ) !! * Output the elements path ! if ( wasRead ( iBandIinit , 'iBandIinit' , 'iBandIinit = 10' , abortExecution ) ) then !! * If `iBandIinit` was read, output its value ! write ( iostd , '(\"iBandIinit = \", i4)' ) iBandIinit ! endif ! if ( wasRead ( iBandIfinal , 'iBandIfinal' , 'iBandIfinal = 20' , abortExecution ) ) then !! * If `iBandIfinal` was read, output its value ! write ( iostd , '(\"iBandIfinal = \", i4)' ) iBandIfinal ! endif ! if ( wasRead ( iBandFinit , 'iBandFinit' , 'iBandFinit = 9' , abortExecution ) ) then !! * If `iBandFinit` was read, output its value ! write ( iostd , '(\"iBandFinit = \", i4)' ) iBandFinit ! endif ! if ( wasRead ( iBandFfinal , 'iBandFfinal' , 'iBandFfinal = 9' , abortExecution ) ) then !! * If `iBandFfinal` was read, output its value ! write ( iostd , '(\"iBandFfinal = \", i4)' ) iBandFfinal ! endif ! !> * If `calculateVfis` is true and `iBandFinit` and `iBandFfinal` are not equal !>    * Output an error message and set `abortExecution` to true if ( ( calculateVfis ) . and . ( iBandFinit /= iBandFfinal ) ) then ! write ( iostd , * ) write ( iostd , '(\" Vfis can be calculated only if the final state is one and only one!\")' ) write ( iostd , '(\" ''iBandFInit'' = \", i10)' ) iBandFinit write ( iostd , '(\" ''iBandFfinal'' = \", i10)' ) iBandFfinal write ( iostd , '(\" This variable is mandatory and thus the program will not be executed!\")' ) abortExecution = . true . ! endif ! write ( iostd , '(\"calculateVfis = \", l )' ) calculateVfis !! * Output the value of `calculateVfis` ! !> * If the `VfisOutput` file name is blank !>    * Output a warning message and set the default value to `VfisVsE` if ( trim ( VfisOutput ) == '' ) then ! write ( iostd , * ) write ( iostd , '(\" Variable : \"\"VfisOutput\"\" is not defined!\")' ) write ( iostd , '(\" usage : VfisOutput = ''VfisVsE''\")' ) write ( iostd , '(\" The default value ''VfisVsE'' will be used.\")' ) VfisOutput = 'VfisVsE' ! endif ! write ( iostd , '(\"VfisOutput = ''\", a, \"''\")' ) trim ( VfisOutput ) !! * Output the value of `VfisOutput` !> @todo Remove everything with `ki` and `kf` because never used @endtodo ! !if( .not. wasRead(ki, 'ki', 'ki = 1') ) then !  !! * If `ki` wasn't read, set the default value to 1 !  ! !  write(iostd, '(\" ki = 1 will be used.\")') !  ki = 1 !  ! !endif ! !if( .not. wasRead(kf, 'kf', 'kf = 1') ) then !  !! * If `kf` wasn't read, set the default value to the total !  !!   number of k points (actually done in [[TMEModeul(module):readQEInput(subroutine)]] !  !!   where the total number of k points is read !  ! !  write(iostd, '(\" kf = total number of k-points will be used.\")') !  ! !endif ! !if ( ki /= kf ) then !  write(iostd, *) !  write(iostd, '(\" Initial k-point index ''ki'', should be equal to the Final k-point index ''kf'' !\")') !  write(iostd, '(\" Calculation of transition matrix elements with momentum transfer is not implemented!\")') !  write(iostd, '(\" This variable is mandatory and thus the program will not be executed!\")') !  abortExecution = .true. !endif ! if ( . not . wasRead ( INT ( eBin ), 'eBin' , 'eBin = 0.01' ) ) then !! * If the value of `eBin` was not read !!    * Output a warning message and set the default value to 0.01 eV ! write ( iostd , '(\" A default value of 0.01 eV will be used !\")' ) eBin = 0.01_dp ! eV ! endif ! write ( iostd , '(\"eBin = \", f8.4, \" (eV)\")' ) eBin !! * Output the value of eBin ! eBin = eBin * evToHartree !! * Convert `eBin` from eV to Hartree ! if ( abortExecution ) then !! * If `abortExecution` was ever set to true !!    * Output an error message and stop the program write ( iostd , '(\" Program stops!\")' ) stop endif ! flush ( iostd ) !! * Make the output file available for other processes ! return ! end subroutine checkInitialization","tags":"","loc":"proc/checkinitialization.html","title":"checkInitialization – Carrier Cross Sections"},{"text":"public subroutine readQEExport(system) Read input files in the Export directory created by pw_export_for_TME Walkthrough Start a local timer Output header to output file based on the input crystal type Note The program will end if a crystal type other than PC or SD is used. Set the path for the input file from the PC export directory Check if the input file from the PC export directory exists If the input file doesn't exist Output an error message and end the program Open and read the input file Calculate F , F1 , and F2 using the all-electron and psuedowvefunctions Todo Look more into how AE and PS wavefunctions are combined to further understand this Todo Move this behavior to another subroutine for clarity Todo Figure out if differences in PC and SD F1 calculations are intentional Todo Figure out if should be (wae_i wae_j - wps_i wps_j)r_{ab} Todo Figure out if first term in each should be conjugated for inner product form Todo Figure out if rab plays role of dr within augmentation sphere Close the input file Go through the projAngMom values for each projector for each atom\n and find the max to store in JMAX Todo Figure out if intentional to only use JMAX from SD input End the local timer and write out the total time to read the inputs\n to the output file Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect Contents Variables i ik iType ni iRAugMax l ind iDum t1 t2 ef textDum input fileExists Source Code readQEExport Variables Type Visibility Attributes Name Initial integer, public :: i Loop index integer, public :: ik Loop index integer, public :: iType Loop index integer, public :: ni Loop index integer, public :: iRAugMax Local value of iRAugMax for each atom so don't have to keep accessing in loop integer, public :: l Angular momentum of each projector read from input file integer, public :: ind Index of each projector read from input file integer, public :: iDum Dummy variable to hold trash from input file real(kind=dp), public :: t1 Local start time real(kind=dp), public :: t2 Local end time real(kind=dp), public :: ef character(len=300), public :: textDum Dummy variable to hold trash from input file character(len=300), public :: input The input file path logical, public :: fileExists Whether or not the input file exists in the given \n Export directory Source Code subroutine readQEExport ( system ) !! Read input files in the Export directory created by !! [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! ! implicit none ! !integer, intent(in) :: id ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect` ! integer :: i , ik , iType , ni !! Loop index integer :: iRAugMax !! Local value of `iRAugMax` for each atom so don't have to keep accessing in loop integer :: l !! Angular momentum of each projector read from input file integer :: ind !! Index of each projector read from input file integer :: iDum !! Dummy variable to hold trash from input file ! real ( kind = dp ) :: t1 !! Local start time real ( kind = dp ) :: t2 !! Local end time real ( kind = dp ) :: ef ! character ( len = 300 ) :: textDum !! Dummy variable to hold trash from input file character ( len = 300 ) :: input !! The input file path ! logical :: fileExists !! Whether or not the `input` file exists in the given !! Export directory ! call cpu_time ( t1 ) !! * Start a local timer ! !> * Output header to output file based on the input crystal type !> @note !> The program will end if a crystal type other than `PC` or `SD` is used. !> @endnote write ( iostd , * ) if ( system % crystalType == 'PC' ) then ! write ( iostd , '(\" Reading perfect crystal inputs.\")' ) ! else if ( system % crystalType == 'SD' ) then ! write ( iostd , '(\" Reading solid defect inputs.\")' ) ! else ! write ( iostd , '(\"Unknown crystal type\", a, \".\")' ) system % crystalType write ( iostd , '(\"Please only use PC for pristine crystal or SD for solid defect.\")' ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! write ( iostd , * ) ! input = trim ( trim ( system % exportDir ) // '/input' ) !! * Set the path for the input file from the PC export directory ! inquire ( file = trim ( input ), exist = fileExists ) !! * Check if the input file from the PC export directory exists ! !> * If the input file doesn't exist !>    * Output an error message and end the program if ( fileExists . eqv . . false . ) then ! write ( iostd , '(\" File : \", a, \" , does not exist!\")' ) trim ( input ) write ( iostd , '(\" Please make sure that folder : \", a, \" has been created successfully !\")' ) trim ( system % exportDir ) write ( iostd , '(\" Program stops!\")' ) flush ( iostd ) stop ! endif ! !............................................................................................... !> * Open and read the [input](../page/inputOutput/exportedInput.html) file ! open ( 50 , file = trim ( input ), status = 'old' ) ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(ES24.15E3)' ) system % omega ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % nKpts !if ( kf < 0 ) kf = system%nKpts ! read ( 50 , '(a)' ) textDum ! allocate ( system % npws ( system % nKpts ), system % wk ( system % nKpts ), system % xk ( 3 , system % nKpts ) ) ! !allocate( system%groundState(system%nKpts) ) ! Don't allocate space for groundState because it is never used ! do ik = 1 , system % nKpts ! !read(50, '(3i10,4ES24.15E3)') iDum, system%groundState(ik), system%npws(ik), system%wk(ik), system%xk(1:3,ik) ! Don't read in groundState because it is never used read ( 50 , '(3i10,4ES24.15E3)' ) iDum , iDum , system % npws ( ik ), system % wk ( ik ), system % xk ( 1 : 3 , ik ) ! enddo ! read ( 50 , '(a)' ) textDum ! read ( 50 , * ) system % numOfGvecs ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % numOfPWs ! read ( 50 , '(a)' ) textDum ! !read(50, '(6i10)') fftxMin, fftxMax, fftyMin, fftyMax, fftzMin, fftzMax ! Don't read in FFT grid because it is never used read ( 50 , * ) ! read ( 50 , '(a)' ) textDum ! !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,1) !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,2) !read(50, '(a5, 3ES24.15E3)') textDum, at(1:3,3) ! Don't read in `at` because it is never used read ( 50 , * ) read ( 50 , * ) read ( 50 , * ) ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 1 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 2 ) read ( 50 , '(a5, 3ES24.15E3)' ) textDum , system % bg ( 1 : 3 , 3 ) ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % nIons ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % numOfTypes ! allocate ( system % posIon ( 3 , system % nIons ), system % atomTypeIndex ( system % nIons ) ) ! read ( 50 , '(a)' ) textDum ! do ni = 1 , system % nIons ! read ( 50 , '(i10, 3ES24.15E3)' ) system % atomTypeIndex ( ni ), system % posIon ( 1 : 3 , ni ) ! enddo ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(i10)' ) system % nBands ! read ( 50 , '(a)' ) textDum ! read ( 50 , '(i10)' ) system % nSpins ! allocate ( system % atoms ( system % numOfTypes ) ) ! system % nProjs = 0 ! do iType = 1 , system % numOfTypes ! read ( 50 , '(a)' ) textDum read ( 50 , * ) system % atoms ( iType )% symbol ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% numOfAtoms ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% numProjs ! number of projectors ! allocate ( system % atoms ( iType )% projAngMom ( system % atoms ( iType )% numProjs ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , system % atoms ( iType )% numProjs ! read ( 50 , '(2i10)' ) l , ind system % atoms ( iType )% projAngMom ( ind ) = l ! enddo ! read ( 50 , '(a)' ) textDum read ( 50 , '(i10)' ) system % atoms ( iType )% lmMax ! read ( 50 , '(a)' ) textDum read ( 50 , '(2i10)' ) system % atoms ( iType )% nMax , system % atoms ( iType )% iRAugMax ! allocate ( system % atoms ( iType )% r ( system % atoms ( iType )% nMax ), system % atoms ( iType )% rab ( system % atoms ( iType )% nMax ) ) ! read ( 50 , '(a)' ) textDum do i = 1 , system % atoms ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) system % atoms ( iType )% r ( i ), system % atoms ( iType )% rab ( i ) ! enddo ! allocate ( system % atoms ( iType )% wae ( system % atoms ( iType )% nMax , system % atoms ( iType )% numProjs ) ) allocate ( system % atoms ( iType )% wps ( system % atoms ( iType )% nMax , system % atoms ( iType )% numProjs ) ) ! read ( 50 , '(a)' ) textDum do j = 1 , system % atoms ( iType )% numProjs do i = 1 , system % atoms ( iType )% nMax ! read ( 50 , '(2ES24.15E3)' ) system % atoms ( iType )% wae ( i , j ), system % atoms ( iType )% wps ( i , j ) ! write(iostd, '(2i5, ES24.15E3)') j, i, abs(system%atoms(iType)%wae(i, j)-system%atoms(iType)%wps(i, j)) ! enddo enddo ! allocate ( system % atoms ( iType )% F ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs ) ) !, system%atoms(iType)%numProjs) ) allocate ( system % atoms ( iType )% F1 ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs , system % atoms ( iType )% numProjs ) ) allocate ( system % atoms ( iType )% F2 ( system % atoms ( iType )% iRAugMax , system % atoms ( iType )% numProjs , system % atoms ( iType )% numProjs ) ) ! system % atoms ( iType )% F = 0.0_dp system % atoms ( iType )% F1 = 0.0_dp system % atoms ( iType )% F2 = 0.0_dp ! !> * Calculate `F`, `F1`, and `F2` using the all-electron and psuedowvefunctions !> @todo Look more into how AE and PS wavefunctions are combined to further understand this @endtodo !> @todo Move this behavior to another subroutine for clarity @endtodo do j = 1 , system % atoms ( iType )% numProjs ! iRAugMax = system % atoms ( iType )% iRAugMax ! system % atoms ( iType )% F ( 1 : iRAugMax , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% r ( 1 : iRAugMax ) * system % atoms ( iType )% rab ( 1 : iRAugMax ) ! do i = 1 , system % atoms ( iType )% numProjs !> @todo Figure out if differences in PC and SD `F1` calculations are intentional @endtodo !> @todo Figure out if should be `(wae_i wae_j - wps_i wps_j)r_{ab}` @endtodo !> @todo Figure out if first term in each should be conjugated for inner product form @endtodo !> @todo Figure out if `rab` plays role of dr within augmentation sphere @endtodo if ( system % crystalType == 'PC' ) then ! system % atoms ( iType )% F1 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) ! else if ( system % crystalType == 'SD' ) then ! system % atoms ( iType )% F1 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) ! endif ! system % atoms ( iType )% F2 ( 1 : iRAugMax , i , j ) = ( system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wae ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j ) - & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wae ( 1 : iRAugMax , j ) + & system % atoms ( iType )% wps ( 1 : iRAugMax , i ) * system % atoms ( iType )% wps ( 1 : iRAugMax , j )) * & system % atoms ( iType )% rab ( 1 : iRAugMax ) enddo enddo ! system % nProjs = system % nProjs + system % atoms ( iType )% numOfAtoms * system % atoms ( iType )% lmMax ! deallocate ( system % atoms ( iType )% wae , system % atoms ( iType )% wps ) !deallocate ( system%groundState ) ! Don't use because groundState is never used ! enddo ! !............................................................................................... ! close ( 50 ) !! * Close the input file ! !> * Go through the `projAngMom` values for each projector for each atom !> and find the max to store in `JMAX` !> @todo Figure out if intentional to only use `JMAX` from SD input @endtodo JMAX = 0 do iType = 1 , system % numOfTypes ! do i = 1 , system % atoms ( iType )% numProjs ! if ( system % atoms ( iType )% projAngMom ( i ) > JMAX ) JMAX = system % atoms ( iType )% projAngMom ( i ) ! enddo ! enddo ! maxL = JMAX JMAX = 2 * JMAX + 1 ! do iType = 1 , system % numOfTypes ! allocate ( system % atoms ( iType )% bes_J_qr ( 0 : JMAX , system % atoms ( iType )% iRAugMax ) ) system % atoms ( iType )% bes_J_qr (:,:) = 0.0_dp ! enddo ! !> * End the local timer and write out the total time to read the inputs !> to the output file call cpu_time ( t2 ) write ( iostd , '(\" Reading input files done in:                \", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , * ) flush ( iostd ) ! return ! end subroutine readQEExport","tags":"","loc":"proc/readqeexport.html","title":"readQEExport – Carrier Cross Sections"},{"text":"public subroutine readPWsSet() Read the g vectors in Miller indices from mgrid file and convert\n using reciprocal lattice vectors Walkthrough Open the mgrid file from Export directory from pw_export_for_TME Ignore the first two lines as they are comments Allocate space for the g vectors Initialize all of the g vectors to zero For each g vector Read in the g vector in terms of Miller indices Calculate the g vector using the reciprocal lattice vectors from input file\n Close the mgrid file Arguments None Contents Variables ig iDum iGx iGy iGz Source Code readPWsSet Variables Type Visibility Attributes Name Initial integer, public :: ig integer, public :: iDum integer, public :: iGx integer, public :: iGy integer, public :: iGz Source Code subroutine readPWsSet () !! Read the g vectors in Miller indices from `mgrid` file and convert !! using reciprocal lattice vectors !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer :: ig , iDum , iGx , iGy , iGz ! open ( 72 , file = trim ( solidDefect % exportDir ) // \"/mgrid\" ) !! * Open the `mgrid` file from Export directory from [[pw_export_for_tme(program)]] ! !> * Ignore the first two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( gvecs ( 3 , solidDefect % numOfGvecs ) ) !! * Allocate space for the g vectors ! gvecs (:,:) = 0.0_dp !! * Initialize all of the g vectors to zero ! do ig = 1 , solidDefect % numOfGvecs !! * For each g vector !!    * Read in the g vector in terms of Miller indices !!    * Calculate the g vector using the reciprocal lattice vectors from input file read ( 72 , '(4i10)' ) iDum , iGx , iGy , iGz gvecs ( 1 , ig ) = dble ( iGx ) * solidDefect % bg ( 1 , 1 ) + dble ( iGy ) * solidDefect % bg ( 1 , 2 ) + dble ( iGz ) * solidDefect % bg ( 1 , 3 ) gvecs ( 2 , ig ) = dble ( iGx ) * solidDefect % bg ( 2 , 1 ) + dble ( iGy ) * solidDefect % bg ( 2 , 2 ) + dble ( iGz ) * solidDefect % bg ( 2 , 3 ) gvecs ( 3 , ig ) = dble ( iGx ) * solidDefect % bg ( 3 , 1 ) + dble ( iGy ) * solidDefect % bg ( 3 , 2 ) + dble ( iGz ) * solidDefect % bg ( 3 , 3 ) enddo ! close ( 72 ) !! Close the `mgrid` file ! return ! end subroutine readPWsSet","tags":"","loc":"proc/readpwsset.html","title":"readPWsSet – Carrier Cross Sections"},{"text":"public subroutine distributePWsToProcs(nOfPWs, nOfBlocks) Determine how many g vectors each process should get Walkthrough Determine the base number of g vectors to give \n   to each process Determine the number of g vectors left over after that For each process, give the base amount and an extra\n   if there were any still left over Arguments Type Intent Optional Attributes Name integer, intent(in) :: nOfPWs Number of g vectors integer, intent(in) :: nOfBlocks Number of processes Contents Variables iStep iModu Source Code distributePWsToProcs Variables Type Visibility Attributes Name Initial integer, public :: iStep Number of g vectors per number of processes integer, public :: iModu Number of remaining g vectors after giving\n each process the same number of g vectors Source Code subroutine distributePWsToProcs ( nOfPWs , nOfBlocks ) !! Determine how many g vectors each process should get !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: nOfPWs !! Number of g vectors integer , intent ( in ) :: nOfBlocks !! Number of processes integer :: iStep !! Number of g vectors per number of processes integer :: iModu !! Number of remaining g vectors after giving !! each process the same number of g vectors ! iStep = int ( nOfPWs / nOfBlocks ) !! * Determine the base number of g vectors to give !!   to each process iModu = mod ( nOfPWs , nOfBlocks ) !! * Determine the number of g vectors left over after that ! do i = 0 , nOfBlocks - 1 !! * For each process, give the base amount and an extra !!   if there were any still left over counts ( i ) = iStep ! if ( iModu > 0 ) then ! counts ( i ) = counts ( i ) + 1 ! iModu = iModu - 1 ! endif ! enddo ! !displmnt(0) = 0 !do i = 1, nOfBlocks-1 !  displmnt(i) = displmnt(i-1) + counts(i) !enddo ! return ! end subroutine distributePWsToProcs","tags":"","loc":"proc/distributepwstoprocs.html","title":"distributePWsToProcs – Carrier Cross Sections"},{"text":"public subroutine checkIfCalculated(ik, tmes_file_exists) Determine if the output file for a given k point already exists Walkthrough Determine what the file name should be based on the k point index Check if that file already exists Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index logical, intent(out) :: tmes_file_exists Whether or not the output file exists Contents Variables Uelements ikstr Source Code checkIfCalculated Variables Type Visibility Attributes Name Initial character(len=300), public :: Uelements Output file name character(len=300), public :: ikstr String version of integer input ik Source Code subroutine checkIfCalculated ( ik , tmes_file_exists ) !! Determine if the output file for a given k point already exists !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index logical , intent ( out ) :: tmes_file_exists !! Whether or not the output file exists ! character ( len = 300 ) :: Uelements !! Output file name character ( len = 300 ) :: ikstr !! String version of integer input `ik` ! call int2str ( ik , ikstr ) write ( Uelements , '(\"/TMEs_kptI_\",a,\"_kptF_\",a)' ) trim ( ikstr ), trim ( ikstr ) !! * Determine what the file name should be based on the k point index ! inquire ( file = trim ( elementsPath ) // trim ( Uelements ), exist = tmes_file_exists ) !! * Check if that file already exists ! return ! end subroutine checkIfCalculated","tags":"","loc":"proc/checkifcalculated.html","title":"checkIfCalculated – Carrier Cross Sections"},{"text":"public subroutine calculatePWsOverlap(ik) Read the wavefunctions and calculate the overlap \\langle\\Phi_f|\\Psi_i\\rangle Walkthrough Read the perfect crystal wavefunction ( readWfc ) Read the solid defect wavefunction ( readWfc ) Initialize Ufi for the given k point to complex double zero For each initial band, calculate \\sum \\phi_f&#94;*\\psi_i (overlap??) with each final band Calculate \\langle\\Phi_f|\\Psi_i\\rangle Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index Contents Variables ibi ibf Source Code calculatePWsOverlap Variables Type Visibility Attributes Name Initial integer, public :: ibi Loop index integer, public :: ibf Loop index Source Code subroutine calculatePWsOverlap ( ik ) !! Read the wavefunctions and calculate the overlap !! \\langle\\Phi_f|\\Psi_i\\rangle !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ibi , ibf !! Loop index ! call readWfc ( ik , perfectCrystal ) !! * Read the perfect crystal wavefunction ([[TMEModule(module):readWfc(subroutine)]]) ! call readWfc ( ik , solidDefect ) !! * Read the solid defect wavefunction ([[TMEModule(module):readWfc(subroutine)]]) ! Ufi (:,:, ik ) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize `Ufi` for the given k point to complex double zero ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal !! * For each initial band, calculate \\sum \\phi_f&#94;*\\psi_i (overlap??) with each final band !! Ufi ( ibf , ibi , ik ) = sum ( conjg ( solidDefect % wfc (:, ibf )) * perfectCrystal % wfc (:, ibi )) !! * Calculate \\langle\\Phi_f|\\Psi_i\\rangle !! !if ( ibi == ibf ) write(iostd,'(2i4,3ES24.15E3)') ibf, ibi, Ufi(ibf, ibi, ik), abs(Ufi(ibf, ibi, ik))**2 flush ( iostd ) ! enddo ! enddo ! return ! end subroutine calculatePWsOverlap","tags":"","loc":"proc/calculatepwsoverlap.html","title":"calculatePWsOverlap – Carrier Cross Sections"},{"text":"public subroutine readWfc(ik, system) Open the grid.ki file from pw_export_for_TME to get the indices for the wavefunction to be stored in, then\n open the wfc.ki file and read in the wavefunction for the \n proper bands and store in the proper indices in the system's wfc Walkthrough Convert the k point index to a string Open the grid.ki file from pw_export_for_TME Ignore the first two lines as they are comments Allocate space for pwGind For each plane wave for a given k point, \n   read in the indices for the plane waves that \n   are held in wfc.ki Close the grid.ki file Open the wfc.ki file from pw_export_for_TME Ignore the first two lines because they are comments\n * For each band before iBandInit , ignore all of the\n   plane waves for the given k point\n * Initialize the wavefunction to complex double zero For bands between iBandIinit and iBandIfinal ,\n   read in all of the plane waves for the given k point\n   and store them in the proper index of the system's wfc Close the wfc.ki file Deallocate space for pwGind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) Contents Variables ib ig iDumV pwGind wfc ikstr Source Code readWfc Variables Type Visibility Attributes Name Initial integer, public :: ib Loop index integer, public :: ig Loop index integer, public :: iDumV (3) Dummy vector to ignore g vectors from grid.ki integer, public, allocatable :: pwGind (:) Indices for the wavefunction of a given k point complex(kind=dp), public :: wfc Wavefunction character(len=300), public :: ikstr String version of the k point index Source Code subroutine readWfc ( ik , system ) !! Open the `grid.ki` file from [[pw_export_for_tme(program)]] !! to get the indices for the wavefunction to be stored in, then !! open the `wfc.ki` file and read in the wavefunction for the !! proper bands and store in the proper indices in the system's `wfc` !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ib , ig !! Loop index integer :: iDumV ( 3 ) !! Dummy vector to ignore g vectors from `grid.ki` integer , allocatable :: pwGind (:) !! Indices for the wavefunction of a given k point ! complex ( kind = dp ) :: wfc !! Wavefunction ! character ( len = 300 ) :: ikstr !! String version of the k point index ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! open ( 72 , file = trim ( system % exportDir ) // \"/grid.\" // trim ( ikstr )) !! * Open the `grid.ki` file from [[pw_export_for_tme(program)]] ! !> * Ignore the first two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGind ( system % npws ( ik )) ) !! * Allocate space for `pwGind` ! do ig = 1 , system % npws ( ik ) !! * For each plane wave for a given k point, !!   read in the indices for the plane waves that !!   are held in `wfc.ki` ! read ( 72 , '(4i10)' ) pwGind ( ig ), iDumV ( 1 : 3 ) ! enddo ! close ( 72 ) !! * Close the `grid.ki` file ! open ( 72 , file = trim ( system % exportDir ) // \"/wfc.\" // trim ( ikstr )) !! * Open the `wfc.ki` file from [[pw_export_for_tme(program)]] ! !> Ignore the first two lines because they are comments read ( 72 , * ) read ( 72 , * ) ! do ib = 1 , iBandIinit - 1 do ig = 1 , system % npws ( ik ) !! * For each band before `iBandInit`, ignore all of the !!   plane waves for the given k point read ( 72 , * ) ! enddo enddo ! system % wfc (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize the wavefunction to complex double zero ! do ib = iBandIinit , iBandIfinal do ig = 1 , system % npws ( ik ) !! * For bands between `iBandIinit` and `iBandIfinal`, !!   read in all of the plane waves for the given k point !!   and store them in the proper index of the system's `wfc` ! read ( 72 , '(2ES24.15E3)' ) wfc system % wfc ( pwGind ( ig ), ib ) = wfc ! enddo enddo ! close ( 72 ) !! * Close the `wfc.ki` file ! deallocate ( pwGind ) !! * Deallocate space for `pwGind` ! return ! end subroutine readWfc","tags":"","loc":"proc/readwfc.html","title":"readWfc – Carrier Cross Sections"},{"text":"public subroutine readProjections(ik, system) Read in the projection \\langle\\beta|\\Psi\\rangle for each band Walkthrough Convert the k point index to a string Initialize cProj to all complex double zero Open the projections.ik file from pw_export_for_TME Ignore the first line as it is a comment Todo Get actual perfect crystal and solid defect output to test Todo Figure out if loop should be over solidDefect or perfectCrystal Todo Look into nSpins to figure out if it is needed * For each band, read in the projections \\langle\\beta|\\Psi\\rangle Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) Contents Variables i j ikstr Source Code readProjections Variables Type Visibility Attributes Name Initial integer, public :: i Loop index integer, public :: j Loop index character(len=300), public :: ikstr String version of k point index Source Code subroutine readProjections ( ik , system ) !! Read in the projection \\langle\\beta|\\Psi\\rangle for each band !! !! <H2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: i , j !! Loop index ! character ( len = 300 ) :: ikstr !! String version of k point index TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! system % cProj (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize `cProj` to all complex double zero ! open ( 72 , file = trim ( system % exportDir ) // \"/projections.\" // trim ( ikstr )) !! * Open the `projections.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) !! * Ignore the first line as it is a comment ! !write(6,'(\"Solid defect nBands: \", i3)') solidDefect%nBands !write(6,'(\"Solid defect nSpins: \", i3)') solidDefect%nSpins !write(6,'(\"Perfect crystal nBands: \", i3)') perfectCrystal%nBands !write(6,'(\"Perfect crystal nSpins: \", i3)') perfectCrystal%nSpins !! @todo Get actual perfect crystal and solid defect output to test @endtodo !! @todo Figure out if loop should be over `solidDefect` or `perfectCrystal` @endtodo !! @todo Look into `nSpins` to figure out if it is needed @endtodo do j = 1 , solidDefect % nBands ! number of bands do i = 1 , system % nProjs ! number of projections !! * For each band, read in the projections \\langle\\beta|\\Psi\\rangle ! read ( 72 , '(2ES24.15E3)' ) system % cProj ( i , j , 1 ) ! enddo enddo ! close ( 72 ) ! return ! end subroutine readProjections","tags":"","loc":"proc/readprojections.html","title":"readProjections – Carrier Cross Sections"},{"text":"public subroutine projectBeta(ik, betaSystem, projectedSystem) Todo Figure out what this subroutine really does Walkthrough Convert the k point index to a string Open the grid.ki file from pw_export_for_TME Ignore the next two lines as they are comments Allocate space for pwGind Read in the index for each plane wave Close the grid.ki file Allocate space for |\\beta\\rangle Initialize all values of |\\beta\\rangle to complex double zero Open the projectors.ki file from pw_export_for_TME Ignore the first line because it is a comment Ignore the second line because it is the number of projectors that\n   was already calculated in readQEExport and the number of plane waves for a given k point that was read in in the\n   same subroutine Read in each |\\beta\\rangle and store in the proper index of beta for the system Deallocate space for pwGind If the system that you are getting |\\beta\\rangle from \n   is the perfect crystal, then calculate \\langle\\beta|\\Phi\\rangle between iBandFinit and iBandFfinal If the system that you are getting |\\beta\\rangle from \n   is the solid defect, then calculate \\langle\\beta|\\Psi\\rangle between iBandIinit and iBandIfinal Deallocate space for |\\beta\\rangle Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: betaSystem Holds the structure for the system you are getting \\beta from\n (either perfectCrystal or solidDefect ) type( crystal ), intent(inout) :: projectedSystem Holds the structure for the system you are projecting\n (either perfectCrystal or solidDefect ) Contents Variables ig i j iDumV iDum pwGind ikstr Source Code projectBeta Variables Type Visibility Attributes Name Initial integer, public :: ig Loop index integer, public :: i Loop index integer, public :: j Loop index integer, public :: iDumV (3) Dummy variable to ignore input from file integer, public :: iDum Dummy variable to ignore input from file integer, public, allocatable :: pwGind (:) Indices for the wavefunction of a given k point character(len=300), public :: ikstr String version of the k point index Source Code subroutine projectBeta ( ik , betaSystem , projectedSystem ) !! @todo Figure out what this subroutine really does !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ig , i , j !! Loop index integer :: iDumV ( 3 ), iDum !! Dummy variable to ignore input from file integer , allocatable :: pwGind (:) !! Indices for the wavefunction of a given k point ! character ( len = 300 ) :: ikstr !! String version of the k point index ! TYPE ( crystal ), intent ( inout ) :: betaSystem !! Holds the structure for the system you are getting \\beta from !! (either `perfectCrystal` or `solidDefect`) TYPE ( crystal ), intent ( inout ) :: projectedSystem !! Holds the structure for the system you are projecting !! (either `perfectCrystal` or `solidDefect`) ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! ! Reading PC projectors ! open ( 72 , file = trim ( betaSystem % exportDir ) // \"/grid.\" // trim ( ikstr )) !! * Open the `grid.ki` file from [[pw_export_for_tme(program)]] ! !> * Ignore the next two lines as they are comments read ( 72 , * ) read ( 72 , * ) ! allocate ( pwGind ( betaSystem % npws ( ik )) ) !! * Allocate space for `pwGind` ! do ig = 1 , betaSystem % npws ( ik ) !! * Read in the index for each plane wave ! read ( 72 , '(4i10)' ) pwGind ( ig ), iDumV ( 1 : 3 ) ! enddo ! close ( 72 ) !! * Close the `grid.ki` file ! ! allocate ( betaSystem % beta ( numOfPWs , betaSystem % nProjs ) ) !! * Allocate space for |\\beta\\rangle ! betaSystem % beta (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values of |\\beta\\rangle to complex double zero ! open ( 73 , file = trim ( betaSystem % exportDir ) // \"/projectors.\" // trim ( ikstr )) !! * Open the `projectors.ki` file from [[pw_export_for_tme(program)]] ! read ( 73 , * ) !! * Ignore the first line because it is a comment read ( 73 , * ) !! * Ignore the second line because it is the number of projectors that !!   was already calculated in [[TMEModule(module):readQEExport(subroutine)]] !!   and the number of plane waves for a given k point that was read in in the !!   same subroutine ! do j = 1 , betaSystem % nProjs do i = 1 , betaSystem % npws ( ik ) !! * Read in each |\\beta\\rangle and store in the proper index of `beta` !!   for the system ! read ( 73 , '(2ES24.15E3)' ) betaSystem % beta ( pwGind ( i ), j ) ! enddo enddo ! close ( 73 ) ! deallocate ( pwGind ) !! * Deallocate space for `pwGind` ! if ( betaSystem % crystalType == \"PC\" ) then !! * If the system that you are getting |\\beta\\rangle from !!   is the perfect crystal, then calculate !!   \\langle\\beta|\\Phi\\rangle between `iBandFinit` !!   and `iBandFfinal` ! do j = iBandFinit , iBandFfinal do i = 1 , betaSystem % nProjs ! betaSystem % cCrossProj ( i , j , 1 ) = sum ( conjg ( betaSystem % beta (:, i )) * projectedSystem % wfc (:, j )) ! enddo enddo ! else if ( betaSystem % crystalType == \"SD\" ) then !! * If the system that you are getting |\\beta\\rangle from !!   is the solid defect, then calculate !!   \\langle\\beta|\\Psi\\rangle between `iBandIinit` !!   and `iBandIfinal` ! do j = iBandIinit , iBandIfinal do i = 1 , betaSystem % nProjs betaSystem % cCrossProj ( i , j , 1 ) = sum ( conjg ( betaSystem % beta (:, i )) * projectedSystem % wfc (:, j )) enddo enddo ! endif ! deallocate ( betaSystem % beta ) !! * Deallocate space for |\\beta\\rangle ! return ! end subroutine projectBeta","tags":"","loc":"proc/projectbeta.html","title":"projectBeta – Carrier Cross Sections"},{"text":"public subroutine pawCorrectionWfc(system) Calculates the augmentation part of the transition matrix element Todo Figure out what this subroutine really does Walkthrough Set the value of ispin to 1 Note ispin never has a value other than one, so I'm not sure\n  what its purpose is Initialize all values in paw_Wfc to complex double zero Initialize the base offset for cProj 's first index to zero For each atom in the system Get the index for the atom type Loop over the projectors twice, each time finding the\n  angular momentum quantum number ( l and l&#94;{\\prime} )\n  and magnetic quantum number ( m and m&#94;{\\prime} ) If l = l&#94;{\\prime} and m = m&#94;{\\prime} , loop over the bands to\n  calculate paw_Wfc Todo Figure out the significance of l = l&#94;{\\prime} and m = m&#94;{\\prime} Todo Figure out why the difference between SD and PC Todo Figure out why the difference between SD and PC Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) Contents Variables iIon iProj jProj ibi ibf m mPrime ispin LMBASE LM LMP l lPrime iAtomType atomicOverlap cProjIe cProjFe Source Code pawCorrectionWfc Variables Type Visibility Attributes Name Initial integer, public :: iIon Loop index over atoms integer, public :: iProj Loop index of projectors integer, public :: jProj Loop index of projectors integer, public :: ibi Loop index over bands integer, public :: ibf Loop index over bands integer, public :: m Loop index for magnetic quantum number for a given projector integer, public :: mPrime Loop index for magnetic quantum number for a given projector integer, public :: ispin integer, public :: LMBASE integer, public :: LM Index for cProj integer, public :: LMP Index for cProj integer, public :: l Angular momentum quantum number for a given projector integer, public :: lPrime Angular momentum quantum number for a given projector integer, public :: iAtomType Atom type index for a given ion in the system real(kind=dp), public :: atomicOverlap complex(kind=dp), public :: cProjIe complex(kind=dp), public :: cProjFe Source Code subroutine pawCorrectionWfc ( system ) !! Calculates the augmentation part of the transition matrix element !! @todo Figure out what this subroutine really does @endtodo !! !! <h2>Walkthrough</h2> !! implicit none integer :: iIon !! Loop index over atoms integer :: iProj , jProj !! Loop index of projectors integer :: ibi , ibf !! Loop index over bands integer :: m , mPrime !! Loop index for magnetic quantum number for a given projector integer :: ispin integer :: LMBASE integer :: LM , LMP !! Index for cProj integer :: l , lPrime !! Angular momentum quantum number for a given projector integer :: iAtomType !! Atom type index for a given ion in the system ! real ( kind = dp ) :: atomicOverlap ! complex ( kind = dp ) :: cProjIe , cProjFe ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! ispin = 1 !! * Set the value of `ispin` to 1 !! @note !! `ispin` never has a value other than one, so I'm not sure !!  what its purpose is !! @endnote ! system % paw_Wfc (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values in `paw_Wfc` to complex double zero ! LMBASE = 0 !! * Initialize the base offset for `cProj`'s first index to zero ! do iIon = 1 , system % nIons !! * For each atom in the system !!    * Get the index for the atom type !!    * Loop over the projectors twice, each time finding the !!      angular momentum quantum number (l and l&#94;{\\prime}) !!      and magnetic quantum number (m and m&#94;{\\prime}) !!    * If l = l&#94;{\\prime} and m = m&#94;{\\prime}, loop over the bands to !!      calculate `paw_Wfc` !! !! @todo Figure out the significance of l = l&#94;{\\prime} and m = m&#94;{\\prime} @endtodo ! iAtomType = system % atomTypeIndex ( iIon ) ! LM = 0 ! do iProj = 1 , system % atoms ( iAtomType )% numProjs ! l = system % atoms ( iAtomType )% projAngMom ( iProj ) ! do m = - l , l ! LM = LM + 1 !1st index for CPROJ ! LMP = 0 ! do jProj = 1 , system % atoms ( iAtomType )% numProjs ! lPrime = system % atoms ( iAtomType )% projAngMom ( jProj ) ! do mPrime = - lPrime , lPrime ! LMP = LMP + 1 ! 2nd index for CPROJ ! atomicOverlap = 0.0_dp ! if ( ( l == lPrime ). and .( m == mPrime ) ) then ! atomicOverlap = sum ( system % atoms ( iAtomType )% F1 (:, iProj , jProj )) ! do ibi = iBandIinit , iBandIfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! cProjIe = system % cProj ( LMP + LMBASE , ibi , ISPIN ) ! else if ( system % crystalType == 'SD' ) then ! cProjIe = system % cCrossProj ( LMP + LMBASE , ibi , ISPIN ) ! endif ! do ibf = iBandFinit , iBandFfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! cProjFe = conjg ( system % cCrossProj ( LM + LMBASE , ibf , ISPIN )) ! else if ( system % crystalType == 'SD' ) then ! cProjFe = conjg ( system % cProj ( LM + LMBASE , ibf , ISPIN )) ! endif ! system % paw_Wfc ( ibf , ibi ) = system % paw_Wfc ( ibf , ibi ) + cProjFe * atomicOverlap * cProjIe ! enddo ! enddo ! endif ! enddo ! enddo ! enddo ! enddo ! LMBASE = LMBASE + system % atoms ( iAtomType )% lmMax ! enddo ! return ! end subroutine pawCorrectionWfc","tags":"","loc":"proc/pawcorrectionwfc.html","title":"pawCorrectionWfc – Carrier Cross Sections"},{"text":"public subroutine pawCorrectionK(system) Todo Figure out what this subroutine really does Walkthrough Set the value of ispin to 1 Note ispin never has a value other than one, so I'm not sure\n  what its purpose is Start a timer Initialize all values in pawK to complex double zero Loop through the plane waves for a given process If this is the root process, output a status update every 1000 plane waves\n   and every multiple of 25000, giving an estimate of the time remaining at each step Todo Figure out if this output slows things down significantly Todo Figure out if formula gives accurate representation of time left Calculate q as \\sqrt{\\mathbf{G}\\cdot\\mathbf{G}} to get length of \\mathbf{G} Define a unit vector in the direction of \\mathbf{G} , \n   but only divide by the length if it is bigger than 1\\times10&#94;{-6} to avoid dividing by very small numbers Initialize the spherical harmonics to complex double zero Calculate spherical harmonics with argument v_in up to Y_{J_{\\text{max}}}&#94;{\\pm J_{\\text{max}}} Initialize the base offset for cProj 's first index to zero For each atom type, loop through the r points\n   in the augmentation sphere and calculate the \n   spherical Bessel functions from 0 to JMAX at each point Todo Figure out if this should be system Todo Figure out significance of \"qr\" point Todo Test if can just directly store in each atom type's bes_J_qr For each atom in the system Calculate \\mathbf{G}\\cdot\\mathbf{r} Calculate e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} Get the index for the atom type Loop over the projectors, finding l, m for each For each possible m Calculate \\text{FI} = j_l\\cdot F where j_l is\n     the Bessel function and F is for a given projector Calculate \\text{VifQ_aug} = e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}}\n     Y_l&#94;m(\\mathbf{G}/|\\mathbf{G}|)(-i)&#94;l\\text{FI} Loop over the bands, summing VifQ_aug*cProj to get pawK Todo Figure out if this should be gDotR Todo Figure out why this is called ATOMIC_CENTER Todo Figure out why the difference between SD and PC Todo Figure out why the difference between SD and PC Todo Figure out why the difference between SD and PC Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) Contents Variables ibi ibf iPW iProj iR iAtomType iIon l m ispin LMBASE LM ind qDotR t1 t2 v_in JL q FI Y ATOMIC_CENTER VifQ_aug Source Code pawCorrectionK Variables Type Visibility Attributes Name Initial integer, public :: ibi Loop index over bands integer, public :: ibf Loop index over bands integer, public :: iPW Loop index over plane waves for a given process integer, public :: iProj Loop index over projectors integer, public :: iR Loop index over radial mesh (up to augmentation sphere) integer, public :: iAtomType Loop index over atom types integer, public :: iIon Loop index over ions in system integer, public :: l Angular momentum quantum number integer, public :: m Magnetic quantum number integer, public :: ispin integer, public :: LMBASE integer, public :: LM integer, public :: ind real(kind=dp), public :: qDotR \\mathbf{G}\\cdot\\mathbf{r} real(kind=dp), public :: t1 Start time real(kind=dp), public :: t2 End time real(kind=dp), public :: v_in (3) Unit vector in the direction of \\mathbf{G} real(kind=dp), public :: JL (0:JMAX) Spherical bessel functions for a point up to JMAX real(kind=dp), public :: q real(kind=dp), public :: FI complex(kind=dp), public :: Y ((JMAX+1)**2) All spherical harmonics up to some max momentum complex(kind=dp), public :: ATOMIC_CENTER e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} complex(kind=dp), public :: VifQ_aug Source Code subroutine pawCorrectionK ( system ) !! @todo Figure out what this subroutine really does @endtodo !! !! <h2>Walkthrough</h2> ! implicit none ! !integer, intent(in) :: ik ! integer :: ibi , ibf !! Loop index over bands integer :: iPW !! Loop index over plane waves for a given process integer :: iProj !! Loop index over projectors integer :: iR !! Loop index over radial mesh (up to augmentation sphere) integer :: iAtomType !! Loop index over atom types integer :: iIon !! Loop index over ions in system integer :: l !! Angular momentum quantum number integer :: m !! Magnetic quantum number integer :: ispin integer :: LMBASE integer :: LM integer :: ind ! real ( kind = dp ) :: qDotR !! \\mathbf{G}\\cdot\\mathbf{r} real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time real ( kind = dp ) :: v_in ( 3 ) !! Unit vector in the direction of \\mathbf{G} real ( kind = dp ) :: JL ( 0 : JMAX ) !! Spherical bessel functions for a point up to `JMAX` real ( kind = dp ) :: q real ( kind = dp ) :: FI ! complex ( kind = dp ) :: Y ( ( JMAX + 1 ) ** 2 ) !! All spherical harmonics up to some max momentum complex ( kind = dp ) :: ATOMIC_CENTER !! e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} complex ( kind = dp ) :: VifQ_aug ! TYPE ( crystal ), intent ( inout ) :: system !! Holds the structure for the system you are working on !! (either `perfectCrystal` or `solidDefect`) ! ispin = 1 !! * Set the value of `ispin` to 1 !! @note !! `ispin` never has a value other than one, so I'm not sure !!  what its purpose is !! @endnote ! call cpu_time ( t1 ) !! * Start a timer ! system % pawK (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize all values in `pawK` to complex double zero ! do iPW = nPWsI ( myid ), nPWsF ( myid ) !! * Loop through the plane waves for a given process ! if ( myid == root ) then if ( ( iPW == nPWsI ( myid ) + 1000 ) . or . ( mod ( iPW , 25000 ) == 0 ) . or . ( iPW == nPWsF ( myid )) ) then !! * If this is the root process, output a status update every 1000 plane waves !!   and every multiple of 25000, giving an estimate of the time remaining at each step !!   @todo Figure out if this output slows things down significantly @endtodo !!   @todo Figure out if formula gives accurate representation of time left @endtodo ! call cpu_time ( t2 ) ! write ( iostd , '(\"        Done \", i10, \" of\", i10, \" k-vecs. ETR : \", f10.2, \" secs.\")' ) & iPW , nPWsF ( myid ) - nPWsI ( myid ) + 1 , ( t2 - t1 ) * ( nPWsF ( myid ) - nPWsI ( myid ) + 1 - iPW ) / iPW ! flush ( iostd ) ! !call cpu_time(t1) ! endif endif ! q = sqrt ( sum ( gvecs (:, iPW ) * gvecs (:, iPW ))) !! * Calculate `q` as \\sqrt{\\mathbf{G}\\cdot\\mathbf{G}} !!   to get length of \\mathbf{G} ! !> * Define a unit vector in the direction of \\mathbf{G}, !>   but only divide by the length if it is bigger than !>   1\\times10&#94;{-6} to avoid dividing by very small numbers v_in (:) = gvecs (:, iPW ) if ( abs ( q ) > 1.0e-6_dp ) v_in = v_in / q ! Y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! * Initialize the spherical harmonics to complex double zero call ylm ( v_in , JMAX , Y ) !! * Calculate spherical harmonics with argument `v_in` up to !!   Y_{J_{\\text{max}}}&#94;{\\pm J_{\\text{max}}} ! LMBASE = 0 !! * Initialize the base offset for `cProj`'s first index to zero ! do iAtomType = 1 , system % numOfTypes ! do iR = 1 , system % atoms ( iAtomType )% iRAugMax !! * For each atom type, loop through the r points !!   in the augmentation sphere and calculate the !!   spherical Bessel functions from 0 to `JMAX` !!   at each point ! JL = 0.0_dp ! call bessel_j ( q * solidDefect % atoms ( iAtomType )% r ( iR ), JMAX , JL ) ! returns the spherical bessel at qr point !! @todo Figure out if this should be `system` @endtodo !! @todo Figure out significance of \"qr\" point @endtodo ! system % atoms ( iAtomType )% bes_J_qr (:, iR ) = JL (:) !! @todo Test if can just directly store in each atom type's `bes_J_qr` @endtodo ! enddo ! enddo ! do iIon = 1 , system % nIons !! * For each atom in the system !!    * Calculate \\mathbf{G}\\cdot\\mathbf{r} !!    * Calculate e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} !!    * Get the index for the atom type !!    * Loop over the projectors, finding l, m for each !!    * For each possible m !!       * Calculate \\text{FI} = j_l\\cdot F where j_l is !!         the Bessel function and F is for a given projector !!       * Calculate \\text{VifQ_aug} = e&#94;{-i\\mathbf{G}\\cdot\\mathbf{r}} !!         Y_l&#94;m(\\mathbf{G}/|\\mathbf{G}|)(-i)&#94;l\\text{FI} !!       * Loop over the bands, summing `VifQ_aug*cProj` to get `pawK` ! qDotR = sum ( gvecs (:, iPW ) * system % posIon (:, iIon )) !! @todo Figure out if this should be `gDotR` @endtodo ! !> @todo Figure out why this is called `ATOMIC_CENTER` @endtodo !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! ATOMIC_CENTER = exp ( - ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! else if ( system % crystalType == 'SD' ) then ! ATOMIC_CENTER = exp ( ii * cmplx ( qDotR , 0.0_dp , kind = dp ) ) ! endif ! iAtomType = system % atomTypeIndex ( iIon ) ! LM = 0 ! do iProj = 1 , system % atoms ( iAtomType )% numProjs ! l = system % atoms ( iAtomType )% projAngMom ( iProj ) ! do m = - l , l ! LM = LM + 1 !1st index for CPROJ ! FI = 0.0_dp ! FI = sum ( system % atoms ( iAtomType )% bes_J_qr ( l ,:) * system % atoms ( iAtomType )% F (:, iProj )) ! radial part integration F contains rab ! ind = l * ( l + 1 ) + m + 1 ! index for spherical harmonics ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! VifQ_aug = ATOMIC_CENTER * Y ( ind ) * ( - II ) ** l * FI ! else if ( system % crystalType == 'SD' ) then ! VifQ_aug = ATOMIC_CENTER * conjg ( Y ( ind )) * ( II ) ** l * FI ! endif ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! !> @todo Figure out why the difference between SD and PC @endtodo if ( system % crystalType == 'PC' ) then ! system % pawK ( ibf , ibi , iPW ) = system % pawK ( ibf , ibi , iPW ) + & VifQ_aug * system % cProj ( LM + LMBASE , ibi , ISPIN ) ! else if ( system % crystalType == 'SD' ) then ! system % pawK ( ibf , ibi , iPW ) = system % pawK ( ibf , ibi , iPW ) + & VifQ_aug * conjg ( system % cProj ( LM + LMBASE , ibi , ISPIN )) ! endif ! enddo ! enddo ! ENDDO ENDDO LMBASE = LMBASE + system % atoms ( iAtomType )% lmMax ENDDO ! enddo ! !system%pawK(:,:,:) = system%pawK(:,:,:)*4.0_dp*pi/sqrt(solidDefect%omega) ! return ! end subroutine pawCorrectionK","tags":"","loc":"proc/pawcorrectionk.html","title":"pawCorrectionK – Carrier Cross Sections"},{"text":"public subroutine ylm(V_in, LMAX, Y) Returns the spherical harmonics for a given argument vector up to the maximum value of l given Description Purpose The spherical harmonics (Condon and Shortley convention) Y_0&#94;0,Y_1&#94;{-1},Y_1&#94;0,Y_1&#94;1,Y_2&#94;{-2} ... Y_{l_{\\text{max}}}&#94;{\\pm l_{\\text{max}}} for vector \\mathbf{V} (given in Cartesian coordinates)\n        are calculated. In the Condon Shortley convention the\n        spherical harmonics are defined as Y_l&#94;m = (-1)&#94;m \\sqrt{\\frac{1}{\\pi}} P_l&#94;m(\\cos{\\theta})\n        e&#94;{im\\phi} where P_l&#94;m(\\cos{\\theta}) is the normalized Associated\n        Legendre function. Thus, Y_l&#94;{-m} = (-1)&#94;m (Y_l&#94;m)&#94;* Usage DOUBLE PRECISION V ( 3 ), Y ( 5 * 5 ) V ( 1 ) = ... V ( 2 ) = ... V ( 3 ) = ... CALL YLM ( V , 4 , Y ) Argument Description V - DOUBLE PRECISION vector, dimension 3        (input) Must be given in Cartesian coordinates.\n                   Conversion of V to polar coordinates gives the\n                   angles \\theta and \\phi necessary for the calculation\n                   of the spherical harmonics. LMAX - INTEGER value                               (input) upper bound of l for which spherical harmonics\n                   will be calculated constraint: LMAX >= 0 Y - COMPLEX*16 array, dimension (LMAX+1)**2 (output) contains the calculated spherical harmonics Y(1) for l=0 ( m = 0 ) Y(2), ..., Y(4) for l = 1 ( m = -1, 0, 1 ) ... Y(LMAX*LMAX+1), ..., Y((LMAX+1)*(LMAX+1)) for l = l_{\\text{max}} ( m = -l,...,l ) constraint: Dimension of Y \\geq (l_{\\text{max}} + 1)&#94;2 (not checked) Used Subroutines (Directly Called) none Indirectly Called Subroutines none Input/Output (Read/Write) none Machine Dependent Program Parts Type COMPLEX*16 is used which does not conform to the\n           FORTRAN 77 standard.\n           Also the non-standard type conversion function DCMPLX() is used which combines two double precision values into\n           one double complex value. Method The basic algorithm used to calculate the spherical\n           harmonics for vector \\mathbf{V} is as follows: Y ( 0 , 0 ) Y ( 1 , 0 ) Y ( 1 , 1 ) Y ( 1 , - 1 ) = - Y ( 1 , 1 ) DO L = 2 , LMAX Y ( L , L ) = f ( Y ( L - 1 , L - 1 )) ... Formula 1 Y ( L , L - 1 ) = f ( Y ( L - 1 , L - 1 )) ... Formula 2 DO M = L - 2 , 0 , - 1 Y ( L , M ) = f ( Y ( L - 1 , M ) , Y ( L - 2 , M )) ... Formula 2 Y ( L , - M ) = ( - 1 ) ** M * CONJG ( Y ( L , M )) ENDDO ENDDO Formulas Starting values: Y_0&#94;0 = \\sqrt{\\dfrac{1}{4\\pi}} Y_1&#94;0 = \\sqrt{\\dfrac{3}{4\\pi}}\\cos\\theta Y_1&#94;1 = -\\sqrt{\\dfrac{3}{8\\pi}}\\sin\\theta e&#94;{i\\phi} Formula 1: Y_l&#94;l = -\\sqrt{\\dfrac{2l+1}{2l}}\\sin\\theta e&#94;{i\\phi}Y_{l-1}&#94;{l-1} Formula 2: Y_l&#94;m = \\sqrt{\\dfrac{(2l-1)(2l+1)}{(l-m)(l+m)}}\\cos\\theta Y_{l-1}&#94;m - \n                    \\sqrt{\\dfrac{(l-1+m)(l-1-m)(2l+1)}{(2l-3)(l-m)(l+m)}} Y_{l-2}&#94;m Formula 3: (not used in the algorithm because of the division\n                    by \\sin\\theta which may be zero) Y_l&#94;m = -\\sqrt{\\dfrac{4(m+1)(m+1)}{(l+m+1)(l-m)}}\\dfrac{\\cos\\theta}{\\sin\\theta}e&#94;{i\\phi}Y_1&#94;{m+1} -\n                    \\sqrt{\\dfrac{(l-m-1)(l+m+2)}{(l-m)(l+m+1)}}e&#94;{-2i\\phi}Y_l&#94;{m+2} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_in (3) Vector, argument of the spherical harmonics (we calculate Y_l&#94;m(\\mathbf{v}/|\\mathbf{v}|) ) integer, intent(in) :: LMAX Spherical harmonics are calculated for l = 0, 1, ..., l_{\\text{max}} complex(kind=dp), intent(out) :: Y (*) Array containing Y_l&#94;m(\\mathbf{v}) for several l,m Contents Variables pi I2L I4L2 INDEX INDEX2 L M MSIGN A B C AB ABC ABMAX ABCMAX V D4LL1C D2L13 COSTH SINTH COSPH SINPH TEMP1 TEMP2 TEMP3 YLLR YLL1R YL1L1R YLMR YLLI YLL1I YL1L1I YLMI Source Code ylm Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 3.1415926535897932384626433_dp integer, public :: I2L integer, public :: I4L2 integer, public :: INDEX integer, public :: INDEX2 integer, public :: L integer, public :: M integer, public :: MSIGN real(kind=dp), public :: A real(kind=dp), public :: B real(kind=dp), public :: C real(kind=dp), public :: AB real(kind=dp), public :: ABC real(kind=dp), public :: ABMAX real(kind=dp), public :: ABCMAX real(kind=dp), public :: V (3) real(kind=dp), public :: D4LL1C real(kind=dp), public :: D2L13 real(kind=dp), public :: COSTH real(kind=dp), public :: SINTH real(kind=dp), public :: COSPH real(kind=dp), public :: SINPH real(kind=dp), public :: TEMP1 real(kind=dp), public :: TEMP2 real(kind=dp), public :: TEMP3 real(kind=dp), public :: YLLR real(kind=dp), public :: YLL1R real(kind=dp), public :: YL1L1R real(kind=dp), public :: YLMR real(kind=dp), public :: YLLI real(kind=dp), public :: YLL1I real(kind=dp), public :: YL1L1I real(kind=dp), public :: YLMI Source Code subroutine ylm ( v_in , lmax , y ) !! Returns the [spherical harmonics](http://mathworld.wolfram.com/SphericalHarmonic.html) !! for a given argument vector up to the maximum value of l given !! !! <h2>Description</h2> !!   <h3>Purpose</h3> !!        The spherical harmonics (Condon and Shortley convention) !!          Y_0&#94;0,Y_1&#94;{-1},Y_1&#94;0,Y_1&#94;1,Y_2&#94;{-2} ... Y_{l_{\\text{max}}}&#94;{\\pm l_{\\text{max}}} !!        for vector \\mathbf{V} (given in Cartesian coordinates) !!        are calculated. In the Condon Shortley convention the !!        spherical harmonics are defined as !!         Y_l&#94;m = (-1)&#94;m \\sqrt{\\frac{1}{\\pi}} P_l&#94;m(\\cos{\\theta}) !!        e&#94;{im\\phi}  !!        where  P_l&#94;m(\\cos{\\theta}) is the normalized Associated !!        Legendre function. Thus, !!                       Y_l&#94;{-m} = (-1)&#94;m (Y_l&#94;m)&#94;*  !! !!   <h3>Usage</h3> !! !! !!        DOUBLE PRECISION V(3), Y(5*5) !!        V(1) = ... !!        V(2) = ... !!        V(3) = ... !!        CALL YLM(V,4,Y) !! !!   <h3>Argument Description</h3> !!     <ul> !!          <li> !!                  `V`      - `DOUBLE PRECISION` vector, dimension 3        (input)<br/> !!                   Must be given in Cartesian coordinates. !!                   Conversion of V to polar coordinates gives the !!                   angles \\theta and \\phi necessary for the calculation !!                   of the spherical harmonics. !!          </li> !!          <li> !!                   `LMAX`   - `INTEGER` value                               (input)<br/> !!                   upper bound of l for which spherical harmonics !!                   will be calculated<br/> !!                   constraint: `LMAX >= 0` !!          </li> !!          <li> !!                   `Y`      - `COMPLEX*16` array, dimension `(LMAX+1)**2`    (output)<br/> !!                   contains the calculated spherical harmonics<br/> !!                   `Y(1)` for l=0 (m = 0)<br/> !!                   `Y(2), ..., Y(4)` for l = 1 (m = -1, 0, 1)<br/> !!                   ...<br/> !!                   `Y(LMAX*LMAX+1), ..., Y((LMAX+1)*(LMAX+1))` for l = l_{\\text{max}} !!                            (m = -l,...,l)<br/> !!                   constraint: Dimension of `Y` \\geq (l_{\\text{max}} + 1)&#94;2 (not checked) !!          </li> !!        </ul> !! !!   <h3>Used Subroutines (Directly Called)</h3> !!           none !! !!   <h3>Indirectly Called Subroutines</h3> !!           none !! !!   <h3>Input/Output (Read/Write)</h3> !!           none !! !!   <h3>Machine Dependent Program Parts</h3> !!           Type `COMPLEX*16` is used which does not conform to the !!           FORTRAN 77 standard. !!           Also the non-standard type conversion function `DCMPLX()` !!           is used which combines two double precision values into !!           one double complex value. !! !!   <h3>Method</h3> !!           The basic algorithm used to calculate the spherical !!           harmonics for vector \\mathbf{V} is as follows: !! !! !!           Y(0,0) !!           Y(1,0) !!           Y(1,1) !!           Y(1,-1) = -Y(1,1) !!           DO L = 2, LMAX !!              Y(L,L)   = f(Y(L-1,L-1)) ... Formula 1 !!              Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 !!              DO M = L-2, 0, -1 !!                 Y(L,M) = f(Y(L-1,M),Y(L-2,M)) ... Formula 2 !!                 Y(L,-M)= (-1)**M*CONJG(Y(L,M)) !!              ENDDO !!           ENDDO !! !!   <h3>Formulas</h3> !!        Starting values: !!          Y_0&#94;0 = \\sqrt{\\dfrac{1}{4\\pi}} !!          Y_1&#94;0 = \\sqrt{\\dfrac{3}{4\\pi}}\\cos\\theta !!          Y_1&#94;1 = -\\sqrt{\\dfrac{3}{8\\pi}}\\sin\\theta e&#94;{i\\phi} !!        Formula 1: !!          Y_l&#94;l = -\\sqrt{\\dfrac{2l+1}{2l}}\\sin\\theta e&#94;{i\\phi}Y_{l-1}&#94;{l-1} !!        Formula 2: !!          Y_l&#94;m = \\sqrt{\\dfrac{(2l-1)(2l+1)}{(l-m)(l+m)}}\\cos\\theta Y_{l-1}&#94;m - !!                    \\sqrt{\\dfrac{(l-1+m)(l-1-m)(2l+1)}{(2l-3)(l-m)(l+m)}} Y_{l-2}&#94;m !!        Formula 3: (not used in the algorithm because of the division !!                    by \\sin\\theta which may be zero) !!          Y_l&#94;m = -\\sqrt{\\dfrac{4(m+1)(m+1)}{(l+m+1)(l-m)}}\\dfrac{\\cos\\theta}{\\sin\\theta}e&#94;{i\\phi}Y_1&#94;{m+1} - !!                    \\sqrt{\\dfrac{(l-m-1)(l+m+2)}{(l-m)(l+m+1)}}e&#94;{-2i\\phi}Y_l&#94;{m+2} !! ! !REVISION HISTORY: !   26. April 1994                                   Version 1.2 !   Taken 8 1 98 from SRC_lapw2 to SRC_telnes !   Updated November 2004 (Kevin Jorissen) !   cosmetics March 2005 (Kevin Jorissen) ! implicit none ! !   In/Output : ! integer , intent ( in ) :: LMAX !! Spherical harmonics are calculated for !! l = 0, 1, ..., l_{\\text{max}} real ( kind = dp ), intent ( in ) :: V_in ( 3 ) !! Vector, argument of the spherical harmonics (we calculate !! Y_l&#94;m(\\mathbf{v}/|\\mathbf{v}|)) complex ( kind = dp ), intent ( out ) :: Y ( * ) !! Array containing Y_l&#94;m(\\mathbf{v}) for several l,m ! !   Local variables : real ( kind = dp ), parameter :: pi = 3.1415926535897932384626433_dp ! INTEGER :: I2L , I4L2 , INDEX , INDEX2 , L , M , MSIGN real ( kind = dp ) :: A , B , C , AB , ABC , ABMAX , ABCMAX , V ( 3 ) real ( kind = dp ) :: D4LL1C , D2L13 real ( kind = dp ) :: COSTH , SINTH , COSPH , SINPH real ( kind = dp ) :: TEMP1 , TEMP2 , TEMP3 real ( kind = dp ) :: YLLR , YLL1R , YL1L1R , YLMR real ( kind = dp ) :: YLLI , YLL1I , YL1L1I , YLMI ! ! Y(0,0) ! do INDEX = 1 , 3 V ( INDEX ) = dble ( V_in ( INDEX )) enddo YLLR = 1.0_dp / sqrt ( 4.0_dp * PI ) YLLI = 0.0_dp Y ( 1 ) = CMPLX ( YLLR , YLLI , kind = dp ) ! ! continue only if spherical harmonics for (L .GT. 0) are desired ! IF ( LMAX . LE . 0 ) GOTO 999 ! ! calculate sin(Phi), cos(Phi), sin(Theta), cos(Theta) ! Theta, Phi ... polar angles of vector V ! ABMAX = MAX ( ABS ( V ( 1 )), ABS ( V ( 2 ))) IF ( ABMAX . GT . 0.0_dp ) THEN A = V ( 1 ) / ABMAX B = V ( 2 ) / ABMAX AB = SQRT ( A * A + B * B ) COSPH = A / AB SINPH = B / AB ELSE COSPH = 1.0_dp SINPH = 0.0_dp ENDIF ABCMAX = MAX ( ABMAX , ABS ( V ( 3 ))) IF ( ABCMAX . GT . dble ( 0 )) THEN A = V ( 1 ) / ABCMAX B = V ( 2 ) / ABCMAX C = V ( 3 ) / ABCMAX AB = A * A + B * B ABC = SQRT ( AB + C * C ) COSTH = C / ABC SINTH = SQRT ( AB ) / ABC ELSE COSTH = 1.0_dp SINTH = 0.0_dp ENDIF ! ! Y(1,0) ! Y ( 3 ) = CMPLX ( sqrt ( 3.0_dp ) * YLLR * COSTH , 0.0_dp , kind = dp ) ! ! Y(1,1) ( = -DCONJG(Y(1,-1))) ! TEMP1 = - SQRT ( 1.5_dp ) * YLLR * SINTH Y ( 4 ) = CMPLX ( TEMP1 * COSPH , TEMP1 * SINPH , kind = dp ) Y ( 2 ) = - CONJG ( Y ( 4 )) ! DO L = 2 , LMAX INDEX = L * L + 1 INDEX2 = INDEX + 2 * L MSIGN = 1 - 2 * MOD ( L , 2 ) ! ! YLL = Y(L,L) = f(Y(L-1,L-1)) ... Formula 1 ! YL1L1R = DBLE ( Y ( INDEX - 1 )) YL1L1I = DIMAG ( Y ( INDEX - 1 )) TEMP1 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L )) * SINTH YLLR = TEMP1 * ( COSPH * YL1L1R - SINPH * YL1L1I ) YLLI = TEMP1 * ( COSPH * YL1L1I + SINPH * YL1L1R ) Y ( INDEX2 ) = CMPLX ( YLLR , YLLI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! ! YLL1 = Y(L,L-1) = f(Y(L-1,L-1)) ... Formula 2 ! (the coefficient for Y(L-2,L-1) in Formula 2 is zero) ! TEMP2 = SQRT ( DBLE ( 2 * L + 1 )) * COSTH YLL1R = TEMP2 * YL1L1R YLL1I = TEMP2 * YL1L1I Y ( INDEX2 ) = CMPLX ( YLL1R , YLL1I , kind = dp ) Y ( INDEX ) = - cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = -dble(MSIGN)*CONJG(Y(INDEX2)) INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 ! I4L2 = INDEX2 - 4 * L + 2 I2L = INDEX2 - 2 * L D4LL1C = COSTH * SQRT ( DBLE ( 4 * L * L - 1 )) D2L13 = - SQRT ( DBLE ( 2 * L + 1 ) / DBLE ( 2 * L - 3 )) ! DO M = L - 2 , 0 , - 1 ! ! YLM = Y(L,M) = f(Y(L-2,M),Y(L-1,M)) ... Formula 2 ! TEMP1 = 1.0_dp / SQRT ( DBLE (( L + M ) * ( L - M ))) TEMP2 = D4LL1C * TEMP1 TEMP3 = D2L13 * SQRT ( DBLE (( L + M - 1 ) * ( L - M - 1 ))) * TEMP1 YLMR = TEMP2 * DBLE ( Y ( I2L )) + TEMP3 * DBLE ( Y ( I4L2 )) YLMI = TEMP2 * DIMAG ( Y ( I2L )) + TEMP3 * DIMAG ( Y ( I4L2 )) Y ( INDEX2 ) = CMPLX ( YLMR , YLMI , kind = dp ) Y ( INDEX ) = cmplx ( MSIGN , 0.0_dp , kind = dp ) * CONJG ( Y ( INDEX2 )) !      Y(INDEX)  = dble(MSIGN)*CONJG(Y(INDEX2)) ! MSIGN = - MSIGN INDEX2 = INDEX2 - 1 INDEX = INDEX + 1 I4L2 = I4L2 - 1 I2L = I2L - 1 ENDDO ENDDO ! 999 RETURN END subroutine ylm","tags":"","loc":"proc/ylm.html","title":"ylm – Carrier Cross Sections"},{"text":"public subroutine bessel_j(x, lmax, jl) Generates the spherical bessel function of the first kind for the given argument x and all possible indices from 0 to lmax Walkthrough If x is less than zero, return 0 for all\n   indices but 0 which is 1 Explicitly calculate the first 2 functions so can use \n   recursive definition for later terms Define the rest of the functions as j_l = (2l-1)j_{l-1}/x - j_{l-2} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: lmax real(kind=dp), intent(out) :: jl (0:lmax) Contents Variables l Source Code bessel_j Variables Type Visibility Attributes Name Initial integer, public :: l Source Code subroutine bessel_j ( x , lmax , jl ) !! Generates the !! [spherical bessel function of the first kind](http://mathworld.wolfram.com/SphericalBesselFunctionoftheFirstKind.html) !! for the given argument x and all possible indices from 0 to `lmax` !! !! <h2>Walkthrough</h2> !! ! implicit none ! integer , intent ( in ) :: lmax integer :: l ! real ( kind = dp ), intent ( in ) :: x real ( kind = dp ), intent ( out ) :: jl ( 0 : lmax ) ! if ( x <= 0.0_dp ) then !! * If x is less than zero, return 0 for all !!   indices but 0 which is 1 ! jl = 0.0_dp jl ( 0 ) = 1.0_dp ! return ! end if ! !> * Explicitly calculate the first 2 functions so can use !>   recursive definition for later terms jl ( 0 ) = sin ( x ) / x if ( lmax <= 0 ) return jl ( 1 ) = ( jl ( 0 ) - cos ( x )) / x if ( lmax == 1 ) return ! do l = 2 , lmax !! * Define the rest of the functions as !!   j_l = (2l-1)j_{l-1}/x - j_{l-2} ! jl ( l ) = dble ( 2 * l - 1 ) * jl ( l - 1 ) / x - jl ( l - 2 ) ! enddo ! return ! end subroutine bessel_j","tags":"","loc":"proc/bessel_j.html","title":"bessel_j – Carrier Cross Sections"},{"text":"public subroutine writeResults(ik) Write out the \\langle f|U|i\\rangle matrix and\n changes in eigenvalues for a given k point Walkthrough Start a timer Read eigenvalues from pw_export_for_TME Write out a header to output file Convert the k point index to a string Determine what the file name should be based on the k point index Open the matrix elements output file Output cell volume to Uelements file Calculate the total number of matrix elements Output the total number of elements and band limits Loop through the bands to output the change \n   in eigenvalues, matrix element, and norm \n   squared matrix element Close the matrix elements output file Stop the timer Write to output file how long it took to write the matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index Contents Variables ibi ibf totalNumberOfElements t1 t2 text Uelements ikstr Source Code writeResults Variables Type Visibility Attributes Name Initial integer, public :: ibi Loop index over bands integer, public :: ibf Loop index over bands integer, public :: totalNumberOfElements Total number of matrix elements real(kind=dp), public :: t1 Start time real(kind=dp), public :: t2 End time character(len=300), public :: text String to hold long section header character(len=300), public :: Uelements File name for matrix elements output character(len=300), public :: ikstr String version of k point index Source Code subroutine writeResults ( ik ) !! Write out the \\langle f|U|i\\rangle matrix and !! changes in eigenvalues for a given k point !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index ! integer :: ibi , ibf !! Loop index over bands integer :: totalNumberOfElements !! Total number of matrix elements real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time ! character ( len = 300 ) :: text !! String to hold long section header character ( len = 300 ) :: Uelements !! File name for matrix elements output character ( len = 300 ) :: ikstr !! String version of k point index ! call cpu_time ( t1 ) !! * Start a timer ! call readEigenvalues ( ik ) !! * Read eigenvalues from [[pw_export_for_tme(program)]] ! write ( iostd , '(\" Writing Ufi(:,:).\")' ) !! * Write out a header to `output` file ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! write ( Uelements , '(\"/TMEs_kptI_\",a,\"_kptF_\",a)' ) trim ( ikstr ), trim ( ikstr ) !! * Determine what the file name should be based on the k point index ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) !! * Open the matrix elements output file ! write ( 17 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(a51, ES24.15E3)'' \", ES24.15E3)' ) solidDefect % omega !! * Output cell volume to `Uelements` file ! text = \"# Total number of <f|U|i> elements, Initial States (bandI, bandF), Final States (bandI, bandF)\" write ( 17 , '(a, \" Format : ''(5i10)''\")' ) trim ( text ) ! * Output header for next section ! totalNumberOfElements = ( iBandIfinal - iBandIinit + 1 ) * ( iBandFfinal - iBandFinit + 1 ) !! * Calculate the total number of matrix elements write ( 17 , '(5i10)' ) totalNumberOfElements , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal !! * Output the total number of elements and band limits ! write ( 17 , '(\"# Final Band, Initial Band, Delta energy, Complex <f|U|i>, |<f|U|i>|&#94;2 Format : ''(2i10,4ES24.15E3)''\")' ) ! * Output header for next section ! do ibf = iBandFinit , iBandFfinal do ibi = iBandIinit , iBandIfinal !! * Loop through the bands to output the change !!   in eigenvalues, matrix element, and norm !!   squared matrix element ! write ( 17 , 1001 ) ibf , ibi , eigvI ( ibi ) - eigvF ( ibf ), Ufi ( ibf , ibi , ik ), abs ( Ufi ( ibf , ibi , ik )) ** 2 ! enddo enddo ! close ( 17 ) !! * Close the matrix elements output file ! call cpu_time ( t2 ) !! * Stop the timer ! write ( iostd , '(\" Writing Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 !! * Write to `output` file how long it took to write the matrix ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! Define format for writing matrix ! return ! end subroutine writeResults","tags":"","loc":"proc/writeresults.html","title":"writeResults – Carrier Cross Sections"},{"text":"public subroutine readUfis(ik) Read in matrix elements for a given k point Walkthrough Start a timer Write out a header to the output file Convert the k point index to a string Determine what the file name should be based on the k point index Open the matrix elements file Ignore the first two lines as they are comments Read in the total number of matrix elements Ignore the next line as it is a comment Read in the indices and value for each\n   matrix element, ignoring the change in\n   eigenvalues and norm squared matrix\n   element Stop timer Write out time to read Ufi to output file Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index Contents Variables ibi ibf totalNumberOfElements iDum iEl rDum t1 t2 cUfi Uelements ikstr Source Code readUfis Variables Type Visibility Attributes Name Initial integer, public :: ibi Loop index over bands integer, public :: ibf Loop index over bands integer, public :: totalNumberOfElements Total number of matrix elements integer, public :: iDum Dummy variable to ignore input integer, public :: iEl Loop index over matrix elements real(kind=dp), public :: rDum Dummy variable to ignore input real(kind=dp), public :: t1 Start time real(kind=dp), public :: t2 End time complex(kind=dp), public :: cUfi Temporarily store value of each matrix element character(len=300), public :: Uelements File name for matrix elements output character(len=300), public :: ikstr String version of k point index Source Code subroutine readUfis ( ik ) !! Read in matrix elements for a given k point !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ibi , ibf !! Loop index over bands integer :: totalNumberOfElements !! Total number of matrix elements integer :: iDum !! Dummy variable to ignore input integer :: iEl !! Loop index over matrix elements ! real ( kind = dp ) :: rDum !! Dummy variable to ignore input real ( kind = dp ) :: t1 !! Start time real ( kind = dp ) :: t2 !! End time ! complex ( kind = dp ) :: cUfi !! Temporarily store value of each matrix element ! character ( len = 300 ) :: Uelements !! File name for matrix elements output character ( len = 300 ) :: ikstr !! String version of k point index ! call cpu_time ( t1 ) !! * Start a timer ! write ( iostd , '(\" Reading Ufi(:,:) of k-point: \", i4)' ) ik !! * Write out a header to the `output` file ! call int2str ( ik , ikstr ) !! * Convert the k point index to a string ! write ( Uelements , '(\"/TMEs_kptI_\",a,\"_kptF_\",a)' ) trim ( ikstr ), trim ( ikstr ) !! * Determine what the file name should be based on the k point index ! open ( 17 , file = trim ( elementsPath ) // trim ( Uelements ), status = 'unknown' ) !! * Open the matrix elements file ! read ( 17 , * ) read ( 17 , * ) !! * Ignore the first two lines as they are comments ! read ( 17 , '(5i10)' ) totalNumberOfElements , iDum , iDum , iDum , iDum !! * Read in the total number of matrix elements ! read ( 17 , * ) !! * Ignore the next line as it is a comment ! do iEl = 1 , totalNumberOfElements !! * Read in the indices and value for each !!   matrix element, ignoring the change in !!   eigenvalues and norm squared matrix !!   element ! read ( 17 , 1001 ) ibf , ibi , rDum , cUfi , rDum Ufi ( ibf , ibi , ik ) = cUfi ! enddo ! close ( 17 ) ! call cpu_time ( t2 ) !! * Stop timer ! write ( iostd , '(\" Reading Ufi(:,:) done in:                   \", f10.2, \" secs.\")' ) t2 - t1 !! * Write out time to read `Ufi` to `output` file ! 1001 format ( 2 i10 , 4 ES24 . 1 5E3 ) ! Define format to read in matrix elements ! return ! end subroutine readUfis","tags":"","loc":"proc/readufis.html","title":"readUfis – Carrier Cross Sections"},{"text":"public subroutine calculateVfiElements() Todo Figure out what the purpose of this function is. For plotting? Walkthrough Allocate space for DE and absVfi2 Initialize DE and absVfi2 to double zero For each k point Read in the initial and final eigenvalues For each band between iBandIinit and iBandIfinal Calculate \\epsilon_{if} = \\epsilon_f - \\epsilon_i as defined in paper Calculate |\\Delta H_{if}|&#94;2 = \\dfrac{|\\langle\\Phi_f|\\Psi_i\\rangle|&#94;2 - |\\langle\\Phi_f|\\Psi_i\\rangle|&#94;4}\n                            {(1 - 2|\\langle\\Phi_f|\\Psi_i\\rangle|&#94;2)&#94;2}\\epsilon_{if} (A8 in paper) Note Only numerator is calculated because the denominator\n     is approximately zero, assuming |\\langle\\Phi_f|\\Psi_i\\rangle| \\ll 1","tags":"","loc":"proc/calculatevfielements.html","title":"calculateVfiElements – Carrier Cross Sections"},{"text":"public subroutine readEigenvalues(ik) Read in the eigenvalues output from pw_export_for_TME Walkthrough Convert k point index to string Open the perfectCrystal eigenvalues.ik file from pw_export_for_TME Ignore the first two lines as they are comments Ignore eigenvalues for bands that are before iBandIinit Read in the eigenvalues from iBandIinit to iBandIfinal Close the solid defect eigenvalues.ik file Open the solid defect eigenvalues.ik file from pw_export_for_TME Ignore the first two lines as they are comments Ignore eigenvalues for bands that are before iBandFinit Read in the eigenvalues from iBandFinit to iBandFfinal Close the solid defect eigenvalues.ik file Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index Contents Variables ib ikstr Source Code readEigenvalues Variables Type Visibility Attributes Name Initial integer, public :: ib Loop index over bands character(len=300), public :: ikstr String version of k point index Source Code subroutine readEigenvalues ( ik ) !! Read in the eigenvalues output from [[pw_export_for_tme(program)]] !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: ik !! K point index integer :: ib !! Loop index over bands ! character ( len = 300 ) :: ikstr !! String version of k point index ! call int2str ( ik , ikstr ) !! * Convert k point index to string ! open ( 72 , file = trim ( perfectCrystal % exportDir ) // \"/eigenvalues.\" // trim ( ikstr )) !! * Open the perfectCrystal `eigenvalues.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) read ( 72 , * ) !! * Ignore the first two lines as they are comments ! do ib = 1 , iBandIinit - 1 !! * Ignore eigenvalues for bands that are before `iBandIinit` ! read ( 72 , * ) ! enddo ! do ib = iBandIinit , iBandIfinal !! * Read in the eigenvalues from `iBandIinit` to `iBandIfinal` ! read ( 72 , '(ES24.15E3)' ) eigvI ( ib ) ! enddo ! close ( 72 ) !! * Close the solid defect `eigenvalues.ik` file ! open ( 72 , file = trim ( solidDefect % exportDir ) // \"/eigenvalues.\" // trim ( ikstr )) !! * Open the solid defect `eigenvalues.ik` file from [[pw_export_for_tme(program)]] ! read ( 72 , * ) read ( 72 , * ) !! * Ignore the first two lines as they are comments ! do ib = 1 , iBandFinit - 1 !! * Ignore eigenvalues for bands that are before `iBandFinit` ! read ( 72 , * ) ! enddo ! do ib = iBandFinit , iBandFfinal !! * Read in the eigenvalues from `iBandFinit` to `iBandFfinal` ! read ( 72 , '(ES24.15E3)' ) eigvF ( ib ) ! enddo ! close ( 72 ) !! * Close the solid defect `eigenvalues.ik` file ! return ! end subroutine readEigenvalues","tags":"","loc":"proc/readeigenvalues.html","title":"readEigenvalues – Carrier Cross Sections"},{"text":"public subroutine finalizeCalculation() Stop timer, write out total time taken, and close the output file Arguments None Contents Source Code finalizeCalculation Source Code subroutine finalizeCalculation () !! Stop timer, write out total time taken, and close the output file ! implicit none ! write ( iostd , '(\"-----------------------------------------------------------------\")' ) ! call cpu_time ( tf ) write ( iostd , '(\" Total time needed:                         \", f10.2, \" secs.\")' ) tf - t0 ! close ( iostd ) ! return ! end subroutine finalizeCalculation","tags":"","loc":"proc/finalizecalculation.html","title":"finalizeCalculation – Carrier Cross Sections"},{"text":"public subroutine int2str(integ, string) Write a given integer to a string, using only as many digits as needed Arguments Type Intent Optional Attributes Name integer :: integ character(len=300) :: string Contents Source Code int2str Source Code subroutine int2str ( integ , string ) !! Write a given integer to a string, using only as many digits as needed ! implicit none integer :: integ character ( len = 300 ) :: string ! if ( integ < 10 ) then write ( string , '(i1)' ) integ else if ( integ < 100 ) then write ( string , '(i2)' ) integ else if ( integ < 1000 ) then write ( string , '(i3)' ) integ else if ( integ < 10000 ) then write ( string , '(i4)' ) integ endif ! string = trim ( string ) ! return ! end subroutine int2str","tags":"","loc":"proc/int2str.html","title":"int2str – Carrier Cross Sections"},{"text":"public function wasRead(inputVal, variableName, usage, abortExecution) Determine if an input variable still has the default value.\n If it does, output an error message and possibly set the program\n to abort. Not all variables would cause the program to abort,\n so this program assumes that if you pass in the logical abortExecution then the variable is required and causes the program to abort \n if missing. I could not find a clean way to allow this function to receive\n different types of variables (integer, real, character, etc.), so\n I made the argument be an integer so that each type could be sent\n in a different way. Each case is set up so that the value is tested to\n see if it is less than zero to determine if the variable still has\n its default value For strings, the default value is '' , so pass in LEN(trim(variable))-1 as this should be less than zero if\n the string still has the default value and greater than or equal \n to zero otherwise For integers the default values are less than zero, so just pass as is Real variables also have a negative default value, so just pass the\n value cast from real to integer Default return value is true If the input variable still has the default value output an error message set the program to abort if that variable was sent in set the return value to false to indicate that the \n  variable wasn't read Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputVal Value to compare with 0 to see if a variable has been read; character(len=*), intent(in) :: variableName Name of the variable used in output message character(len=*), intent(in) :: usage Example of how the variable can be used logical, intent(inout), optional :: abortExecution Optional logical for if the program should be aborted Return Value logical Whether or not the input variable was read from the input file;\n this is the return value Walkthrough Contents None","tags":"","loc":"proc/wasread~2.html","title":"wasRead – Carrier Cross Sections"},{"text":"public subroutine readInputs() Uses readInputFiles Read input parameters and read phonon output Walkthrough Check if file output exists; if it does, delete it Open new output file Set default values of input parameters Read input parameters Check if input parameters were updated \n   and do some basic checks Read the phonons output from QE or VASP Read the equilibrium atomic positions Arguments None Contents None","tags":"","loc":"proc/readinputs.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initialize() Set default values for input parameters Arguments None Contents None","tags":"","loc":"proc/initialize.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Check that the input variables don't still have their default\n values. The program will abort here if:\n * equilibriumAtomicPositions is not defined\n * phononsInput is not defined\n * temperature is not defined\n * modeI or modeF is not defined\n * modeF < modeI * maxDisplacement is not defined Arguments None Contents Variables abortExecution Variables Type Visibility Attributes Name Initial logical, public :: abortExecution = .false.","tags":"","loc":"proc/checkandupdateinput~2.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readAtomicPositions() Read in the element and equilibrium position for \n each atom Walkthrough Open the equilibriumAtomicPositions file For each atom, read in the element and equilibrium position Close the equilibriumAtomicPositions file Arguments None Contents Variables iAtom Variables Type Visibility Attributes Name Initial integer, public :: iAtom Loop index over atoms","tags":"","loc":"proc/readatomicpositions.html","title":"readAtomicPositions – Carrier Cross Sections"},{"text":"public subroutine displaceAtoms() For each mode, generate random displacements for the atoms\n based on the parameters maxDisplacement and phonD Walkthrough For each mode, generate random displacements for the atoms \n   based on the parameters maxDisplacement and phonD Todo Figure out if expect modeI and modeF to represent index of magnitude of argument x Arguments None Contents Variables istat iAtom iMode iRand ran norm Variables Type Visibility Attributes Name Initial integer, public :: istat integer, public :: iAtom integer, public :: iMode integer, public :: iRand real(kind=dp), public :: ran real(kind=dp), public :: norm","tags":"","loc":"proc/displaceatoms.html","title":"displaceAtoms – Carrier Cross Sections"},{"text":"public subroutine writeNewAtomicPositions() Uses miscUtilities Write newAtomicPosition s for each mode Arguments None Contents Variables iAtom iMode s2LStr Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode character(len=300), public :: s2LStr","tags":"","loc":"proc/writenewatomicpositions.html","title":"writeNewAtomicPositions – Carrier Cross Sections"},{"text":"public subroutine exportQEInput() Uses miscUtilities Create QE input files for all different modes\n by copying all of the QEInput except the newAtomicPosition s for each mode Walkthrough For each mode between modeI and modeF If the folder for this mode doesn't already \n     exist, make it Copy the QEInput file into the new folder, \n     changing the positions to be the newAtomicPosition Todo Make this loop more clear Arguments None Contents Variables iAtom iMode line fn modeFolder mkDir s2LStr Variables Type Visibility Attributes Name Initial integer, public :: iAtom Loop index over atoms integer, public :: iMode Loop index over phonon modes character(len=300), public :: line character(len=300), public :: fn character(len=300), public :: modeFolder character(len=300), public :: mkDir character(len=300), public :: s2LStr","tags":"","loc":"proc/exportqeinput.html","title":"exportQEInput – Carrier Cross Sections"},{"text":"public function lcg(s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer Contents None","tags":"","loc":"proc/lcg.html","title":"lcg – Carrier Cross Sections"},{"text":"public subroutine readInputs() Uses readInputFiles Read input parameters and read phonon output Walkthrough Include readInputFiles module for reading \n phonons input Check if output file exists; if it does delete it Open new output file Set default values of input parameters Read input parameters Check if input parameters were updated and do some basic checks Read the phonons output from QE or VASP Arguments None Contents None","tags":"","loc":"proc/readinputs~2.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initializeLSF() Allocate and initialize lsfVsE and minimumNumberOfPhonons . If a file was\n given to continue from, read in both \n variables from the file. Todo Figure out why increase minimumNumberOfPhonons by 1 Arguments None Contents Variables dummyD dummyI dummyC1 dummyC8 dummyC9 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dummyD integer, public :: dummyI character(len=1), public :: dummyC1 character(len=8), public :: dummyC8 character(len=9), public :: dummyC9","tags":"","loc":"proc/initializelsf.html","title":"initializeLSF – Carrier Cross Sections"},{"text":"public subroutine initialize() Set default values for input parameters Arguments None Contents None","tags":"","loc":"proc/initialize~2.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Check that the input variables don't still have their default\n values. The program will abort here if:\n   * phononsInput is undefined\n   * phononsInputFormat is undefined\n   * temperature is undefined\n   * maximumNumberOfPhonons is undefined\n   * number of Monte Carlo steps ( nMc ) is not\n     set and maximumNumberOfPhonons is greater\n     than 4 This subroutine also sets maxEnergy and nEnergies and calculates kT and deltaE . Arguments None Contents Variables abortExecution Variables Type Visibility Attributes Name Initial logical, public :: abortExecution = .false.","tags":"","loc":"proc/checkandupdateinput.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readPhononsQE() Arguments None Contents Variables iAtom iMode iq dummyD freqInTHz dummyC Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode integer, public :: iq real(kind=dp), public :: dummyD real(kind=dp), public :: freqInTHz character, public :: dummyC","tags":"","loc":"proc/readphononsqe.html","title":"readPhononsQE – Carrier Cross Sections"},{"text":"public subroutine lsfDeterministicFourPhononsByFourBands() Explicitly calculate the line shape function for \n four phonons in four bands Todo Figure out if iModeFs(myid) has a max of nModes-3 or nModes-nBands+1 Pick four bands, pick a combination of \\pm1 in each band, calculate the lsf of the configuration, and repeat\n until all possible combinations have been done Todo Figure out what the purpose of ic is Arguments None Contents Variables ic iMode1 iMode2 iMode3 iMode4 pm1 pm2 pm3 pm4 t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: ic integer, public :: iMode1 integer, public :: iMode2 integer, public :: iMode3 integer, public :: iMode4 integer, public :: pm1 integer, public :: pm2 integer, public :: pm3 integer, public :: pm4 real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfdeterministicfourphononsbyfourbands.html","title":"lsfDeterministicFourPhononsByFourBands – Carrier Cross Sections"},{"text":"public subroutine lsfOfConfigurationPj() Calculate a portion of the line shape function F for a given set \\{p_j\\} Background The line shape function is defined in the paper as F = \\dfrac{1}{\\Omega_k}\\sum_{p_j}\\left[\\left(\\prod_{j=1}&#94;{M}F_j\\right)\n       \\sum_{j=1}&#94;M\\left(p_j + \\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\n       \\dfrac{I_{p_j+1}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right]}{I_{p_j}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right]}\\right)\n       D(\\omega_j)\\right] This function calculates \\sum_{p_j}\\left[\\left(\\prod_{j=1}&#94;{M}F_j\\right) \n   \\sum_{j=1}&#94;M\\left(p_j + \\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\n   \\dfrac{I_{p_j+1}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right]}{I_{p_j}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right]}\\right)\\right] The F_j terms are calculated based on (42) from the paper F_j = \\exp\\left[\\dfrac{p_j\\hbar\\omega_j}{2kT} - \n   S_j\\coth\\left(\\dfrac{\\hbar\\omega_j}{2kT}\\right)\\right]\n   I_{p_j}\\left[\\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)}\\right] Walkthrough For each phonon mode Get the modified Bessel function I_{p_j} If the number of additional phonons p_j > 0 and I_{p_j} > 10&#94;{-15} , F_j = 0 Otherwise, calculate F_j from (42) Multiply F_j on running product to get \\prod_{j=1}&#94;{M}F_j Calculate I_{p_j+1}(x)I_{p_j}(x) Add results to running total to get innermost sum in (43) in paper\n  (see Background for details) Todo Change this to merge if statements Todo Figure out why don't just exit here because will be multiplying by 0 Todo Redo besRatio if statement to be more clear that it is if/else Calculate the energy gained by the extra phonons Calculate the energy index Increment the number of energies in the calculated bin Combine terms to get the middle portion of (43) in the paper (see Background for details) Arguments None Contents Variables iE j E Fj prodFj sumOverj besPj besRatio Variables Type Visibility Attributes Name Initial integer, public :: iE integer, public :: j real(kind=dp), public :: E real(kind=dp), public :: Fj real(kind=dp), public :: prodFj real(kind=dp), public :: sumOverj real(kind=dp), public :: besPj real(kind=dp), public :: besRatio","tags":"","loc":"proc/lsfofconfigurationpj.html","title":"lsfOfConfigurationPj – Carrier Cross Sections"},{"text":"public subroutine calculatePlusMinusStates(l) Get all of the possible binary numbers with l digits and store them in pms . Note The binary numbers are reversed before stored, but I don't know why. Todo Send slice instead of using other Arguments Type Intent Optional Attributes Name integer, intent(in) :: l Contents Variables iDec other Variables Type Visibility Attributes Name Initial integer, public :: iDec integer, public :: other (0:l-1)","tags":"","loc":"proc/calculateplusminusstates.html","title":"calculatePlusMinusStates – Carrier Cross Sections"},{"text":"public subroutine distrubutePhononsInBands(m, l) Generate all possible ways to distribute m phonons in l bands\n such that each band has at least one phonon (only plus no minuses) Todo Figure out if there is a better way in general to do this Todo Write a recursive function to replace explicit loops Todo Fix typo in distrubute Todo Change l to nBands and m to kPhonons or something similar Todo Add a condition to exit inner loop if i1 + i2 + i3 > m Todo Add a condition to exit inner loop if i > size of pj0s Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l Contents Variables i i1 i2 i3 i4 i5 i6 i7 i8 i9 i10 i11 i12 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i1 integer, public :: i2 integer, public :: i3 integer, public :: i4 integer, public :: i5 integer, public :: i6 integer, public :: i7 integer, public :: i8 integer, public :: i9 integer, public :: i10 integer, public :: i11 integer, public :: i12","tags":"","loc":"proc/distrubutephononsinbands.html","title":"distrubutePhononsInBands – Carrier Cross Sections"},{"text":"public subroutine lsfWithMphonons(m, l, tTimes) Pick nMC groups of bands, then calculate the\n line shape function for all possible configurations\n in those bands and sum to get an estimate of the\n total line shape function for m phonons in l bands Todo Make sure that Monte Carlo makes sense here Todo Figure out if there are any methods that would be better/faster Walkthrough Randomly pick l bands from possible modes Todo Figure out a better way to do this as it is crazy inefficient","tags":"","loc":"proc/lsfwithmphonons.html","title":"lsfWithMphonons – Carrier Cross Sections"},{"text":"public subroutine decimalToOther(iDec, n, iBase, other) Convert an input number in base 10 to an n digit number in base iBase . The number\n is returned in the length n vector other . Todo Figure out why array is reversed Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) Contents Variables m j Variables Type Visibility Attributes Name Initial integer, public :: m integer, public :: j","tags":"","loc":"proc/decimaltoother.html","title":"decimalToOther – Carrier Cross Sections"},{"text":"public subroutine calculateDE(maxM, iEbins, de) Calculate the maximum number of bins the\n energy spectrum can be split into such that\n no bin is empty then return the size de of\n the resulting bin Generate factors of nEnergies","tags":"","loc":"proc/calculatede.html","title":"calculateDE – Carrier Cross Sections"},{"text":"public subroutine lsfMbyOneBand(M) Calculate the line shape function for \n various sets \\{p_j\\} where all p_j are zero except one that has values -M, M Arguments Type Intent Optional Attributes Name integer, intent(in) :: M Number of phonons Contents Variables iMode1 pm1 t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: iMode1 integer, public :: pm1 real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfmbyoneband.html","title":"lsfMbyOneBand – Carrier Cross Sections"},{"text":"public subroutine lsfMbyTwoBands(m) Calculate the line shape function for \n various sets \\{p_j\\} where all p_j are zero except two that have values\n such that the total number of phonons (plus or minus) in\n the two bands is 3 Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables iMode1 iMode2 pm1 pm2 l t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: iMode1 integer, public :: iMode2 integer, public :: pm1 integer, public :: pm2 integer, public :: l real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfmbytwobands.html","title":"lsfMbyTwoBands – Carrier Cross Sections"},{"text":"public subroutine lsfMbyThreeBands(m) Calculate the line shape function for m phonons in 3 bands Background The number of ways to put kPhonons in nBands so that\n all bands have at least one phonon is the same as first putting\n a phonon in each band, then counting how many ways you can \n distribute the rest of the phonons. In other words, since the \n number of ways to distribute k phonons into n bands\n (empty or not) is {n+k-1\\choose k} and each of our n bands needs at least one phonon, we just \n replace the available phonons to distribute k with k-n to get {n+(k-n)-1\\choose (k-n)} = {k-1\\choose k-n} See this Quora article for more details. Walkthrough Determine the length of the pj0s array","tags":"","loc":"proc/lsfmbythreebands.html","title":"lsfMbyThreeBands – Carrier Cross Sections"},{"text":"public subroutine writeLSFandCrossSection() Write out the line shape function versus energy Todo Change the name of this subroutine to just writeLSF Todo Remove all of the extra stuff from this subroutine Arguments None Contents Variables iE E Variables Type Visibility Attributes Name Initial integer, public :: iE real(kind=dp), public :: E","tags":"","loc":"proc/writelsfandcrosssection.html","title":"writeLSFandCrossSection – Carrier Cross Sections"},{"text":"public subroutine init_random_seed() Arguments None Contents Variables seed n t Variables Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: seed (:) integer(kind=int32), public :: n integer, public :: t","tags":"","loc":"proc/init_random_seed.html","title":"init_random_seed – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy3() Figure out what mode each process should start ( iModeIs )\n and finish on ( iModeFs ) so that the resulting states are \n balanced between the processes Note If the number of processors is greater than the number of \n modes, only nModes-2 processes will actually be used Todo Merge this with parallelIsFsBy4 Todo Write a binomialCoefficient function Todo Change this to use available states instead of totalStates Arguments None Contents Variables parTotal parTotal2 totalStates states averageStatesPerProc i iState iproc Variables Type Visibility Attributes Name Initial real(kind=dp), public :: parTotal real(kind=dp), public :: parTotal2 real(kind=dp), public :: totalStates real(kind=dp), public :: states real(kind=dp), public :: averageStatesPerProc integer, public :: i integer, public :: iState integer, public :: iproc","tags":"","loc":"proc/parallelisfsby3.html","title":"parallelIsFsBy3 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy4() Figure out what mode each process should start ( iModeIs )\n and finish on ( iModeFs ) so that the resulting states are \n balanced between the processes Note If the number of processors is greater than the number of \n modes, only nModes-2 processes will actually be used Arguments None Contents Variables parTotal parTotal2 totalStates states averageStatesPerProc i iState iproc Variables Type Visibility Attributes Name Initial real(kind=dp), public :: parTotal real(kind=dp), public :: parTotal2 real(kind=dp), public :: totalStates real(kind=dp), public :: states real(kind=dp), public :: averageStatesPerProc integer, public :: i integer, public :: iState integer, public :: iproc","tags":"","loc":"proc/parallelisfsby4.html","title":"parallelIsFsBy4 – Carrier Cross Sections"},{"text":"public function lcg(s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer Contents None","tags":"","loc":"proc/lcg~2.html","title":"lcg – Carrier Cross Sections"},{"text":"public function msta1(x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer Contents Variables a0 f f0 f1 it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a0 real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn","tags":"","loc":"proc/msta1~2.html","title":"msta1 – Carrier Cross Sections"},{"text":"public function msta2(x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer Contents Variables a0 ejn f f0 f1 hmp obj it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a0 real(kind=dp), public :: ejn real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: hmp real(kind=dp), public :: obj integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn","tags":"","loc":"proc/msta2~2.html","title":"msta2 – Carrier Cross Sections"},{"text":"public function envj(n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents None","tags":"","loc":"proc/envj.html","title":"envj – Carrier Cross Sections"},{"text":"public subroutine readInputs() Arguments None Contents None","tags":"","loc":"proc/readinputs~4.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initializeLSF() Arguments None Contents Variables dummyD dummyI dummyC1 dummyC8 dummyC9 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dummyD integer, public :: dummyI character(len=1), public :: dummyC1 character(len=8), public :: dummyC8 character(len=9), public :: dummyC9","tags":"","loc":"proc/initializelsf~2.html","title":"initializeLSF – Carrier Cross Sections"},{"text":"public subroutine initialize() Arguments None Contents None","tags":"","loc":"proc/initialize~3.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkAndUpdateInput() Arguments None Contents Variables abortExecution Variables Type Visibility Attributes Name Initial logical, public :: abortExecution = .false.","tags":"","loc":"proc/checkandupdateinput~3.html","title":"checkAndUpdateInput – Carrier Cross Sections"},{"text":"public subroutine readPhonons() Arguments None Contents Variables iAtom iMode iq dummyD freqInTHz dummyC Variables Type Visibility Attributes Name Initial integer, public :: iAtom integer, public :: iMode integer, public :: iq real(kind=dp), public :: dummyD real(kind=dp), public :: freqInTHz character, public :: dummyC","tags":"","loc":"proc/readphonons~2.html","title":"readPhonons – Carrier Cross Sections"},{"text":"public subroutine computeGeneralizedDisplacements() Arguments None Contents Variables iq iMode iAtom Variables Type Visibility Attributes Name Initial integer, public :: iq integer, public :: iMode integer, public :: iAtom","tags":"","loc":"proc/computegeneralizeddisplacements~2.html","title":"computeGeneralizedDisplacements – Carrier Cross Sections"},{"text":"public subroutine computeVariables() Arguments None Contents Variables i j nm nb bi di bk dk Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: nm integer, public :: nb real(kind=dp), public, allocatable :: bi (:) real(kind=dp), public, allocatable :: di (:) real(kind=dp), public, allocatable :: bk (:) real(kind=dp), public, allocatable :: dk (:)","tags":"","loc":"proc/computevariables~2.html","title":"computeVariables – Carrier Cross Sections"},{"text":"public subroutine arrangeLargerToSmaller() Arguments None Contents Variables i iMode temp tmpr tmpi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iMode real(kind=dp), public, allocatable :: temp (:) real(kind=dp), public :: tmpr integer, public :: tmpi","tags":"","loc":"proc/arrangelargertosmaller~2.html","title":"arrangeLargerToSmaller – Carrier Cross Sections"},{"text":"public subroutine readMjs() Arguments None Contents Variables i iE0 iE numOfMjs dummyD1 dummyD2 Ee MjOfE MjOfE0 eBin DHifMin eifMin volume dummyC1 dummyC32 dummyC35 modeFolder Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iE0 integer, public :: iE integer, public :: numOfMjs real(kind=dp), public :: dummyD1 real(kind=dp), public :: dummyD2 real(kind=dp), public :: Ee real(kind=dp), public :: MjOfE real(kind=dp), public :: MjOfE0 real(kind=dp), public :: eBin real(kind=dp), public :: DHifMin real(kind=dp), public :: eifMin real(kind=dp), public :: volume character(len=1), public :: dummyC1 character(len=32), public :: dummyC32 character(len=35), public :: dummyC35 character(len=256), public :: modeFolder","tags":"","loc":"proc/readmjs.html","title":"readMjs – Carrier Cross Sections"},{"text":"public subroutine lsfDeterministicFourPhononsByFourBands() Arguments None Contents Variables ic iMode1 iMode2 iMode3 iMode4 pm1 pm2 pm3 pm4 t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: ic integer, public :: iMode1 integer, public :: iMode2 integer, public :: iMode3 integer, public :: iMode4 integer, public :: pm1 integer, public :: pm2 integer, public :: pm3 integer, public :: pm4 real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfdeterministicfourphononsbyfourbands~2.html","title":"lsfDeterministicFourPhononsByFourBands – Carrier Cross Sections"},{"text":"public subroutine lsfOfConfigurationPj() Arguments None Contents Variables iE j E Fj prodFj sumOverj besPj besRatio Variables Type Visibility Attributes Name Initial integer, public :: iE integer, public :: j real(kind=dp), public :: E real(kind=dp), public :: Fj real(kind=dp), public :: prodFj real(kind=dp), public :: sumOverj real(kind=dp), public :: besPj real(kind=dp), public :: besRatio","tags":"","loc":"proc/lsfofconfigurationpj~2.html","title":"lsfOfConfigurationPj – Carrier Cross Sections"},{"text":"public subroutine calculatePlusMinusStates(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l Contents Variables iDes other Variables Type Visibility Attributes Name Initial integer, public :: iDes integer, public :: other (0:l-1)","tags":"","loc":"proc/calculateplusminusstates~2.html","title":"calculatePlusMinusStates – Carrier Cross Sections"},{"text":"public subroutine distrubutePhononsInBands(m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l Contents Variables i i1 i2 i3 i4 i5 i6 i7 i8 i9 i10 i11 i12 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i1 integer, public :: i2 integer, public :: i3 integer, public :: i4 integer, public :: i5 integer, public :: i6 integer, public :: i7 integer, public :: i8 integer, public :: i9 integer, public :: i10 integer, public :: i11 integer, public :: i12","tags":"","loc":"proc/distrubutephononsinbands~2.html","title":"distrubutePhononsInBands – Carrier Cross Sections"},{"text":"public subroutine lsfWithMphonons(m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes Contents Variables ii iMC iM i pick j picks iE iDes iRand steps E Fj prodFj sumOverj besPj besRatio randy picked Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: iMC integer, public :: iM integer, public :: i integer, public :: pick integer, public :: j integer, public :: picks (l) integer, public :: iE integer, public :: iDes integer, public :: iRand integer, public :: steps real(kind=dp), public :: E real(kind=dp), public :: Fj real(kind=dp), public :: prodFj real(kind=dp), public :: sumOverj real(kind=dp), public :: besPj real(kind=dp), public :: besRatio real(kind=dp), public :: randy logical, public :: picked","tags":"","loc":"proc/lsfwithmphonons~2.html","title":"lsfWithMphonons – Carrier Cross Sections"},{"text":"public subroutine decimalToOther(iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) Contents Variables m j Variables Type Visibility Attributes Name Initial integer, public :: m integer, public :: j","tags":"","loc":"proc/decimaltoother~2.html","title":"decimalToOther – Carrier Cross Sections"},{"text":"public subroutine calculateDE(maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de Contents Variables iE j ic ib iEmMax nSteps jMax iEstep tmpB iEsteps empty Variables Type Visibility Attributes Name Initial integer, public :: iE integer, public :: j integer, public :: ic integer, public :: ib integer, public :: iEmMax integer, public :: nSteps integer, public :: jMax integer, public :: iEstep integer, public, allocatable :: tmpB (:) integer, public, allocatable :: iEsteps (:) logical, public :: empty","tags":"","loc":"proc/calculatede~2.html","title":"calculateDE – Carrier Cross Sections"},{"text":"public subroutine lsfMbyOneBand(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables iMode1 pm1 t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: iMode1 integer, public :: pm1 real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfmbyoneband~2.html","title":"lsfMbyOneBand – Carrier Cross Sections"},{"text":"public subroutine lsfMbyTwoBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables iMode1 iMode2 pm1 pm2 l t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: iMode1 integer, public :: iMode2 integer, public :: pm1 integer, public :: pm2 integer, public :: l real(kind=dp), public :: t1 real(kind=dp), public :: t2","tags":"","loc":"proc/lsfmbytwobands~2.html","title":"lsfMbyTwoBands – Carrier Cross Sections"},{"text":"public subroutine lsfMbyThreeBands(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Contents Variables t1 t2 times3 iMode1 iMode2 iMode3 ni mi iDes ii Variables Type Visibility Attributes Name Initial real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: times3 integer, public :: iMode1 integer, public :: iMode2 integer, public :: iMode3 integer, public :: ni integer, public :: mi integer, public :: iDes integer, public :: ii","tags":"","loc":"proc/lsfmbythreebands~2.html","title":"lsfMbyThreeBands – Carrier Cross Sections"},{"text":"public subroutine writeLSFandCrossSection() Arguments None Contents Variables iE E Variables Type Visibility Attributes Name Initial integer, public :: iE real(kind=dp), public :: E","tags":"","loc":"proc/writelsfandcrosssection~2.html","title":"writeLSFandCrossSection – Carrier Cross Sections"},{"text":"public subroutine init_random_seed() Arguments None Contents Variables seed n t Variables Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: seed (:) integer(kind=int32), public :: n integer, public :: t","tags":"","loc":"proc/init_random_seed~2.html","title":"init_random_seed – Carrier Cross Sections"},{"text":"public subroutine iknb(n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) Contents Variables bs el f f0 f1 k m ik pi s0 sk0 ifact Variables Type Visibility Attributes Name Initial double precision, public :: bs double precision, public :: el double precision, public :: f double precision, public :: f0 double precision, public :: f1 integer, public :: k integer, public :: m integer, public :: ik double precision, public :: pi double precision, public :: s0 double precision, public :: sk0 double precision, public :: ifact","tags":"","loc":"proc/iknb~2.html","title":"iknb – Carrier Cross Sections"},{"text":"public subroutine iknb2(n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) Contents Variables pi el a0 bkl bs f f0 f1 g g0 g1 r s0 sk0 vt k k0 l m Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 3.141592653589793_dp real(kind=dp), public, parameter :: el = 0.5772156649015329_dp real(kind=dp), public :: a0 real(kind=dp), public :: bkl real(kind=dp), public :: bs real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: g real(kind=dp), public :: g0 real(kind=dp), public :: g1 real(kind=dp), public :: r real(kind=dp), public :: s0 real(kind=dp), public :: sk0 real(kind=dp), public :: vt integer, public :: k integer, public :: k0 integer, public :: l integer, public :: m","tags":"","loc":"proc/iknb2.html","title":"iknb2 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy3() Arguments None Contents Variables parTotal parTotal2 totalStates states averageStatesPerProc i iState iproc Variables Type Visibility Attributes Name Initial real(kind=dp), public :: parTotal real(kind=dp), public :: parTotal2 real(kind=dp), public :: totalStates real(kind=dp), public :: states real(kind=dp), public :: averageStatesPerProc integer, public :: i integer, public :: iState integer, public :: iproc","tags":"","loc":"proc/parallelisfsby3~2.html","title":"parallelIsFsBy3 – Carrier Cross Sections"},{"text":"public subroutine parallelIsFsBy4() Arguments None Contents Variables parTotal parTotal2 totalStates states averageStatesPerProc i iState iproc Variables Type Visibility Attributes Name Initial real(kind=dp), public :: parTotal real(kind=dp), public :: parTotal2 real(kind=dp), public :: totalStates real(kind=dp), public :: states real(kind=dp), public :: averageStatesPerProc integer, public :: i integer, public :: iState integer, public :: iproc","tags":"","loc":"proc/parallelisfsby4~2.html","title":"parallelIsFsBy4 – Carrier Cross Sections"},{"text":"public subroutine readInputs() Read input parameters and read LSF and TME output Walkthrough Check if an output file exists; if it does, delete it Open new output file Set default values of input parameters Read in input parameters Check if input parameters were updated\n   and do some basic checks Read the LSF output Read the TME output Arguments None Contents Source Code readInputs Source Code subroutine readInputs () !! Read input parameters and read LSF and TME output !! !! <h2>Walkthrough</h2> !! implicit none ! !> * Check if an output file exists; if it does, delete it inquire ( file = output , exist = file_exists ) ! if ( file_exists ) then ! open ( unit = 11 , file = output , status = \"old\" ) ! close ( unit = 11 , status = \"delete\" ) ! endif ! open ( iostd , file = output , status = 'new' ) !! * Open new output file ! call initialize () !! * Set default values of input parameters ! READ ( 5 , elphscat , iostat = ios ) !! * Read in input parameters ! call checkInputAndUpdateParameters () !! * Check if input parameters were updated !!   and do some basic checks ! call readLSF () !! * Read the LSF output ! call readVfis () !! * Read the TME output ! return ! end subroutine readInputs","tags":"","loc":"proc/readinputs~3.html","title":"readInputs – Carrier Cross Sections"},{"text":"public subroutine initialize() Set default values for input parameters Arguments None Contents Source Code initialize Source Code subroutine initialize () !! Set default values for input parameters ! implicit none ! VfisInput = '' LSFinput = '' crossSectionOutput = '' ! de = maxEnergy * eVToHartree / real ( nOfEnergyBins , dp ) ! return ! end subroutine initialize","tags":"","loc":"proc/initialize~4.html","title":"initialize – Carrier Cross Sections"},{"text":"public subroutine checkInputAndUpdateParameters() Check that the input variables don't still have their default\n values. If the input files are not defined, end the program. Arguments None Contents Source Code checkInputAndUpdateParameters Source Code subroutine checkInputAndUpdateParameters () !! Check that the input variables don't still have their default !! values. If the input files are not defined, end the program. ! implicit none ! if ( VfisInput == '' ) then write ( iostd , '(\" Vfi elements input (input variable VfisInput) is not defined!\")' ) else inquire ( file = trim ( VfisInput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" Vfi elements input : \", a)' ) trim ( VfisInput ) else write ( iostd , '(\" Vfi elements input : \", a, \" does not exist!\")' ) trim ( VfisInput ) endif endif ! if ( LSFinput == '' ) then write ( iostd , '(\" LSF input (input variable LSFinput) is not defined!\")' ) else inquire ( file = trim ( LSFinput ), exist = file_exists ) if ( file_exists ) then write ( iostd , '(\" LSF input : \", a)' ) trim ( LSFinput ) else write ( iostd , '(\" LSF input : \", a, \" does not exist!\")' ) trim ( LSFinput ) endif endif ! if ( crossSectionOutput == '' ) then write ( iostd , '(\" crossSectionOutput is not defined! File name : crossSection, will be used.\")' ) crossSectionOutput = 'crossSection' else write ( iostd , '(\" Cross section output file name : \", a)' ) trim ( crossSectionOutput ) endif ! if ( ( VfisInput == '' ) . or . ( LSFinput == '' ) ) then ! write ( iostd , '(\" One or both of the input files is not defined! \")' ) write ( iostd , '(\" ********************************************** \")' ) write ( iostd , '(\" *               Program stops!               * \")' ) write ( iostd , '(\" *       Please check the output file.        * \")' ) write ( iostd , '(\" ********************************************** \")' ) ! stop ! endif ! flush ( iostd ) ! return ! end subroutine checkInputAndUpdateParameters","tags":"","loc":"proc/checkinputandupdateparameters.html","title":"checkInputAndUpdateParameters – Carrier Cross Sections"},{"text":"public subroutine readLSF() Read LSF output Walkthrough Open the LSF output file Read in the number of energies and ?? For each energy, read in the energy value as well as lsfVsE and lsfVsEbyPhonon Arguments None Contents Variables dummyC1 dummyC8 dummyC9 ee iE Source Code readLSF Variables Type Visibility Attributes Name Initial character(len=1), public :: dummyC1 character(len=8), public :: dummyC8 character(len=9), public :: dummyC9 Todo Merge these dummy characters real(kind=dp), public :: ee Energy in eV integer, public :: iE Loop index over energies Source Code subroutine readLSF () !! Read LSF output !! !! <h2>Walkthrough</h2> !! implicit none ! character ( len = 1 ) :: dummyC1 character ( len = 8 ) :: dummyC8 character ( len = 9 ) :: dummyC9 !! @todo Merge these dummy characters @endtodo ! real ( kind = dp ) :: ee !! Energy in eV ! integer :: iE !! Loop index over energies ! open ( 1 , file = trim ( LSFinput ), status = 'old' ) !! * Open the LSF output file ! read ( 1 , '(a1, i10, a9, i5, a8)' ) dummyC1 , nEnergies , dummyC9 , m , dummyC8 !! * Read in the number of energies and ?? ! allocate ( E ( - nEnergies : nEnergies ), lsfVsE ( - nEnergies : nEnergies ), lsfVsEbyPhonon ( - nEnergies : nEnergies ) ) ! do iE = - nEnergies , nEnergies !! * For each energy, read in the energy value as well as `lsfVsE` and `lsfVsEbyPhonon` ! read ( 1 , '(F16.8,2E18.6e3)' ) ee , lsfVsE ( iE ), lsfVsEbyPhonon ( iE ) E ( iE ) = ee * eVToHartree ! enddo ! close ( 1 ) ! end subroutine readLSF","tags":"","loc":"proc/readlsf.html","title":"readLSF – Carrier Cross Sections"},{"text":"public subroutine readVfis() Read TME output, get Vfis and lsf using the same index,\n and output the results to two output files Note This subroutine does not line up with what is output from the TME program,\n so I'm not 100% sure where the input is coming from or what it's supposed\n to be Walkthrough Ignore the first line as it is a comment Read cell volume Read minimum transition energy Read |\\Delta H_{if}|&#94;2 at min transition energy Read energy bin size Ignore the next line as it is a comment Read in nOfEnergies ? Read in the initial values of energy and Vfis Calculate the energy index For each energy Read in energy and VFiOfE Calculate the indices needed to get VFis and lsfVsE using the same index Average lsf over those indices and store \n  in a single index matching that of Vfis Todo Figure out where this file is opened For each energy, output the energy in eV, Vfis and lsf Todo Figure out where this file is opened Arguments None Contents Variables i iE0 iE dummyD1 dummyD2 Ee VfiOfE VfiOfE0 eBin dummyC1 dummyC32 dummyC35 Source Code readVfis Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iE0 integer, public :: iE real(kind=dp), public :: dummyD1 real(kind=dp), public :: dummyD2 real(kind=dp), public :: Ee real(kind=dp), public :: VfiOfE real(kind=dp), public :: VfiOfE0 real(kind=dp), public :: eBin character(len=1), public :: dummyC1 character(len=32), public :: dummyC32 character(len=35), public :: dummyC35 Todo Merge dummy variables Source Code subroutine readVfis () !! Read TME output, get `Vfis` and `lsf` using the same index, !! and output the results to two output files !! !! @note !! This subroutine does not line up with what is output from the TME program, !! so I'm not 100% sure where the input is coming from or what it's supposed !! to be !! @endnote !! !! <h2>Walkthrough</h2> !! implicit none ! integer :: i , iE0 , iE real ( kind = dp ) :: dummyD1 , dummyD2 , Ee , VfiOfE , VfiOfE0 , eBin character ( len = 1 ) :: dummyC1 character ( len = 32 ) :: dummyC32 character ( len = 35 ) :: dummyC35 !! @todo Merge dummy variables @endtodo ! open ( 1 , file = trim ( VfisInput ), status = \"old\" ) ! !read(1, '(a1, i10, a9, f15.4, a16)') dummyC1, nEVfi, dummyC9, volume, dummyC16 ! read ( 1 , * ) !! * Ignore the first line as it is a comment ! read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , volume , dummyC35 !! * Read cell volume ! read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eifMin , dummyC35 !! * Read minimum transition energy ! read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , DHifMin , dummyC35 !! * Read |\\Delta H_{if}|&#94;2 at min transition energy ! read ( 1 , '(a32, ES24.15E3, a35)' ) dummyC32 , eBin , dummyC35 !! * Read energy bin size ! read ( 1 , * ) !! * Ignore the next line as it is a comment ! read ( 1 , '(i10)' ) numOfVfis !! * Read in `nOfEnergies`? ! allocate ( Vfis ( 0 : numOfVfis ), energy ( 0 : numOfVfis ), lsf ( 0 : numOfVfis ) ) ! Vfis (:) = 0.0_dp energy (:) = 0.0_dp lsf (:) = 0.0_dp ! read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE0 , dummyD1 Vfis ( 1 ) = VfiOfE0 energy ( 1 ) = Ee !! * Read in the initial values of energy and `Vfis` ! iE = int ( Ee / de ) + 1 !! * Calculate the energy index ! do i = 2 , numOfVfis !! * For each energy !!    * Read in energy and `VFiOfE` !!    * Calculate the indices needed to get `VFis` !!      and `lsfVsE` using the same index !!    * Average `lsf` over those indices and store !!      in a single index matching that of `Vfis` ! iE0 = iE ! int(energy(i-1)/deltaE) + 1 !  iE ! read ( 1 , '(3ES24.15E3)' ) Ee , VfiOfE , dummyD2 ! energy ( i ) = Ee ! iE = int ( Ee / de ) + 1 ! !Vfis(iE0:iE) = VfiOfE0 Vfis ( i ) = VfiOfE !VfiOfE0 = VfiOfE ! lsf ( i - 1 ) = sum ( lsfVsE ( iE0 : iE )) / ( iE - iE0 + 1 ) ! write ( 26 , * ) E ( iE0 ), Ee , lsf ( i ) ! sum(lsfVsE(iE0:iE))/(iE-iE0+1) !! @todo Figure out where this file is opened @endtodo ! enddo ! close ( 1 ) close ( 26 ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies !! * For each energy, output the energy in eV, `Vfis` and `lsf` ! write ( 44 , * ) energy ( iE ) * HartreeToEv , Vfis ( iE ), lsf ( iE ) !! @todo Figure out where this file is opened @endtodo ! enddo ! close ( 44 ) ! return ! end subroutine readVfis","tags":"","loc":"proc/readvfis.html","title":"readVfis – Carrier Cross Sections"},{"text":"public subroutine calculateSigma() Calculate the index for the min energy Output the min energy in Hartree and eV as well as energy index Todo Figure out where this file is opened Calculate min energy \\sigma Todo Figure out what abCM is Output the minimum energy and the cross section at that energy Calculate \\sigma(E) = \\dfrac{2\\pi*\\text{abCM}&#94;2*\\Omega}{\\hbar v_g}|M_e&#94;{BO}|&#94;2|_{if} Arguments None Contents Variables iE vg sigma0 Source Code calculateSigma Variables Type Visibility Attributes Name Initial integer, public :: iE real(kind=dp), public :: vg real(kind=dp), public :: sigma0 Source Code subroutine calculateSigma () ! implicit none ! integer :: iE real ( kind = dp ) :: vg , sigma0 ! allocate ( sigma ( numOfVfis ) ) ! , sigmaByPhonon(-nEnergies:nEnergies) ) !allocate( sigma(-nEnergies:nEnergies), sigmaByPhonon(-nEnergies:nEnergies) ) ! iE = int ( eifMin / de ) + 1 !! * Calculate the index for the min energy ! write ( 6 , * ) eifMin , eifMin * HartreeToEv , iE !! * Output the min energy in Hartree and eV as well as energy index !! @todo Figure out where this file is opened @endtodo ! sigma0 = twoPi * abCM ** 2 * volume * DHifMin * lsfVsE ( iE ) / sqrt ( 2.0_dp * E ( iE )) !! * Calculate min energy \\sigma !! @todo Figure out what `abCM` is @endtodo ! !do iE = 1, numOfVfis ! -nEnergies, nEnergies - 1 !  if ( (E(iE) < eifMin).and.(E(iE+1) > eifMin) ) sigma0 = twoPi*abCM**2*volume*DHifMin*lsfVsE(iE)/sqrt(2.0_dp*E(iE)) !enddo ! write ( 6 , * ) eifMin * HartreeToEv , sigma0 !! * Output the minimum energy and the cross section at that energy ! sigma (:) = 0.0_dp ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies !! * Calculate \\sigma(E) = \\dfrac{2\\pi*\\text{abCM}&#94;2*\\Omega}{\\hbar v_g}|M_e&#94;{BO}|&#94;2|_{if} ! vg = 1.0_dp ! if ( energy ( iE ) > 0.0_dp ) vg = sqrt ( 2.0_dp * energy ( iE )) ! !write(6,*) iE, energy(iE), vg, Vfis(iE), lsf(iE) sigma ( iE ) = twoPi * abCM ** 2 * volume * Vfis ( iE ) * lsf ( iE ) / vg !sigma(iE)         = twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg !sigmaByPhonon(iE) = twoPi*abCM**2*volume*Vfis(iE)*lsfVsEbyPhonon(iE)/vg ! enddo ! return ! end subroutine calculateSigma","tags":"","loc":"proc/calculatesigma.html","title":"calculateSigma – Carrier Cross Sections"},{"text":"public subroutine writeSigma() Write the energy and \\sigma(E) Arguments None Contents Variables iE Source Code writeSigma Variables Type Visibility Attributes Name Initial integer, public :: iE Source Code subroutine writeSigma () !! Write the energy and \\sigma(E) ! implicit none ! integer :: iE ! open ( 2 , file = trim ( crossSectionOutput ), status = 'unknown' ) ! do iE = 0 , numOfVfis ! -nEnergies, nEnergies ! write ( 2 , * ) energy ( iE ) * HartreeToEv , sigma ( iE ) !, sigmaByPhonon(iE) !write(2,*) E(iE), sigma(iE), sigmaByPhonon(iE) ! enddo ! close ( 2 ) ! return ! end subroutine writeSigma","tags":"","loc":"proc/writesigma.html","title":"writeSigma – Carrier Cross Sections"},{"text":"public function msta1(x, mp) result(fn_val) Determine the starting point for backward \n recurrence such that the magnitude of J_n(x) at that point is about 10&#94;{-\\text{mp}} Walkthrough Get initial guess for f = -log(J_{n_0}(a_0)) - \\text{mp} Get next guess for f Recursively minimize f Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Argument of J_n(x) integer, intent(in) :: mp Magnitude Return Value integer Starting point Contents Variables it n0 n1 nn a0 f f0 f1 Source Code msta1 Variables Type Visibility Attributes Name Initial integer, public :: it Loop index integer, public :: n0 Order of Bessel function integer, public :: n1 Order of Bessel function integer, public :: nn Order of Bessel function real(kind=dp), public :: a0 |x| real(kind=dp), public :: f -\\log(J_n(x)) - \\text{mp} real(kind=dp), public :: f0 -\\log(J_n(x)) - \\text{mp} real(kind=dp), public :: f1 -\\log(J_n(x)) - \\text{mp} Source Code function msta1 ( x , mp ) result ( fn_val ) !! Determine the starting point for backward !! recurrence such that the magnitude of !! J_n(x) at that point is about !! 10&#94;{-\\text{mp}} !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: mp !! Magnitude integer :: fn_val !! Starting point integer :: it !! Loop index integer :: n0 , n1 , nn !! Order of Bessel function ! real ( kind = dp ), intent ( in ) :: x !! Argument of J_n(x) real ( kind = dp ) :: a0 !! |x| real ( kind = dp ) :: f , f0 , f1 !! -\\log(J_n(x)) - \\text{mp} ! a0 = abs ( x ) ! n0 = int ( 1.1 * a0 ) + 1 ! f0 = envj ( n0 , a0 ) - mp !! * Get initial guess for f = -log(J_{n_0}(a_0)) - \\text{mp} ! n1 = n0 + 5 ! f1 = envj ( n1 , a0 ) - mp !! * Get next guess for f ! do it = 1 , 20 !! * Recursively minimize f ! nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) ! f = envj ( nn , a0 ) - mp ! if ( abs ( nn - n1 ) < 1 ) exit ! n0 = n1 ! f0 = f1 ! n1 = nn ! f1 = f ! enddo ! fn_val = nn ! return ! end function msta1","tags":"","loc":"proc/msta1.html","title":"msta1 – Carrier Cross Sections"},{"text":"public function msta2(x, n, mp) result(fn_val) Determine the starting point for backward \n recurrence such that all J_n(x) has mp\n significant digits Walkthrough Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Argument of J_n(x) integer, intent(in) :: n Order of J_n(x) integer, intent(in) :: mp Significant digit Return Value integer Starting point Contents Variables it n0 n1 nn a0 ejn f f0 f1 hmp obj Source Code msta2 Variables Type Visibility Attributes Name Initial integer, public :: it integer, public :: n0 integer, public :: n1 integer, public :: nn real(kind=dp), public :: a0 real(kind=dp), public :: ejn real(kind=dp), public :: f real(kind=dp), public :: f0 real(kind=dp), public :: f1 real(kind=dp), public :: hmp real(kind=dp), public :: obj Source Code function msta2 ( x , n , mp ) result ( fn_val ) !! Determine the starting point for backward !! recurrence such that all J_n(x) has mp !! significant digits !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: n !! Order of J_n(x) integer , intent ( in ) :: mp !! Significant digit integer :: fn_val !! Starting point integer :: it , n0 , n1 , nn ! real ( kind = dp ), intent ( in ) :: x !! Argument of J_n(x) real ( kind = dp ) :: a0 , ejn , f , f0 , f1 , hmp , obj ! a0 = ABS ( x ) ! hmp = 0.5_dp * mp ! ejn = envj ( n , a0 ) ! if ( ejn <= hmp ) then ! obj = mp ! n0 = int ( 1.1 * a0 ) ! else ! obj = hmp + ejn ! n0 = n ! endif ! if ( n0 < 1 ) n0 = 1 ! f0 = envj ( n0 , a0 ) - obj ! n1 = n0 + 5 ! f1 = envj ( n1 , a0 ) - obj ! do it = 1 , 20 ! nn = n1 - int (( n1 - n0 ) / ( 1.0_dp - f0 / f1 )) ! f = envj ( nn , a0 ) - obj ! if ( abs ( nn - n1 ) < 1 ) exit ! n0 = n1 ! f0 = f1 ! n1 = nn ! f1 = f ! enddo ! fn_val = nn + 10 ! return ! end function msta2","tags":"","loc":"proc/msta2.html","title":"msta2 – Carrier Cross Sections"},{"text":"public function envj(n, x) result(fn_val) Estimates -\\log(J_n(x)) from the estimate J_n(x) \\approx \\dfrac{1}{\\sqrt{2\\pi n}}\\left(\\dfrac{ex}{2n}\\right)&#94;n Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Order of Bessel function real(kind=dp), intent(in) :: x Argument Return Value real(kind=dp) -\\log(J_n(x)) Contents Source Code envj Source Code function envj ( n , x ) result ( fn_val ) !! Estimates -\\log(J_n(x)) from the estimate !! J_n(x) \\approx \\dfrac{1}{\\sqrt{2\\pi n}}\\left(\\dfrac{ex}{2n}\\right)&#94;n ! implicit none ! integer , intent ( in ) :: n !! Order of Bessel function real ( kind = dp ), intent ( in ) :: x !! Argument real ( kind = dp ) :: fn_val !! -\\log(J_n(x)) ! fn_val = 0.5_dp * log10 ( 6.28_dp * n ) - n * log10 ( 1.36_dp * x / n ) ! 6.28 = 2\\pi and 1.36 = e/2 ! return ! end function envj","tags":"","loc":"proc/envj~2.html","title":"envj – Carrier Cross Sections"},{"text":"public subroutine computeGeneralizedDisplacements(nOfqPoints, nModes, genCoord, nAtoms, atomM, phonD, atomD) Calculate the generalized displacements\n by dotting the phonon displacements with\n the atom displacements Walkthrough For each q point, mode, and atom combination, calculate\n   the generalized displacement as \\sum_{\\text{mode}} \\sqrt{1823m}\\mathbf{\\Delta r}_{\\text{phonon}}\\cdot\\mathbf{\\Delta r}_{\\text{atom}} Note The 1822.88833218_dp is a conversion factor from atomic mass units to Hartree Todo Make mass conversion factor a constant parameter for clarity Arguments Type Intent Optional Attributes Name integer, intent(in) :: nOfqPoints Number of q points integer, intent(in) :: nModes Number of phonon modes real(kind=dp), intent(out) :: genCoord (nModes) Generalized coordinates \\delta q_j integer, intent(in) :: nAtoms Number of atoms in system real(kind=dp), intent(in) :: atomM (nAtoms) Atom masses real(kind=dp), intent(in) :: phonD (3,nAtoms,nModes,nOfqPoints) Phonon displacements real(kind=dp), intent(in) :: atomD (3,nAtoms) Equilibrium displacements in defect versus pristine Contents Variables iAtom iMode iq Source Code computeGeneralizedDisplacements Variables Type Visibility Attributes Name Initial integer, public :: iAtom Loop index over atoms integer, public :: iMode Loop index over phonon modes integer, public :: iq Loop index over q points Source Code subroutine computeGeneralizedDisplacements ( nOfqPoints , nModes , genCoord , nAtoms , atomM , phonD , atomD ) !! Calculate the generalized displacements !! by dotting the phonon displacements with !! the atom displacements !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: nAtoms !! Number of atoms in system integer , intent ( in ) :: nModes !! Number of phonon modes integer , intent ( in ) :: nOfqPoints !! Number of q points integer :: iAtom !! Loop index over atoms integer :: iMode !! Loop index over phonon modes integer :: iq !! Loop index over q points ! real ( kind = dp ), intent ( in ) :: atomD ( 3 , nAtoms ) !! Equilibrium displacements in defect versus pristine real ( kind = dp ), intent ( in ) :: atomM ( nAtoms ) !! Atom masses real ( kind = dp ), intent ( out ) :: genCoord ( nModes ) !! Generalized coordinates \\delta q_j real ( kind = dp ), intent ( in ) :: phonD ( 3 , nAtoms , nModes , nOfqPoints ) !! Phonon displacements ! do iq = 1 , nOfqPoints ! do iMode = 1 , nModes ! genCoord ( iMode ) = 0.0_dp ! do iAtom = 1 , nAtoms !! * For each q point, mode, and atom combination, calculate !!   the generalized displacement as !!   \\sum_{\\text{mode}} \\sqrt{1823m}\\mathbf{\\Delta r}_{\\text{phonon}}\\cdot\\mathbf{\\Delta r}_{\\text{atom}} ! genCoord ( iMode ) = genCoord ( iMode ) + sqrt ( 182 2.88833218_dp * atomM ( iAtom )) * sum ( phonD (:, iAtom , iMode , iq ) * atomD (:, iAtom )) !! @note The `1822.88833218_dp` is a conversion factor from atomic mass units to Hartree @endnote !! @todo Make mass conversion factor a constant parameter for clarity @endtodo ! enddo ! enddo ! enddo ! return ! end subroutine computeGeneralizedDisplacements","tags":"","loc":"proc/computegeneralizeddisplacements.html","title":"computeGeneralizedDisplacements – Carrier Cross Sections"},{"text":"public subroutine computeVariables(x, Sj, coth, wby2kT, phonF, genCoord, kT, s2L, nModes, maximumNumberOfPhonons, besOrderNofModeM) Uses miscUtilities Calculate biggest portions of equations 42 and 43 to make\n entire equation more manageable Walkthrough Include miscUtilities module for call to arrangeLargerToSmaller Calculate S_j = \\dfrac{\\omega_j}{2\\hbar}N\\delta q_j&#94;2 where \\omega_i\\rightarrow phonF(j) , \\delta q_j\\rightarrow genCoord(j) , and N is the number of atoms per supercell Note This is equation 44 in the paper Todo Figure out why there is no N in this equation in the code Calculate \\hbar\\omega_j/2kT that is the argument \n   to hyperbolic trig functions Note This is mainly from equations 42 and 43 in the paper Calculate \\coth(\\hbar\\omega_j/2kT) Note This is in equation 42 in the paper Todo Figure out if this needs to be another variable Calculate the argument to the modified Bessel functions \\dfrac{S_j}{\\sinh(\\hbar\\omega_j/2kT)} Create an array of the indices that will be rearranged Rearrange the indices based on ordering the arguments ( x )\n   largest to smallest Todo Frequency should actually be in eV/ \\hbar . Check that that's the case. Write out the index, \\omega_j in eV, \\delta q_j , \\delta q_j&#94;2 , \n   and S_j/\\sinh(\\hbar\\omega_j/2kT) for each phonon mode Todo Figure out why this is assigned to another variable Todo Figure out if still need di , bk , and dk Todo Figure out if need to have this in loop. Why change nm in iknb ? Todo Figure out if should send nm as it is immediately modified and not used here Store the modified Bessel function for each mode and order Todo Possibly change besOrderNofModeM to modBesOrderNofModeM Todo Figure out why this loop is here. Can not just pass besOrderNofModeM(:,j)","tags":"","loc":"proc/computevariables.html","title":"computeVariables – Carrier Cross Sections"},{"text":"public subroutine iknb(n, x, nm, bi) * * * * * * * * * * 72 IKNB compute Bessel function In(x) and Kn(x). Discussion Compute modified Bessel functions In ( x ) and Kn ( x ), and their derivatives . Licensing This routine is copyrighted by Shanjie Zhang and Jianming Jin . However , they give permission to incorporate this routine into a user program provided that the copyright is acknowledged . Reference Shanjie Zhang , Jianming Jin , Computation of Special Functions , Wiley , 1996 , ISBN : 0 - 471 - 11963 - 6 , LC : QA351 . C45 . Walkthrough If x < 10&#94;{-15} , use the limiting value for  a small argument I_n(x) \\approx \\left(\\dfrac{x}{2}\\right)&#94;2\\Gamma(n+1) where \\Gamma(n+1) = n! to calculate multiple orders of the \n   modified Bessel function (up to n ) for a single value of x Otherwise, get the starting order m such\n   that J_n(x)\\approx10&#94;{-200} If m is less than the max order to be \n   calculated, set the max to m Otherwise, set m to the starting order such\n   that all J_{nm}(x) have 15 significant digits Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Order of I_n(x) and K_n(x) double precision :: x The argument integer, intent(inout) :: nm The highest order computed double precision :: bi (0:n) I_n(x) Contents Variables ik k m bs el f fact f0 f1 pi s0 sk0 Source Code iknb Variables Type Visibility Attributes Name Initial integer, public :: ik integer, public :: k integer, public :: m double precision, public :: bs double precision, public :: el double precision, public :: f double precision, public :: fact double precision, public :: f0 double precision, public :: f1 double precision, public :: pi double precision, public :: s0 double precision, public :: sk0 Source Code subroutine iknb ( n , x , nm , bi ) !, di, bk, dk ) !! author: Shanjie Zhang, Jianming Jin !! date: 17 July 2012 ! ! Modified : when x < 10&#94;(-15) return the limiting value for small argument [ I_n(x) ~ (x/2)&#94;n Gamma(n+1) ] ! !*********************************************************************72 ! !! IKNB compute Bessel function In(x) and Kn(x). !! !!  <h2>Discussion</h2> !! !!    Compute modified Bessel functions In(x) and Kn(x), !!    and their derivatives. !! !!  <h2>Licensing</h2> !! !!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !!    they give permission to incorporate this routine into a user program !!    provided that the copyright is acknowledged. !! !! !!  <h2>Reference</h2> !! !!    Shanjie Zhang, Jianming Jin, !!    Computation of Special Functions, !!    Wiley, 1996, !!    ISBN: 0-471-11963-6, !!    LC: QA351.C45. !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( in ) :: n !! Order of I_n(x) and K_n(x) integer , intent ( inout ) :: nm !! The highest order computed integer :: ik integer :: k !    integer :: k0 !    integer :: l integer :: m !    integer :: msta1 !    integer :: msta2 ! !    double precision :: a0 double precision :: bi ( 0 : n ) !! I_n(x) !    double precision :: bkl double precision :: bs double precision :: el double precision :: f double precision :: fact double precision :: f0 double precision :: f1 !    double precision :: g !    double precision :: g0 !    double precision :: g1 double precision :: pi !    double precision :: r double precision :: s0 double precision :: sk0 !    double precision :: vt double precision :: x !! The argument ! pi = 3.141592653589793D+00 el = 0.5772156649015329D+00 nm = n ! if ( x . le . 1.0D-15 ) then !! * If x < 10&#94;{-15}, use the limiting value for  a small argument !!   I_n(x) \\approx \\left(\\dfrac{x}{2}\\right)&#94;2\\Gamma(n+1) !!   where \\Gamma(n+1) = n! to calculate multiple orders of the !!   modified Bessel function (up to n) for a single value of x ! do k = 0 , n ! For each order ! fact = 1.0_dp ! do ik = 2 , k ! Calculate the factorial ! fact = fact * ik ! enddo ! bi ( k ) = ( 0.5_dp * x ) ** k / fact ! Calculate I_n(x) ! enddo ! return ! endif ! if ( n . eq . 0 ) then ! nm = 1 ! end if ! m = msta1 ( x , 200 ) !! * Otherwise, get the starting order m such !!   that J_n(x)\\approx10&#94;{-200} ! if ( m . lt . nm ) then !! * If m is less than the max order to be !!   calculated, set the max to m ! nm = m ! else !! * Otherwise, set m to the starting order such !!   that all J_{nm}(x) have 15 significant digits ! m = msta2 ( x , nm , 15 ) ! end if ! bs = 0.0D+00 sk0 = 0.0D+00 f0 = 0.0D+00 f1 = 1.0D-100 ! do k = m , 0 , - 1 ! f = 2.0D+00 * ( k + 1.0D+00 ) / x * f1 + f0 ! if ( k . le . nm ) then ! bi ( k ) = f ! end if ! if ( k . ne . 0 . and . k . eq . 2 * int ( k / 2 ) ) then ! sk0 = sk0 + 4.0D+00 * f / k ! end if ! bs = bs + 2.0D+00 * f ! f0 = f1 ! f1 = f ! enddo ! s0 = exp ( x ) / ( bs - f ) ! do k = 0 , nm ! bi ( k ) = s0 * bi ( k ) ! end do ! return end subroutine iknb","tags":"","loc":"proc/iknb.html","title":"iknb – Carrier Cross Sections"},{"text":"public subroutine int2str(integ, string) Write a given integer to a string, using only as many digits as needed Arguments Type Intent Optional Attributes Name integer :: integ character(len=300) :: string Contents Source Code int2str Source Code subroutine int2str ( integ , string ) !! Write a given integer to a string, using only as many digits as needed ! implicit none integer :: integ character ( len = 300 ) :: string ! if ( integ < 10 ) then write ( string , '(i1)' ) integ else if ( integ < 100 ) then write ( string , '(i2)' ) integ else if ( integ < 1000 ) then write ( string , '(i3)' ) integ else if ( integ < 10000 ) then write ( string , '(i4)' ) integ endif ! string = trim ( string ) ! return ! end subroutine int2str","tags":"","loc":"proc/int2str~2.html","title":"int2str – Carrier Cross Sections"},{"text":"public subroutine arrangeLargerToSmaller(nModes, x, s2L) Sort s2L based on descending order\n of x Todo Change this to a more efficient algorithm Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes Number of phonon modes real(kind=dp), intent(in) :: x (nModes) Argument to modified Bessel function integer, intent(inout) :: s2L (nModes) Indexes phonon information that come in\n in order (1, 2, 3, ...) and are rearranged\n here so that they are the indices in order\n of the magnitude of the argument x Contents Variables i iMode temp tmpr tmpi Source Code arrangeLargerToSmaller Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iMode real(kind=dp), public :: temp (nModes) real(kind=dp), public :: tmpr integer, public :: tmpi Source Code subroutine arrangeLargerToSmaller ( nModes , x , s2L ) !! Sort `s2L` based on descending order !! of `x` !! !! @todo Change this to a more efficient algorithm @endtodo ! implicit none ! integer , intent ( in ) :: nModes !! Number of phonon modes integer , intent ( inout ) :: s2L ( nModes ) !! Indexes phonon information that come in !! in order (1, 2, 3, ...) and are rearranged !! here so that they are the indices in order !! of the magnitude of the argument `x` integer :: i , iMode ! real ( kind = dp ), intent ( in ) :: x ( nModes ) !! Argument to modified Bessel function real ( kind = dp ) :: temp ( nModes ) real ( kind = dp ) :: tmpr integer :: tmpi ! temp (:) = 0.0_dp temp (:) = x (:) ! do iMode = 1 , nModes ! do i = 1 , nModes - 1 ! if ( temp ( i ) < temp ( i + 1 ) ) then ! tmpi = s2L ( i ) s2L ( i ) = s2L ( i + 1 ) s2L ( i + 1 ) = tmpi ! tmpr = temp ( i ) temp ( i ) = temp ( i + 1 ) temp ( i + 1 ) = tmpr ! endif ! enddo ! enddo ! return ! end subroutine arrangeLargerToSmaller","tags":"","loc":"proc/arrangelargertosmaller.html","title":"arrangeLargerToSmaller – Carrier Cross Sections"},{"text":"public subroutine readPhonons(phononsInput, nOfqPoints, nAtoms, nModes, atomD, atomM, phonQ, phonF, phonD) Read the number of atoms and q points and\n get the phonon information like frequency \n and displacements Walkthrough Open phononsInput file Read in the number of q points and number of atoms Calculate the number of phonon modes Write the number of atoms, q points, and modes to the output file Ignore the next line as it is blank For each atom, read in the displacement (either pristine-defect \n   or defect-pristine) and the atom mass Ignore the next line as it is blank For each q point Read in the coordinates in q -space For each phonon mode Read in the phonon frequency in THz Convert the frequency to Hartree Read in the atom displacements Close phononsInput file Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: phononsInput QE/VASP phonon output file name integer, intent(out) :: nOfqPoints Number of q points integer, intent(out) :: nAtoms Number of atoms in system integer, intent(out) :: nModes Number of phonon modes real(kind=dp), intent(out), allocatable :: atomD (:,:) Atom displacements when comparing defective and perfect crystals real(kind=dp), intent(out), allocatable :: atomM (:) Atom masses real(kind=dp), intent(out), allocatable :: phonQ (:,:) real(kind=dp), intent(out), allocatable :: phonF (:) real(kind=dp), intent(out), allocatable :: phonD (:,:,:,:) Contents Variables iAtom iMode iq dummyD freqInTHz dummyC Source Code readPhonons Variables Type Visibility Attributes Name Initial integer, public :: iAtom Loop index over atoms integer, public :: iMode Loop index over phonon modes integer, public :: iq Loop index over q points real(kind=dp), public :: dummyD Dummy variable to ignore input real(kind=dp), public :: freqInTHz Input frequency in THz character, public :: dummyC Dummy variable to ignore input Source Code subroutine readPhonons ( phononsInput , nOfqPoints , nAtoms , nModes , atomD , atomM , phonQ , phonF , phonD ) !! Read the number of atoms and q points and !! get the phonon information like frequency !! and displacements !! !! <h2>Walkthrough</h2> !! implicit none ! integer , intent ( out ) :: nOfqPoints !! Number of q points integer , intent ( out ) :: nAtoms !! Number of atoms in system integer , intent ( out ) :: nModes !! Number of phonon modes integer :: iAtom !! Loop index over atoms integer :: iMode !! Loop index over phonon modes integer :: iq !! Loop index over q points ! real ( kind = dp ), allocatable , intent ( out ) :: atomD (:,:) !! Atom displacements when comparing defective and perfect crystals real ( kind = dp ), allocatable , intent ( out ) :: atomM (:) !! Atom masses real ( kind = dp ), allocatable , intent ( out ) :: phonD (:,:,:,:) real ( kind = dp ), allocatable , intent ( out ) :: phonF (:) real ( kind = dp ), allocatable , intent ( out ) :: phonQ (:,:) real ( kind = dp ) :: dummyD !! Dummy variable to ignore input real ( kind = dp ) :: freqInTHz !! Input frequency in THz ! character ( len = 256 ), intent ( in ) :: phononsInput !! QE/VASP phonon output file name character :: dummyC !! Dummy variable to ignore input ! open ( 1 , file = trim ( phononsInput ), status = \"old\" ) !! * Open `phononsInput` file ! read ( 1 , * ) nOfqPoints , nAtoms !! * Read in the number of q points and number of atoms ! nModes = 3 * nAtoms - 3 !! * Calculate the number of phonon modes write ( iostd , '(\" Number of atoms : \", i5)' ) nAtoms write ( iostd , '(\" Number of q-Points : \", i5)' ) nOfqPoints write ( iostd , '(\" Number of modes : \", i5)' ) nModes flush ( iostd ) !! * Write the number of atoms, q points, and modes to the output file ! read ( 1 , * ) !! * Ignore the next line as it is blank ! allocate ( atomD ( 3 , nAtoms ), atomM ( nAtoms ) ) ! atomD = 0.0_dp atomM = 0.0_dp ! do iAtom = 1 , nAtoms !! * For each atom, read in the displacement (either pristine-defect !!   or defect-pristine) and the atom mass ! read ( 1 , * ) atomD ( 1 , iAtom ), atomD ( 2 , iAtom ), atomD ( 3 , iAtom ), atomM ( iAtom ) ! enddo ! read ( 1 , * ) !! * Ignore the next line as it is blank ! allocate ( phonQ ( 3 , nOfqPoints ), phonF ( nModes ), phonD ( 3 , nAtoms , nModes , nOfqPoints ) ) ! phonQ = 0.0_dp phonF = 0.0_dp phonD = 0.0_dp ! do iq = 1 , nOfqPoints !! * For each q point !!    * Read in the coordinates in q-space !!    * For each phonon mode !!      * Read in the phonon frequency in THz !!      * Convert the frequency to Hartree !!      * Read in the atom displacements ! read ( 1 , * ) dummyC , dummyC , dummyC , phonQ ( 1 , iq ), phonQ ( 2 , iq ), phonQ ( 3 , iq ), dummyC ! do iMode = 1 , nModes ! read ( 1 , * ) ! read ( 1 , * ) freqInTHz , dummyC , dummyD , dummyC , dummyD , dummyC , dummyD , dummyC phonF ( iMode ) = dble ( freqInTHz ) * THzToHartree ! read ( 1 , * ) dummyC , dummyC , dummyC , dummyC , dummyC , dummyC ! do iAtom = 1 , nAtoms ! read ( 1 , * ) dummyD , dummyD , dummyD , phonD ( 1 , iAtom , iMode , iq ), phonD ( 2 , iAtom , iMode , iq ), phonD ( 3 , iAtom , iMode , iq ) ! enddo ! enddo ! enddo ! close ( 1 ) !! * Close `phononsInput` file ! flush ( iostd ) ! return ! end subroutine readPhonons","tags":"","loc":"proc/readphonons.html","title":"readPhonons – Carrier Cross Sections"},{"text":"Uses io_global kinds parameters Contents Variables file_version restart_module_verbosity Subroutines write_restart_wfc Variables Type Visibility Attributes Name Initial integer, public, parameter :: file_version = 202 integer, public :: restart_module_verbosity = 0 Subroutines public subroutine write_restart_wfc (iuni, exportDir, ik, nk, kunit, ispin, nspin, scal, wf0, t0, wfm, tm, ngw, gamma_only, nbnd, igl, ngwl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iuni character(len=256), intent(in) :: exportDir integer, intent(in) :: ik integer, intent(in) :: nk integer, intent(in) :: kunit integer, intent(in) :: ispin integer, intent(in) :: nspin real(kind=DP), intent(in) :: scal complex(kind=DP), intent(in) :: wf0 (:,:) logical, intent(in) :: t0 complex(kind=DP), intent(in) :: wfm (:,:) logical, intent(in) :: tm integer, intent(in) :: ngw logical, intent(in) :: gamma_only integer, intent(in) :: nbnd integer, intent(in) :: igl (:) integer, intent(in) :: ngwl","tags":"","loc":"module/io_base_export.html","title":"io_base_export – Carrier Cross Sections"},{"text":"Declare all global variables\n and house all subroutines Contents Variables dp iostd root evToHartree HartreeToEv pi sq4pi ii output gx gy gz i iBandFfinal iBandFinit iBandIfinal iBandIinit ibf ibi id ierr ig ik ind2 ios iPn iTypes j JMAX kf ki maxL myid n n1 n2 n3 n4 nF nGf nGi nGvsF nGvsI nI np nPP npw npwMf npwMi npwNf npwNi nSquareProcs numOfPWs numOfUsedGvecsPP numprocs eBin t0 tf threej paw paw2 pseudo1 pseudo2 calculateVfis coulomb gamma_only master tmes_file_exists elementsPath mkdir textDum VfisOutput counts igvs iqs nFs ngs nIs nPWsI nPWsF pwGvecs pwGs absVfi2 DE eigvF eigvI gvecs paw_id paw_fi pawPsiPC pawSDPhi paw_SDKKPC Ufi perfectCrystal solidDefect vecs newVecs Derived Types atom crystal vec Functions wasRead Subroutines initializeCalculation readInput checkInitialization readQEExport readPWsSet distributePWsToProcs checkIfCalculated calculatePWsOverlap readWfc readProjections projectBeta pawCorrectionWfc pawCorrectionK ylm bessel_j writeResults readUfis calculateVfiElements readEigenvalues finalizeCalculation int2str Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) Used to set real variables to double precision integer, public, parameter :: iostd = 16 Unit number for output file integer, public, parameter :: root = 0 ID of the root process real(kind=dp), public, parameter :: evToHartree = 0.03674932538878_dp Conversion factor from eV to Hartree real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp Conversion factor from Hartree to eV real(kind=dp), public, parameter :: pi = 3.141592653589793_dp Pi real(kind=dp), public, parameter :: sq4pi = 3.544907701811032_dp \\sqrt{4\\pi} complex(kind=dp), public, parameter :: ii = cmplx(0.0_dp, 1.0_dp, kind=dp) Complex i character(len=6), public, parameter :: output = 'output' Name of the output file;\n used in readInput Todo Change I/O from file to console so that usage matches that of QE integer, public :: gx integer, public :: gy integer, public :: gz integer, public :: i integer, public :: iBandFfinal integer, public :: iBandFinit integer, public :: iBandIfinal integer, public :: iBandIinit integer, public :: ibf integer, public :: ibi integer, public :: id integer, public :: ierr Error code returned from MPI integer, public :: ig integer, public :: ik integer, public :: ind2 integer, public :: ios Status returned from I/O commands integer, public :: iPn integer, public :: iTypes integer, public :: j integer, public :: JMAX 2*L_{\\text{max}} + 1 integer, public :: kf integer, public :: ki integer, public :: maxL Maximum angular momentum of projector from any atom type integer, public :: myid ID for each MPI process integer, public :: n integer, public :: n1 integer, public :: n2 integer, public :: n3 integer, public :: n4 integer, public :: nF integer, public :: nGf integer, public :: nGi integer, public :: nGvsF integer, public :: nGvsI integer, public :: nI integer, public :: np integer, public :: nPP integer, public :: npw integer, public :: npwMf integer, public :: npwMi integer, public :: npwNf integer, public :: npwNi integer, public :: nSquareProcs integer, public :: numOfPWs integer, public :: numOfUsedGvecsPP integer, public :: numprocs Number of processes in the MPI pool real(kind=dp), public :: eBin real(kind=dp), public :: t0 Start time for program real(kind=dp), public :: tf End time for program real(kind=dp), public :: threej complex(kind=dp), public :: paw complex(kind=dp), public :: paw2 complex(kind=dp), public :: pseudo1 complex(kind=dp), public :: pseudo2 logical, public :: calculateVfis logical, public :: coulomb logical, public :: gamma_only logical, public :: master logical, public :: tmes_file_exists character(len=300), public :: elementsPath character(len=320), public :: mkdir Command for creating the elements path directory character(len=300), public :: textDum Dummy variable to hold unneeded lines from input file character(len=200), public :: VfisOutput Output file for ?? integer, public, allocatable :: counts (:) integer, public, allocatable :: igvs (:,:,:) integer, public, allocatable :: iqs (:) integer, public, allocatable :: nFs (:,:) integer, public, allocatable :: ngs (:,:) integer, public, allocatable :: nIs (:,:) integer, public, allocatable :: nPWsI (:) integer, public, allocatable :: nPWsF (:) integer, public, allocatable :: pwGvecs (:,:) integer, public, allocatable :: pwGs (:,:) real(kind=dp), public, allocatable :: absVfi2 (:,:) real(kind=dp), public, allocatable :: DE (:,:) real(kind=dp), public, allocatable :: eigvF (:) real(kind=dp), public, allocatable :: eigvI (:) real(kind=dp), public, allocatable :: gvecs (:,:) complex(kind=dp), public, allocatable :: paw_id (:,:) complex(kind=dp), public, allocatable :: paw_fi (:,:) complex(kind=dp), public, allocatable :: pawPsiPC (:,:) complex(kind=dp), public, allocatable :: pawSDPhi (:,:) complex(kind=dp), public, allocatable :: paw_SDKKPC (:,:) complex(kind=dp), public, allocatable :: Ufi (:,:,:) type( crystal ), public :: perfectCrystal Structure that holds all of the information on the perfect crystal type( crystal ), public :: solidDefect Structure that holds all of the information on the solid defect type( vec ), public, allocatable :: vecs (:) type( vec ), public, allocatable :: newVecs (:) Derived Types type, public :: atom Define a new type to represent an atom in the structure. \n Each different type of atom in the structure will be another\n variable with the type atom . Read more… Components Type Visibility Attributes Name Initial integer, public :: iRAugMax Maximum radius of beta projector (outer radius to integrate);\n for PAW augmentation charge may extend a bit further; I think this\n is the max index for the augmentation sphere, so I'm changing the \n name; last name was iRc integer, public :: numOfAtoms Number of atoms of a specific type in the structure integer, public :: numProjs Number of projectors integer, public :: lmMax Number of channels integer, public :: nMax Number of radial mesh points character(len=2), public :: symbol Element name for the given atom type integer, public, allocatable :: projAngMom (:) Angular momentum of each projector real(kind=dp), public, allocatable :: bes_J_qr (:,:) real(kind=dp), public, allocatable :: F (:,:) real(kind=dp), public, allocatable :: F1 (:,:,:) real(kind=dp), public, allocatable :: F2 (:,:,:) real(kind=dp), public, allocatable :: r (:) Radial mesh real(kind=dp), public, allocatable :: rab (:) Derivative of radial mesh real(kind=dp), public, allocatable :: wae (:,:) All electron wavefunction real(kind=dp), public, allocatable :: wps (:,:) Psuedowavefunction type, public :: crystal Components Type Visibility Attributes Name Initial integer, public :: nKpts Number of k points integer, public :: numOfPWs Total number of plane waves integer, public :: nIons Total number of atoms in system integer, public :: numOfTypes Number of different types of atoms integer, public :: nProjs Number of projectors integer, public :: numOfGvecs Number of G vectors Read more… integer, public :: nBands Number of bands integer, public :: nSpins Number of spins integer, public, allocatable :: npws (:) Number of plane waves per k point integer, public, allocatable :: atomTypeIndex (:) Index of the given atom type real(kind=dp), public :: omega Cell volume real(kind=dp), public :: bg (3,3) real(kind=dp), public, allocatable :: wk (:) real(kind=dp), public, allocatable :: xk (:,:) real(kind=dp), public, allocatable :: posIon (:,:) complex(kind=dp), public, allocatable :: wfc (:,:) complex(kind=dp), public, allocatable :: beta (:,:) complex(kind=dp), public, allocatable :: cProj (:,:,:) complex(kind=dp), public, allocatable :: cCrossProj (:,:,:) complex(kind=dp), public, allocatable :: paw_Wfc (:,:) complex(kind=dp), public, allocatable :: pawK (:,:,:) character(len=2), public :: crystalType 'PC' for pristine crystal and 'SD' for solid defect character(len=200), public :: exportDir Export directory from pw_export_for_TME type( atom ), public, allocatable :: atoms (:) type, public :: vec Components Type Visibility Attributes Name Initial integer, public :: ind integer, public, allocatable :: igN (:) integer, public, allocatable :: igM (:) Functions public function wasRead (inputVal, variableName, usage, abortExecution) Determine if an input variable still has the default value.\n If it does, output an error message and possibly set the program\n to abort. Not all variables would cause the program to abort,\n so this program assumes that if you pass in the logical abortExecution then the variable is required and causes the program to abort \n if missing. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputVal Value to compare with 0 to see if a variable has been read; character(len=*), intent(in) :: variableName Name of the variable used in output message character(len=*), intent(in) :: usage Example of how the variable can be used logical, intent(inout), optional :: abortExecution Optional logical for if the program should be aborted Return Value logical Whether or not the input variable was read from the input file;\n this is the return value Read more… Subroutines public subroutine initializeCalculation (solidDefect, pristineCrystal, elementsPath, VfisOutput, ki, kf, eBin, iBandIinit, iBandIfinal, iBandFinit, iBandFfinal, calculateVfis, t0) Initialize the calculation by starting timer,\n setting start values for variables to be read from .in file, removing any existing output in the output directory,\n and opening a clean output file Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: solidDefect type( crystal ), intent(inout) :: pristineCrystal character(len=300), intent(out) :: elementsPath character(len=200), intent(out) :: VfisOutput integer, intent(out) :: ki integer, intent(out) :: kf real(kind=dp), intent(out) :: eBin integer, intent(out) :: iBandIinit integer, intent(out) :: iBandIfinal integer, intent(out) :: iBandFinit integer, intent(out) :: iBandFfinal logical, intent(out) :: calculateVfis real(kind=dp), intent(out) :: t0 public subroutine readInput (perfectCrystal, solidDefect, elementsPath, iBandIinit, iBandIfinal, iBandFinit, iBandFfinal, ki, kf, calculateVfis, VfisOutput) Delete any previous output, initialize input variables,\n start a timer, and read in the input files Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: perfectCrystal Holds all of the information on the perfect crystal type( crystal ), intent(inout) :: solidDefect Holds all of the information on the defective crystal character(len=300), intent(inout) :: elementsPath integer, intent(inout) :: iBandIinit integer, intent(inout) :: iBandIfinal integer, intent(inout) :: iBandFinit integer, intent(inout) :: iBandFfinal integer, intent(inout) :: ki integer, intent(inout) :: kf logical, intent(inout) :: calculateVfis character(len=200), intent(inout) :: VfisOutput public subroutine checkInitialization () Check to see if variables from .in file still\n have the values set in initializeCalculation or if they have values that aren't allowed Read more… Arguments None public subroutine readQEExport (system) Read input files in the Export directory created by pw_export_for_TME Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect public subroutine readPWsSet () Read the g vectors in Miller indices from mgrid file and convert\n using reciprocal lattice vectors Read more… Arguments None public subroutine distributePWsToProcs (nOfPWs, nOfBlocks) Determine how many g vectors each process should get Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nOfPWs Number of g vectors integer, intent(in) :: nOfBlocks Number of processes public subroutine checkIfCalculated (ik, tmes_file_exists) Determine if the output file for a given k point already exists Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index logical, intent(out) :: tmes_file_exists Whether or not the output file exists public subroutine calculatePWsOverlap (ik) Read the wavefunctions and calculate the overlap \\langle\\Phi_f|\\Psi_i\\rangle Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index public subroutine readWfc (ik, system) Open the grid.ki file from pw_export_for_TME to get the indices for the wavefunction to be stored in, then\n open the wfc.ki file and read in the wavefunction for the \n proper bands and store in the proper indices in the system's wfc Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) public subroutine readProjections (ik, system) Read in the projection \\langle\\beta|\\Psi\\rangle for each band Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) public subroutine projectBeta (ik, betaSystem, projectedSystem) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index type( crystal ), intent(inout) :: betaSystem Holds the structure for the system you are getting \\beta from\n (either perfectCrystal or solidDefect ) type( crystal ), intent(inout) :: projectedSystem Holds the structure for the system you are projecting\n (either perfectCrystal or solidDefect ) public subroutine pawCorrectionWfc (system) Calculates the augmentation part of the transition matrix element Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) public subroutine pawCorrectionK (system) Read more… Arguments Type Intent Optional Attributes Name type( crystal ), intent(inout) :: system Holds the structure for the system you are working on\n (either perfectCrystal or solidDefect ) public subroutine ylm (V_in, LMAX, Y) Returns the spherical harmonics for a given argument vector up to the maximum value of l given Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_in (3) Vector, argument of the spherical harmonics (we calculate Y_l&#94;m(\\mathbf{v}/|\\mathbf{v}|) ) integer, intent(in) :: LMAX Spherical harmonics are calculated for l = 0, 1, ..., l_{\\text{max}} complex(kind=dp), intent(out) :: Y (*) Array containing Y_l&#94;m(\\mathbf{v}) for several l,m public subroutine bessel_j (x, lmax, jl) Generates the spherical bessel function of the first kind for the given argument x and all possible indices from 0 to lmax Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: lmax real(kind=dp), intent(out) :: jl (0:lmax) public subroutine writeResults (ik) Write out the \\langle f|U|i\\rangle matrix and\n changes in eigenvalues for a given k point Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index public subroutine readUfis (ik) Read in matrix elements for a given k point Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index public subroutine calculateVfiElements () Read more… Arguments None public subroutine readEigenvalues (ik) Read in the eigenvalues output from pw_export_for_TME Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik K point index public subroutine finalizeCalculation () Stop timer, write out total time taken, and close the output file Arguments None public subroutine int2str (integ, string) Write a given integer to a string, using only as many digits as needed Arguments Type Intent Optional Attributes Name integer :: integ character(len=300) :: string","tags":"","loc":"module/tmemodule.html","title":"TMEModule – Carrier Cross Sections"},{"text":"read ( 1 , ' (d22.14,i5,4d22.14) ' ) E , dummyI , dummyD , MjsOfE0 , dummyD ! E = E * eVToHartree iE = int ( E / deltaE ) + 1 ! do i = 1 , nEMjs - 1 ! iE0 = iE read ( 1 , ' (d22.14,i5,4d22.14) ' ) E , dummyI , dummyD , MjsOfE , dummyD E = E * eVToHartree iE = int ( E / deltaE ) + 1 Mjs ( iE0 : iE ) = MjsOfE0 MjsOfE0 = MjsOfE ! enddo ! close ( 1 ) ! ! do iE = - nEnergies , nEnergies ! write ( 44 , * ) real ( iE , dp ) * deltaE * HartreeToEv , Mjs ( iE ) ! enddo ! Uses constants Contents Variables int32 int64 un output ios modeF modeI nAtoms nModes nOfqPoints qPoint kT maxDisplacement t1 t2 temperature tf ti equilibriumAtomicPositions newAtomicPositions phononsInput QEInput file_exists readQEInput s2L atomD atomM atomPosition besOrderNofModeM coth genCoord newAtomicPosition phonD phonF phonQ Sj wby2kT x elements Functions wasRead Subroutines readInputs initialize checkAndUpdateInput readAtomicPositions displaceAtoms writeNewAtomicPositions exportQEInput Variables Type Visibility Attributes Name Initial integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: un = 3 character(len=6), public, parameter :: output = 'status' integer, public :: ios integer, public :: modeF integer, public :: modeI integer, public :: nAtoms Number of atoms integer, public :: nModes Number of phonon modes integer, public :: nOfqPoints integer, public :: qPoint Read in from input file, but no default value set Todo Make sure default value is set for qPoint real(kind=dp), public :: kT real(kind=dp), public :: maxDisplacement real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: temperature real(kind=dp), public :: tf real(kind=dp), public :: ti character(len=256), public :: equilibriumAtomicPositions character(len=256), public :: newAtomicPositions character(len=256), public :: phononsInput character(len=256), public :: QEInput logical, public :: file_exists logical, public :: readQEInput integer, public, allocatable :: s2L (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: atomPosition (:,:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: newAtomicPosition (:,:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: x (:) character(len=2), public, allocatable :: elements (:) Functions public function wasRead (inputVal, variableName, usage, abortExecution) Determine if an input variable still has the default value.\n If it does, output an error message and possibly set the program\n to abort. Not all variables would cause the program to abort,\n so this program assumes that if you pass in the logical abortExecution then the variable is required and causes the program to abort \n if missing. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: inputVal Value to compare with 0 to see if a variable has been read; character(len=*), intent(in) :: variableName Name of the variable used in output message character(len=*), intent(in) :: usage Example of how the variable can be used logical, intent(inout), optional :: abortExecution Optional logical for if the program should be aborted Return Value logical Whether or not the input variable was read from the input file;\n this is the return value Read more… Subroutines public subroutine readInputs () Read input parameters and read phonon output Read more… Arguments None public subroutine initialize () Set default values for input parameters Arguments None public subroutine checkAndUpdateInput () Check that the input variables don't still have their default\n values. The program will abort here if:\n * equilibriumAtomicPositions is not defined\n * phononsInput is not defined\n * temperature is not defined\n * modeI or modeF is not defined\n * modeF < modeI * maxDisplacement is not defined Arguments None public subroutine readAtomicPositions () Read in the element and equilibrium position for \n each atom Read more… Arguments None public subroutine displaceAtoms () For each mode, generate random displacements for the atoms\n based on the parameters maxDisplacement and phonD Read more… Arguments None public subroutine writeNewAtomicPositions () Write newAtomicPosition s for each mode Arguments None public subroutine exportQEInput () Create QE input files for all different modes\n by copying all of the QEInput except the newAtomicPosition s for each mode Read more… Arguments None","tags":"","loc":"module/mjmodule.html","title":"MjModule – Carrier Cross Sections"},{"text":"Todo Remove all of these comments Uses constants Contents Variables int32 int64 un root output ierr ios istat myid numprocs i iE iMint iMmod iMode l m maximumNumberOfPhonons mi minimumNumberOfPhonons nAtoms nEnergies ni nMC nModes nOfqPoints nProcMax printsteps de deltaE E kT maxEnergy t1 t2 tf ti temperature times weight continueLSFfromFile fn phononsInputFormat phononsInput file_exists iEbinsByBands iEbinsByPhonons iModeFs iModeIs pj pj0s pms s2L atomD atomM besOrderNofModeM coth genCoord lsfbyPhononsPerProc lsfVsE lsfVsEbyBands lsfVsEbyPhonons phonD phonF phonQ Sj wby2kT x Functions lcg Subroutines readInputs initializeLSF initialize checkAndUpdateInput readPhononsQE lsfDeterministicFourPhononsByFourBands lsfOfConfigurationPj calculatePlusMinusStates distrubutePhononsInBands lsfWithMphonons decimalToOther calculateDE lsfMbyOneBand lsfMbyTwoBands lsfMbyThreeBands writeLSFandCrossSection init_random_seed parallelIsFsBy3 parallelIsFsBy4 Variables Type Visibility Attributes Name Initial integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: un = 3 integer, public, parameter :: root = 0 character(len=6), public, parameter :: output = 'status' integer(kind=int32), public :: ierr integer(kind=int32), public :: ios integer(kind=int32), public :: istat integer(kind=int32), public :: myid integer(kind=int32), public :: numprocs integer, public :: i integer, public :: iE integer, public :: iMint integer, public :: iMmod integer, public :: iMode integer, public :: l integer, public :: m integer, public :: maximumNumberOfPhonons integer, public :: mi integer, public :: minimumNumberOfPhonons integer, public :: nAtoms integer, public :: nEnergies integer, public :: ni integer, public :: nMC integer, public :: nModes integer, public :: nOfqPoints integer, public :: nProcMax integer, public :: printsteps real(kind=dp), public :: de real(kind=dp), public :: deltaE real(kind=dp), public :: E real(kind=dp), public :: kT real(kind=dp), public :: maxEnergy real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: tf real(kind=dp), public :: ti real(kind=dp), public :: temperature real(kind=dp), public :: times real(kind=dp), public :: weight character(len=256), public :: continueLSFfromFile character(len=256), public :: fn character(len=256), public :: phononsInputFormat character(len=256), public :: phononsInput logical, public :: file_exists integer, public, allocatable :: iEbinsByBands (:) integer, public, allocatable :: iEbinsByPhonons (:) integer, public, allocatable :: iModeFs (:) integer, public, allocatable :: iModeIs (:) integer, public, allocatable :: pj (:) integer, public, allocatable :: pj0s (:,:) integer, public, allocatable :: pms (:,:) integer, public, allocatable :: s2L (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: lsfbyPhononsPerProc (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyBands (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonons (:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: x (:) Functions public function lcg (s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer Subroutines public subroutine readInputs () Read input parameters and read phonon output Read more… Arguments None public subroutine initializeLSF () Allocate and initialize lsfVsE and minimumNumberOfPhonons . If a file was\n given to continue from, read in both \n variables from the file. Read more… Arguments None public subroutine initialize () Set default values for input parameters Arguments None public subroutine checkAndUpdateInput () Check that the input variables don't still have their default\n values. The program will abort here if:\n   * phononsInput is undefined\n   * phononsInputFormat is undefined\n   * temperature is undefined\n   * maximumNumberOfPhonons is undefined\n   * number of Monte Carlo steps ( nMc ) is not\n     set and maximumNumberOfPhonons is greater\n     than 4 Read more… Arguments None public subroutine readPhononsQE () Arguments None public subroutine lsfDeterministicFourPhononsByFourBands () Explicitly calculate the line shape function for \n four phonons in four bands Read more… Arguments None public subroutine lsfOfConfigurationPj () Calculate a portion of the line shape function F for a given set \\{p_j\\} Read more… Arguments None public subroutine calculatePlusMinusStates (l) Get all of the possible binary numbers with l digits and store them in pms . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: l public subroutine distrubutePhononsInBands (m, l) Generate all possible ways to distribute m phonons in l bands\n such that each band has at least one phonon (only plus no minuses) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l public subroutine lsfWithMphonons (m, l, tTimes) Pick nMC groups of bands, then calculate the\n line shape function for all possible configurations\n in those bands and sum to get an estimate of the\n total line shape function for m phonons in l bands Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes public subroutine decimalToOther (iDec, n, iBase, other) Convert an input number in base 10 to an n digit number in base iBase . The number\n is returned in the length n vector other . Read more… Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) public subroutine calculateDE (maxM, iEbins, de) Calculate the maximum number of bins the\n energy spectrum can be split into such that\n no bin is empty then return the size de of\n the resulting bin Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de public subroutine lsfMbyOneBand (M) Calculate the line shape function for \n various sets \\{p_j\\} where all p_j are zero except one that has values -M, M Arguments Type Intent Optional Attributes Name integer, intent(in) :: M Number of phonons public subroutine lsfMbyTwoBands (m) Calculate the line shape function for \n various sets \\{p_j\\} where all p_j are zero except two that have values\n such that the total number of phonons (plus or minus) in\n the two bands is 3 Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyThreeBands (m) Calculate the line shape function for m phonons in 3 bands Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine writeLSFandCrossSection () Write out the line shape function versus energy Read more… Arguments None public subroutine init_random_seed () Arguments None public subroutine parallelIsFsBy3 () Figure out what mode each process should start ( iModeIs )\n and finish on ( iModeFs ) so that the resulting states are \n balanced between the processes Read more… Arguments None public subroutine parallelIsFsBy4 () Figure out what mode each process should start ( iModeIs )\n and finish on ( iModeFs ) so that the resulting states are \n balanced between the processes Read more… Arguments None","tags":"","loc":"module/lsf.html","title":"lsf – Carrier Cross Sections"},{"text":"Contents Variables dp int32 int64 iostd un root pi twopi abCM THzToHartree HartreeToEv eVToHartree myid numprocs ios istat ierr iMode l m nMC nProcMax iMint iMmod i printsteps iE ni mi nAtoms nOfqPoints nModes minimumNumberOfPhonons maximumNumberOfPhonons nEnergies ti tf t1 t2 weight times de E temperature maxEnergy deltaE kT iModeIs iModeFs pj pj0s pms s2L iEbinsByBands iEbinsByPhonons atomD atomM phonQ phonF genCoord Mjs wby2kT phonD x Sj coth besOrderNofModeM lsfVsEbyBands lsfVsE lsfVsEbyPhonons lsfbyPhononsPerProc modes output MjsInput phononsInput fn continueLSFfromFile equilibriumAtomicPositions file_exists Functions lcg msta1 msta2 envj Subroutines readInputs initializeLSF initialize checkAndUpdateInput readPhonons computeGeneralizedDisplacements computeVariables arrangeLargerToSmaller readMjs lsfDeterministicFourPhononsByFourBands lsfOfConfigurationPj calculatePlusMinusStates distrubutePhononsInBands lsfWithMphonons decimalToOther calculateDE lsfMbyOneBand lsfMbyTwoBands lsfMbyThreeBands writeLSFandCrossSection init_random_seed iknb iknb2 parallelIsFsBy3 parallelIsFsBy4 Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: int64 = selected_int_kind(15) integer, public, parameter :: iostd = 16 integer, public, parameter :: un = 3 integer, public, parameter :: root = 0 real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: THzToHartree = 1.0_dp/6579.683920729_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp integer(kind=int32), public :: myid integer(kind=int32), public :: numprocs integer(kind=int32), public :: ios integer(kind=int32), public :: istat integer(kind=int32), public :: ierr integer, public :: iMode integer, public :: l integer, public :: m integer, public :: nMC integer, public :: nProcMax integer, public :: iMint integer, public :: iMmod integer, public :: i integer, public :: printsteps integer, public :: iE integer, public :: ni integer, public :: mi integer, public :: nAtoms integer, public :: nOfqPoints integer, public :: nModes integer, public :: minimumNumberOfPhonons integer, public :: maximumNumberOfPhonons integer, public :: nEnergies real(kind=dp), public :: ti real(kind=dp), public :: tf real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: weight real(kind=dp), public :: times real(kind=dp), public :: de real(kind=dp), public :: E real(kind=dp), public :: temperature real(kind=dp), public :: maxEnergy real(kind=dp), public :: deltaE real(kind=dp), public :: kT integer, public, allocatable :: iModeIs (:) integer, public, allocatable :: iModeFs (:) integer, public, allocatable :: pj (:) integer, public, allocatable :: pj0s (:,:) integer, public, allocatable :: pms (:,:) integer, public, allocatable :: s2L (:) integer, public, allocatable :: iEbinsByBands (:) integer, public, allocatable :: iEbinsByPhonons (:) real(kind=dp), public, allocatable :: atomD (:,:) real(kind=dp), public, allocatable :: atomM (:) real(kind=dp), public, allocatable :: phonQ (:,:) real(kind=dp), public, allocatable :: phonF (:) real(kind=dp), public, allocatable :: genCoord (:) real(kind=dp), public, allocatable :: Mjs (:,:) real(kind=dp), public, allocatable :: wby2kT (:) real(kind=dp), public, allocatable :: phonD (:,:,:,:) real(kind=dp), public, allocatable :: x (:) real(kind=dp), public, allocatable :: Sj (:) real(kind=dp), public, allocatable :: coth (:) real(kind=dp), public, allocatable :: besOrderNofModeM (:,:) real(kind=dp), public, allocatable :: lsfVsEbyBands (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonons (:) real(kind=dp), public, allocatable :: lsfbyPhononsPerProc (:) integer, public :: modes character(len=6), public, parameter :: output = 'status' character(len=256), public :: MjsInput character(len=256), public :: phononsInput character(len=256), public :: fn character(len=256), public :: continueLSFfromFile character(len=256), public :: equilibriumAtomicPositions logical, public :: file_exists Functions public function lcg (s) Arguments Type Intent Optional Attributes Name integer :: s Return Value integer public function msta1 (x, mp) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: mp Return Value integer public function msta2 (x, n, mp) result(fn_val) !!!!!!\n!!!!!! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: n integer, intent(in) :: mp Return Value integer public function envj (n, x) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public subroutine readInputs () Arguments None public subroutine initializeLSF () Arguments None public subroutine initialize () Arguments None public subroutine checkAndUpdateInput () Arguments None public subroutine readPhonons () Arguments None public subroutine computeGeneralizedDisplacements () Arguments None public subroutine computeVariables () Arguments None public subroutine arrangeLargerToSmaller () Arguments None public subroutine readMjs () Arguments None public subroutine lsfDeterministicFourPhononsByFourBands () Arguments None public subroutine lsfOfConfigurationPj () Arguments None public subroutine calculatePlusMinusStates (l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l public subroutine distrubutePhononsInBands (m, l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l public subroutine lsfWithMphonons (m, l, tTimes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: l integer, intent(in) :: tTimes public subroutine decimalToOther (iDec, n, iBase, other) Arguments Type Intent Optional Attributes Name integer :: iDec integer, intent(in) :: n integer, intent(in) :: iBase integer :: other (0:n-1) public subroutine calculateDE (maxM, iEbins, de) Arguments Type Intent Optional Attributes Name integer, intent(in) :: maxM integer, intent(in) :: iEbins (-nEnergies:nEnergies) real(kind=dp), intent(out) :: de public subroutine lsfMbyOneBand (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyTwoBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine lsfMbyThreeBands (m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m public subroutine writeLSFandCrossSection () Arguments None public subroutine init_random_seed () Arguments None public subroutine iknb (n, x, nm, bi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision :: x integer :: nm double precision :: bi (0:n) public subroutine iknb2 (n, x, nm, bi, di, bk, dk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: x integer, intent(out) :: nm real(kind=dp), intent(out) :: bi (0:n) real(kind=dp), intent(out) :: di (0:n) real(kind=dp), intent(out) :: bk (0:n) real(kind=dp), intent(out) :: dk (0:n) public subroutine parallelIsFsBy3 () Arguments None public subroutine parallelIsFsBy4 () Arguments None","tags":"","loc":"module/lsf~2.html","title":"lsf – Carrier Cross Sections"},{"text":"Contents Variables dp int32 iostd nOfEnergyBins abCM eVToHartree HartreeToEv maxEnergy pi twopi output ios m nEnergies numOfVfis volume de eifMin DHifMin E energy lorentz lorentzByPhonon lsf lsfVsE lsfVsEbyPhonon sigma sigmaByPhonon Vfis VfisInput LSFinput crossSectionOutput file_exists Subroutines readInputs initialize checkInputAndUpdateParameters readLSF readVfis calculateSigma writeSigma Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: int32 = selected_int_kind(5) integer, public, parameter :: iostd = 16 integer, public, parameter :: nOfEnergyBins = 5040 real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: maxEnergy = 10.0_dp real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi character(len=11), public, parameter :: output = 'sigmaStatus' integer(kind=int32), public :: ios integer, public :: m integer, public :: nEnergies integer, public :: numOfVfis real(kind=dp), public :: volume real(kind=dp), public :: de real(kind=dp), public :: eifMin real(kind=dp), public :: DHifMin real(kind=dp), public, allocatable :: E (:) real(kind=dp), public, allocatable :: energy (:) real(kind=dp), public, allocatable :: lorentz (:) real(kind=dp), public, allocatable :: lorentzByPhonon (:) real(kind=dp), public, allocatable :: lsf (:) real(kind=dp), public, allocatable :: lsfVsE (:) real(kind=dp), public, allocatable :: lsfVsEbyPhonon (:) real(kind=dp), public, allocatable :: sigma (:) real(kind=dp), public, allocatable :: sigmaByPhonon (:) real(kind=dp), public, allocatable :: Vfis (:) character(len=256), public :: VfisInput character(len=256), public :: LSFinput character(len=256), public :: crossSectionOutput logical, public :: file_exists Subroutines public subroutine readInputs () Read input parameters and read LSF and TME output Read more… Arguments None public subroutine initialize () Set default values for input parameters Arguments None public subroutine checkInputAndUpdateParameters () Check that the input variables don't still have their default\n values. If the input files are not defined, end the program. Arguments None public subroutine readLSF () Read LSF output Read more… Arguments None public subroutine readVfis () Read TME output, get Vfis and lsf using the same index,\n and output the results to two output files Read more… Arguments None public subroutine calculateSigma () Calculate the index for the min energy Read more… Arguments None public subroutine writeSigma () Write the energy and \\sigma(E) Arguments None","tags":"","loc":"module/sigma_module.html","title":"sigma_module – Carrier Cross Sections"},{"text":"Contents Variables dp iostd abCM eVToHartree HartreeToEv pi THzToHartree twopi Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) Used to make reals double precision integer, public, parameter :: iostd = 16 Unit number for output file real(kind=dp), public, parameter :: abCM = 0.529177219217e-8_dp real(kind=dp), public, parameter :: eVToHartree = 1.0_dp/27.21138386_dp real(kind=dp), public, parameter :: HartreeToEv = 27.21138386_dp real(kind=dp), public, parameter :: pi = 3.1415926535897932_dp real(kind=dp), public, parameter :: THzToHartree = 1.0_dp/6579.683920729_dp real(kind=dp), public, parameter :: twopi = 2.0_dp*pi","tags":"","loc":"module/constants.html","title":"constants – Carrier Cross Sections"},{"text":"Uses constants Contents Functions msta1 msta2 envj Subroutines computeGeneralizedDisplacements computeVariables iknb Functions public function msta1 (x, mp) result(fn_val) Determine the starting point for backward \n recurrence such that the magnitude of J_n(x) at that point is about 10&#94;{-\\text{mp}} Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Argument of J_n(x) integer, intent(in) :: mp Magnitude Return Value integer Starting point public function msta2 (x, n, mp) result(fn_val) Determine the starting point for backward \n recurrence such that all J_n(x) has mp\n significant digits Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Argument of J_n(x) integer, intent(in) :: n Order of J_n(x) integer, intent(in) :: mp Significant digit Return Value integer Starting point public function envj (n, x) result(fn_val) Estimates -\\log(J_n(x)) from the estimate J_n(x) \\approx \\dfrac{1}{\\sqrt{2\\pi n}}\\left(\\dfrac{ex}{2n}\\right)&#94;n Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Order of Bessel function real(kind=dp), intent(in) :: x Argument Return Value real(kind=dp) -\\log(J_n(x)) Subroutines public subroutine computeGeneralizedDisplacements (nOfqPoints, nModes, genCoord, nAtoms, atomM, phonD, atomD) Calculate the generalized displacements\n by dotting the phonon displacements with\n the atom displacements Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nOfqPoints Number of q points integer, intent(in) :: nModes Number of phonon modes real(kind=dp), intent(out) :: genCoord (nModes) Generalized coordinates \\delta q_j integer, intent(in) :: nAtoms Number of atoms in system real(kind=dp), intent(in) :: atomM (nAtoms) Atom masses real(kind=dp), intent(in) :: phonD (3,nAtoms,nModes,nOfqPoints) Phonon displacements real(kind=dp), intent(in) :: atomD (3,nAtoms) Equilibrium displacements in defect versus pristine public subroutine computeVariables (x, Sj, coth, wby2kT, phonF, genCoord, kT, s2L, nModes, maximumNumberOfPhonons, besOrderNofModeM) Calculate biggest portions of equations 42 and 43 to make\n entire equation more manageable Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: x (nModes) Argument to modified Bessel function real(kind=dp), intent(out) :: Sj (nModes) S_j in equation 44 in paper real(kind=dp), intent(out) :: coth (nModes) Hyperbolic cotangent real(kind=dp), intent(out) :: wby2kT (nModes) \\omega/2kT real(kind=dp), intent(in) :: phonF (nModes) Phonon frequencies in Hartree real(kind=dp), intent(in) :: genCoord (nModes) Generalized coordinates \\delta q_j real(kind=dp), intent(in) :: kT integer, intent(out) :: s2L (nModes) integer, intent(in) :: nModes Number of phonon modes integer, intent(in) :: maximumNumberOfPhonons real(kind=dp), intent(out) :: besOrderNofModeM (0:maximumNumberOfPhonons+1,nModes) public subroutine iknb (n, x, nm, bi) Author Shanjie Zhang, Jianming Jin Date 17 July 2012 * * * * * * * * * * 72 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Order of I_n(x) and K_n(x) double precision :: x The argument integer, intent(inout) :: nm The highest order computed double precision :: bi (0:n) I_n(x)","tags":"","loc":"module/generalcomputations.html","title":"generalComputations – Carrier Cross Sections"},{"text":"Uses constants Contents Subroutines int2str arrangeLargerToSmaller Subroutines public subroutine int2str (integ, string) Write a given integer to a string, using only as many digits as needed Arguments Type Intent Optional Attributes Name integer :: integ character(len=300) :: string public subroutine arrangeLargerToSmaller (nModes, x, s2L) Sort s2L based on descending order\n of x Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nModes Number of phonon modes real(kind=dp), intent(in) :: x (nModes) Argument to modified Bessel function integer, intent(inout) :: s2L (nModes) Indexes phonon information that come in\n in order (1, 2, 3, ...) and are rearranged\n here so that they are the indices in order\n of the magnitude of the argument x","tags":"","loc":"module/miscutilities.html","title":"miscUtilities – Carrier Cross Sections"},{"text":"Uses constants Contents Subroutines readPhonons Subroutines public subroutine readPhonons (phononsInput, nOfqPoints, nAtoms, nModes, atomD, atomM, phonQ, phonF, phonD) Read the number of atoms and q points and\n get the phonon information like frequency \n and displacements Read more… Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: phononsInput QE/VASP phonon output file name integer, intent(out) :: nOfqPoints Number of q points integer, intent(out) :: nAtoms Number of atoms in system integer, intent(out) :: nModes Number of phonon modes real(kind=dp), intent(out), allocatable :: atomD (:,:) Atom displacements when comparing defective and perfect crystals real(kind=dp), intent(out), allocatable :: atomM (:) Atom masses real(kind=dp), intent(out), allocatable :: phonQ (:,:) real(kind=dp), intent(out), allocatable :: phonF (:) real(kind=dp), intent(out), allocatable :: phonD (:,:,:,:)","tags":"","loc":"module/readinputfiles.html","title":"readInputFiles – Carrier Cross Sections"},{"text":"Uses wrappers pwcom io_global io_files ions_base iotk_module mp_global mp_pools mp_world mp environment Contents Variables trimcheck ik i kunittmp ios ryToHartree pp_file exportDir writeWFC Subroutines write_export Source Code pw_export_for_TME Variables Type Attributes Name Initial character(len=256), EXTERNAL :: trimcheck integer :: ik integer :: i integer :: kunittmp integer :: ios real(kind=dp), parameter :: ryToHartree = 0.5_dp character(len=256) :: pp_file character(len=256) :: exportDir logical :: writeWFC Subroutines subroutine write_export (pp_file, exportDir, kunit) Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: pp_file character(len=256), intent(in) :: exportDir integer, intent(in) :: kunit Source Code PROGRAM pw_export_for_TME !----------------------------------------------------------------------- ! ! writes PWSCF data for postprocessing purposes in XML format using IOTK lib ! Wave-functions are collected and written using IO_BASE module. ! ! input:  namelist \"&inputpp\", with variables !   prefix       prefix of input files saved by program pwscf !   outdir       temporary directory where files resides !   exportDir    output directory. A directory !                \"exportDir\" is created and !                output files are put there. All the data !                are accessible through the \"\"exportDir\"/input\" file. ! USE wrappers , ONLY : f_mkdir_safe USE pwcom USE io_global , ONLY : ionode , ionode_id USE io_files , ONLY : prefix , tmp_dir , outdir USE ions_base , ONLY : ntype => nsp USE iotk_module USE mp_global , ONLY : mp_startup USE mp_pools , ONLY : kunit USE mp_world , ONLY : world_comm USE mp , ONLY : mp_bcast USE environment , ONLY : environment_start ! IMPLICIT NONE ! CHARACTER ( LEN = 256 ), EXTERNAL :: trimcheck ! INTEGER :: ik , i , kunittmp , ios ! real ( kind = dp ), parameter :: ryToHartree = 0.5_dp ! CHARACTER ( len = 256 ) :: pp_file , exportDir LOGICAL :: writeWFC ! NAMELIST / inputpp / prefix , outdir , exportDir , writeWFC ! ! initialise environment ! #ifdef __MPI CALL mp_startup ( ) #endif CALL environment_start ( 'PW_EXPORT' ) ! !   set default values for variables in namelist ! prefix = '' CALL get_environment_variable ( 'ESPRESSO_TMPDIR' , outdir ) IF ( trim ( outdir ) == ' ' ) outdir = './' exportDir = './Export' ! writeWFC = . true . ! gdb : by default the wavefunctions are needed, !       this gives the user the ability not to write the wavefunctions ! !    Reading input file ! IF ( ionode ) THEN ! CALL input_from_file ( ) ! READ ( 5 , inputpp , IOSTAT = ios ) ! IF ( ios /= 0 ) CALL errore ( 'pw_export' , 'reading inputpp namelist' , abs ( ios ) ) ! ios = f_mkdir_safe ( trim ( exportDir ) ) ! pp_file = trim ( exportDir ) // \"/input\" ! ! ENDIF ! ! ... Broadcasting variables ! tmp_dir = trimcheck ( outdir ) CALL mp_bcast ( outdir , ionode_id , world_comm ) CALL mp_bcast ( tmp_dir , ionode_id , world_comm ) CALL mp_bcast ( prefix , ionode_id , world_comm ) ! !   Now allocate space for pwscf variables, read and check them. ! CALL read_file CALL openfil_pp ! #if defined __MPI kunittmp = kunit #else kunittmp = 1 #endif CALL write_export ( pp_file , exportDir , kunittmp ) CALL stop_pp ! CONTAINS ! !----------------------------------------------------------------------- SUBROUTINE write_export ( pp_file , exportDir , kunit ) !----------------------------------------------------------------------- ! USE iotk_module USE kinds , ONLY : DP USE pwcom USE start_k , ONLY : nk1 , nk2 , nk3 , k1 , k2 , k3 USE control_flags , ONLY : gamma_only USE global_version , ONLY : version_number USE becmod , ONLY : bec_type , becp , calbec , & allocate_bec_type , deallocate_bec_type USE uspp , ONLY : nkb , vkb USE wavefunctions_module , ONLY : evc USE io_files , ONLY : outdir , prefix , iunwfc , nwordwfc USE io_files , ONLY : psfile USE io_base_export , ONLY : write_restart_wfc USE io_global , ONLY : ionode , stdout USE ions_base , ONLY : atm , nat , ityp , tau , nsp USE mp_pools , ONLY : my_pool_id , intra_pool_comm , inter_pool_comm , & nproc_pool USE mp , ONLY : mp_sum , mp_max USE mp_world , ONLY : world_comm , nproc , mpime ! USE upf_module , ONLY : read_upf ! USE pseudo_types , ONLY : pseudo_upf USE radial_grids , ONLY : radial_grid_type ! USE wvfct , ONLY : wg ! USE paw_variables , ONLY : okpaw , ddd_paw , total_core_energy , only_paw USE paw_onecenter , ONLY : PAW_potential USE paw_symmetry , ONLY : PAW_symmetrize_ddd USE uspp_param , ONLY : nh , nhm ! used for PAW USE uspp , ONLY : qq_so , dvan_so , qq , dvan USE scf , ONLY : rho ! IMPLICIT NONE ! CHARACTER ( 5 ), PARAMETER :: fmt_name = \"QEXPT\" CHARACTER ( 5 ), PARAMETER :: fmt_version = \"1.1.0\" INTEGER , INTENT ( in ) :: kunit CHARACTER ( 256 ), INTENT ( in ) :: pp_file , exportDir INTEGER :: i , j , k , ig , ik , ibnd , na , ngg , ig_ , ierr INTEGER , ALLOCATABLE :: kisort (:) real ( DP ) :: xyz ( 3 ), tmp ( 3 ) INTEGER :: npool , nkbl , nkl , nkr , npwx_g , im , ink , inb , ms INTEGER :: ike , iks , npw_g , ispin , local_pw INTEGER , ALLOCATABLE :: ngk_g ( : ) INTEGER , ALLOCATABLE :: itmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_g ( :, : ) real ( DP ), ALLOCATABLE :: rtmp_gg ( : ) INTEGER , ALLOCATABLE :: itmp1 ( : ) INTEGER , ALLOCATABLE :: igwk ( :, : ) INTEGER , ALLOCATABLE :: l2g_new ( : ) INTEGER , ALLOCATABLE :: igk_l2g ( :, : ) ! ! character ( len = 300 ) :: text ! real ( DP ) :: wfc_scal LOGICAL :: twf0 , twfm , file_exists CHARACTER ( iotk_attlenx ) :: attr TYPE ( pseudo_upf ) :: upf ! the pseudo data TYPE ( radial_grid_type ) :: grid integer , allocatable :: nnTyp (:), groundState (:) IF ( nkstot > 0 ) THEN IF ( ( kunit < 1 ) . or . ( mod ( nkstot , kunit ) /= 0 ) ) & CALL errore ( ' write_export ' , ' wrong kunit ' , 1 ) IF ( ( nproc_pool > nproc ) . or . ( mod ( nproc , nproc_pool ) /= 0 ) ) & CALL errore ( ' write_export ' , ' nproc_pool ' , 1 ) !  find out the number of pools npool = nproc / nproc_pool !  find out number of k points blocks nkbl = nkstot / kunit !  k points per pool nkl = kunit * ( nkbl / npool ) !  find out the reminder nkr = ( nkstot - nkl * npool ) / kunit !  Assign the reminder to the first nkr pools IF ( my_pool_id < nkr ) nkl = nkl + kunit !  find out the index of the first k point in this pool iks = nkl * my_pool_id + 1 IF ( my_pool_id >= nkr ) iks = iks + nkr * kunit !  find out the index of the last k point in this pool ike = iks + nkl - 1 ENDIF ! find out the global number of G vectors: ngm_g ngm_g = ngm CALL mp_sum ( ngm_g , intra_pool_comm ) !  Open file PP_FILE IF ( ionode ) THEN ! WRITE ( stdout , * ) \"Opening file \" // trim ( pp_file ) ! open ( 50 , file = trim ( pp_file )) ! WRITE ( stdout , * ) \"Reconstructing the main grid\" ! endif ! collect all G vectors across processors within the pools ! and compute their modules ! ALLOCATE ( itmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_g ( 3 , ngm_g ) ) ALLOCATE ( rtmp_gg ( ngm_g ) ) itmp_g = 0 DO ig = 1 , ngm itmp_g ( 1 , ig_l2g ( ig ) ) = mill ( 1 , ig ) itmp_g ( 2 , ig_l2g ( ig ) ) = mill ( 2 , ig ) itmp_g ( 3 , ig_l2g ( ig ) ) = mill ( 3 , ig ) ENDDO ! CALL mp_sum ( itmp_g , intra_pool_comm ) ! ! here we are in crystal units rtmp_g ( 1 : 3 , 1 : ngm_g ) = REAL ( itmp_g ( 1 : 3 , 1 : ngm_g ) ) ! ! go to cartesian units (tpiba) CALL cryst_to_cart ( ngm_g , rtmp_g , bg , 1 ) ! ! compute squared moduli DO ig = 1 , ngm_g rtmp_gg ( ig ) = rtmp_g ( 1 , ig ) ** 2 + rtmp_g ( 2 , ig ) ** 2 + rtmp_g ( 3 , ig ) ** 2 ENDDO DEALLOCATE ( rtmp_g ) ! build the G+k array indexes ALLOCATE ( igk_l2g ( npwx , nks ) ) ALLOCATE ( kisort ( npwx ) ) DO ik = 1 , nks kisort = 0 npw = npwx CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , kisort ( 1 ), g2kin ) ! ! mapping between local and global G vector index, for this kpoint ! DO ig = 1 , npw ! igk_l2g ( ig , ik ) = ig_l2g ( kisort ( ig ) ) ! ENDDO ! igk_l2g ( npw + 1 : npwx , ik ) = 0 ! ngk ( ik ) = npw ENDDO DEALLOCATE ( kisort ) ! compute the global number of G+k vectors for each k point ALLOCATE ( ngk_g ( nkstot ) ) ngk_g = 0 ngk_g ( iks : ike ) = ngk ( 1 : nks ) CALL mp_sum ( ngk_g , world_comm ) ! compute the Maximum G vector index among all G+k and processors npw_g = maxval ( igk_l2g (:,:) ) CALL mp_max ( npw_g , world_comm ) ! compute the Maximum number of G vector among all k points npwx_g = maxval ( ngk_g ( 1 : nkstot ) ) IF ( ionode ) THEN ! write ( 50 , '(\"# Cell volume (a.u.)&#94;3. Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) omega ! write ( 50 , '(\"# Number of K-points. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nkstot ! write ( 50 , '(\"# ik, groundState, ngk_g(ik), wk(ik), xk(1:3,ik). Format: ''(3i10,4ES24.15E3)''\")' ) ! allocate ( groundState ( nkstot ) ) ! groundState (:) = 0 DO ik = 1 , nkstot do ibnd = 1 , nbnd if ( wg ( ibnd , ik ) / wk ( ik ) < 0.5_dp ) then !if (et(ibnd,ik) > ef) then groundState ( ik ) = ibnd - 1 goto 10 endif enddo 10 continue enddo ! endif ! ALLOCATE ( igwk ( npwx_g , nkstot ) ) ! DO ik = 1 , nkstot igwk (:, ik ) = 0 ! ALLOCATE ( itmp1 ( npw_g ), STAT = ierr ) IF ( ierr /= 0 ) CALL errore ( 'pw_export' , 'allocating itmp1' , abs ( ierr ) ) itmp1 = 0 ! IF ( ik >= iks . and . ik <= ike ) THEN DO ig = 1 , ngk ( ik - iks + 1 ) itmp1 ( igk_l2g ( ig , ik - iks + 1 ) ) = igk_l2g ( ig , ik - iks + 1 ) ENDDO ENDIF ! CALL mp_sum ( itmp1 , world_comm ) ! ngg = 0 DO ig = 1 , npw_g IF ( itmp1 ( ig ) == ig ) THEN ngg = ngg + 1 igwk ( ngg , ik ) = ig ENDIF ENDDO IF ( ngg /= ngk_g ( ik ) ) THEN if ( ionode ) WRITE ( 50 , * ) ' ik, ngg, ngk_g = ' , ik , ngg , ngk_g ( ik ) ENDIF ! DEALLOCATE ( itmp1 ) ! if ( ionode ) write ( 50 , '(3i10,4ES24.15E3)' ) ik , groundState ( ik ), ngk_g ( ik ), wk ( ik ), xk ( 1 : 3 , ik ) ! ENDDO ! if ( ionode ) then ! write ( 50 , '(\"# Number of G-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ngm_g ! write ( 50 , '(\"# Number of PW-vectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) npw_g ! write ( 50 , '(\"# Number of min - max values of fft grid in x, y and z axis. Format: ''(6i10)''\")' ) write ( 50 , '(6i10)' ) minval ( itmp_g ( 1 , 1 : ngm_g )), maxval ( itmp_g ( 1 , 1 : ngm_g )), & minval ( itmp_g ( 2 , 1 : ngm_g )), maxval ( itmp_g ( 2 , 1 : ngm_g )), & minval ( itmp_g ( 3 , 1 : ngm_g )), maxval ( itmp_g ( 3 , 1 : ngm_g )) ! write ( 50 , '(\"# Cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# a1 \",3ES24.15E3)' ) at (:, 1 ) * alat write ( 50 , '(\"# a2 \",3ES24.15E3)' ) at (:, 2 ) * alat write ( 50 , '(\"# a3 \",3ES24.15E3)' ) at (:, 3 ) * alat ! write ( 50 , '(\"# Reciprocal cell (a.u.). Format: ''(a5, 3ES24.15E3)''\")' ) write ( 50 , '(\"# b1 \",3ES24.15E3)' ) bg (:, 1 ) * tpiba write ( 50 , '(\"# b2 \",3ES24.15E3)' ) bg (:, 2 ) * tpiba write ( 50 , '(\"# b3 \",3ES24.15E3)' ) bg (:, 3 ) * tpiba ! write ( 50 , '(\"# Number of Atoms. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nat ! write ( 50 , '(\"# Number of Types. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nsp ! write ( 50 , '(\"# Atoms type, position(1:3) (a.u.). Format: ''(i10,3ES24.15E3)''\")' ) DO i = 1 , nat xyz = tau (:, i ) write ( 50 , '(i10,3ES24.15E3)' ) ityp ( i ), tau (:, i ) * alat ENDDO ! write ( 50 , '(\"# Number of Bands. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nbnd ! DO ik = 1 , nkstot ! open ( 72 , file = trim ( exportDir ) // \"/grid\" // iotk_index ( ik )) write ( 72 , '(\"# Wave function G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngk_g ( ik ) write ( 72 , '(4i10)' ) igwk ( ink , ik ), itmp_g ( 1 : 3 , igwk ( ink , ik )) enddo ! close ( 72 ) ! ENDDO ! open ( 72 , file = trim ( exportDir ) // \"/mgrid\" ) write ( 72 , '(\"# Full G-vectors grid\")' ) write ( 72 , '(\"# G-vector index, G-vector(1:3) miller indices. Format: ''(4i10)''\")' ) ! do ink = 1 , ngm_g write ( 72 , '(4i10)' ) ink , itmp_g ( 1 : 3 , ink ) enddo ! close ( 72 ) ! !DEALLOCATE( itmp_g ) ! write ( 50 , '(\"# Spin. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nspin ! allocate ( nnTyp ( nsp ) ) nnTyp = 0 do i = 1 , nat nnTyp ( ityp ( i )) = nnTyp ( ityp ( i )) + 1 enddo ! DO i = 1 , nsp ! call read_upf ( upf , grid , ierr , 71 , trim ( outdir ) // '/' // trim ( prefix ) // '.save/' // trim ( psfile ( i ))) ! if ( upf % typ == 'PAW' ) then ! write ( stdout , * ) ' PAW type pseudopotential found !' ! write ( 50 , '(\"# Element\")' ) write ( 50 , * ) trim ( atm ( i )) write ( 50 , '(\"# Number of Atoms of this type. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) nnTyp ( i ) write ( 50 , '(\"# Number of projectors. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) upf % nbeta ! number of projectors ! write ( 50 , '(\"# Angular momentum, index of the projectors. Format: ''(2i10)''\")' ) ms = 0 do inb = 1 , upf % nbeta write ( 50 , '(2i10)' ) upf % lll ( inb ), inb ms = ms + 2 * upf % lll ( inb ) + 1 enddo ! write ( 50 , '(\"# Number of channels. Format: ''(i10)''\")' ) write ( 50 , '(i10)' ) ms ! write ( 50 , '(\"# Number of radial mesh points. Format: ''(2i10)''\")' ) write ( 50 , '(2i10)' ) upf % mesh , upf % kkbeta ! number of points in the radial mesh, number of point inside the aug sphere ! write ( 50 , '(\"# Radial grid, Integratable grid. Format: ''(2ES24.15E3)''\")' ) do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % r ( im ), upf % rab ( im ) ! r(mesh) radial grid, rab(mesh) dr(x)/dx (x=linear grid) enddo ! write ( 50 , '(\"# AE, PS radial wfc for each beta function. Format: ''(2ES24.15E3)''\")' ) if ( upf % has_wfc ) then ! if true, UPF contain AE and PS wfc for each beta do inb = 1 , upf % nbeta do im = 1 , upf % mesh write ( 50 , '(2ES24.15E3)' ) upf % aewfc ( im , inb ), upf % pswfc ( im , inb ) ! wfc(mesh,nbeta) AE wfc, wfc(mesh,nbeta) PS wfc enddo enddo else write ( 50 , * ) 'UPF does not contain AE and PS wfcs!!' stop endif ! endif ! enddo ! ENDIF ! DEALLOCATE ( rtmp_gg ) !  ! for each k point build and write the global G+k indexes array !  ALLOCATE( igwk( npwx_g,nkstot ) ) !  !WRITE(0,*) \"Writing grids for wfc\" !  !CALL iotk_write_attr (attr,\"npwx\",npwx_g,first=.true.) !  !IF(ionode) CALL iotk_write_begin(50,\"Wfc_grids\",ATTR=attr) ! ! !  DO ik = 1, nkstot !    igwk(:,ik) = 0 !    ! !    ALLOCATE( itmp1( npw_g ), STAT= ierr ) !    IF ( ierr/=0 ) CALL errore('pw_export','allocating itmp1', abs(ierr) ) !    itmp1 = 0 !    ! !    IF( ik >= iks .and. ik <= ike ) THEN !      DO  ig = 1, ngk( ik-iks+1 ) !        itmp1( igk_l2g( ig, ik-iks+1 ) ) = igk_l2g( ig, ik-iks+1 ) !      ENDDO !    ENDIF !    ! !    CALL mp_sum( itmp1 ) !    ! !    ngg = 0 !    DO  ig = 1, npw_g !      IF( itmp1( ig ) == ig ) THEN !        ngg = ngg + 1 !        igwk( ngg , ik) = ig !      ENDIF !    ENDDO !    IF( ngg /= ngk_g( ik ) ) THEN !      WRITE( stdout,*) ' ik, ngg, ngk_g = ', ik, ngg, ngk_g( ik ) !    ENDIF !    ! !    DEALLOCATE( itmp1 ) !    ! !  ENDDO ! !  DEALLOCATE( itmp_g ) ! ! #ifdef __MPI CALL poolrecover ( et , nbnd , nkstot , nks ) #endif WRITE ( stdout , * ) \"Writing Eigenvalues\" IF ( ionode ) THEN ! write ( 50 , '(\"# Fermi Energy (Hartree). Format: ''(ES24.15E3)''\")' ) write ( 50 , '(ES24.15E3)' ) ef * ryToHartree flush ( 50 ) ! DO ik = 1 , nkstot ! ispin = isk ( ik ) ! open ( 72 , file = trim ( exportDir ) // \"/eigenvalues\" // iotk_index ( ik )) ! write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Eigenvalues (Hartree), band occupation number. Format: ''(2ES24.15E3)''\")' ) ! do ibnd = 1 , nbnd if ( wk ( ik ) == 0.D0 ) then write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) else write ( 72 , '(2ES24.15E3)' ) et ( ibnd , ik ) * ryToHartree , wg ( ibnd , ik ) / wk ( ik ) endif enddo ! close ( 72 ) ! ENDDO ! endif ! if ( ionode . and . writeWFC ) WRITE ( stdout , * ) \"Writing Wavefunctions\" ! wfc_scal = 1.0d0 twf0 = . true . twfm = . false . ! IF ( nkb > 0 ) THEN ! CALL init_us_1 CALL init_at_1 ! CALL allocate_bec_type ( nkb , nbnd , becp ) ! DO ik = 1 , nkstot ! local_pw = 0 IF ( ( ik >= iks ) . and . ( ik <= ike ) ) THEN CALL gk_sort ( xk ( 1 , ik + iks - 1 ), ngm , g , ecutwfc / tpiba2 , npw , igk , g2kin ) CALL davcio ( evc , nwordwfc , iunwfc , ( ik - iks + 1 ), - 1 ) CALL init_us_2 ( npw , igk , xk ( 1 , ik ), vkb ) local_pw = ngk ( ik - iks + 1 ) IF ( gamma_only ) THEN CALL calbec ( ngk_g ( ik ), vkb , evc , becp ) WRITE ( 0 , * ) 'Gamma only PW_EXPORT not yet tested' ELSE CALL calbec ( npw , vkb , evc , becp ) if ( ionode ) then ! WRITE ( stdout , * ) \"Writing projectors of kpt\" , ik ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/projectors\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              open(73, file=trim(exportDir)//\"/projectors\"//iotk_index(ik)) !              write(73, '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")') !              write(73,'(2i10)') nkb, ngk_g(ik) !              do j = 1, nkb !                do i = 1, ngk_g(ik) !                  write(73,'(2ES24.15E3)') vkb(i,j) !                enddo !              enddo !              close(73) !            endif !            ! !            file_exists = .false. !            inquire(file =trim(exportDir)//\"/evc\"//iotk_index(ik), exist = file_exists) !            if ( .not. file_exists ) then !              ! !              open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !              write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !              write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') !              write(74,'(2i10)') nbnd, ngk_g(ik) !              ! !              do j = 1, nbnd !                do i = 1, ngk_g(ik) !                  write(74,'(2ES24.15E3)') evc(i,j) !                enddo !              enddo !              ! !              close(74) !              ! !            endif !            ! file_exists = . false . inquire ( file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/projections\" // iotk_index ( ik )) write ( 72 , '(\"# Complex projections <beta|psi>. Format: ''(2ES24.15E3)''\")' ) do j = 1 , becp % nbnd ! number of bands do i = 1 , nkb ! number of projections write ( 72 , '(2ES24.15E3)' ) becp % k ( i , j ) enddo enddo ! close ( 72 ) ! endif endif ENDIF ENDIF ALLOCATE ( l2g_new ( local_pw )) l2g_new = 0 DO ig = 1 , local_pw ngg = igk_l2g ( ig , ik - iks + 1 ) DO ig_ = 1 , ngk_g ( ik ) IF ( ngg == igwk ( ig_ , ik )) THEN l2g_new ( ig ) = ig_ exit ENDIF ENDDO ENDDO ! ispin = isk ( ik ) ! if ( ionode ) then file_exists = . false . inquire ( file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik ), exist = file_exists ) if ( . not . file_exists ) then open ( 72 , file = trim ( exportDir ) // \"/wfc\" // iotk_index ( ik )) write ( 72 , '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")' ) ispin write ( 72 , '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")' ) ! open ( 73 , file = trim ( exportDir ) // \"/projectors\" // iotk_index ( ik )) write ( 73 , '(\"# Complex projectors |beta>. Format: ''(2ES24.15E3)''\")' ) write ( 73 , '(2i10)' ) nkb , ngk_g ( ik ) !          WRITE(stdout,*) \"Writing Wavefunctions of kpt\", ik !          open(74, file=trim(exportDir)//\"/evc\"//iotk_index(ik)) !          write(74, '(\"# Spin : \",i10, \" Format: ''(a9, i10)''\")') ispin !          write(74, '(\"# Complex : wavefunction coefficients (a.u.)&#94;(-3/2). Format: ''(2ES24.15E3)''\")') endif endif ! CALL mp_bcast ( file_exists , ionode_id , world_comm ) ! if ( . not . file_exists ) then CALL write_restart_wfc ( 72 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , evc , twf0 , evc , twfm , npw_g , gamma_only , nbnd , & l2g_new (:), local_pw ) CALL write_restart_wfc ( 73 , exportDir , ik , nkstot , kunit , ispin , nspin , & wfc_scal , vkb , twf0 , evc , twfm , npw_g , gamma_only , nkb , & l2g_new (:), local_pw ) endif ! if ( . not . file_exists . and . ionode ) then close ( 72 ) close ( 73 ) !        close(74) endif ! DEALLOCATE ( l2g_new ) ENDDO ! CALL deallocate_bec_type ( becp ) ! ENDIF DEALLOCATE ( igk_l2g ) DEALLOCATE ( igwk ) DEALLOCATE ( ngk_g ) END SUBROUTINE write_export END PROGRAM pw_export_for_TME","tags":"","loc":"program/pw_export_for_tme.html","title":"pw_export_for_TME – Carrier Cross Sections"},{"text":"Uses mpi TMEModule Todo Add detailed math derivation and summary for main program Walkthrough Use pre-built mpi library and declarations module that \n is defined in TME_Module_v28.f90 Initialize MPI environment Determine the rank or ID of the calling process Determine the size of the MPI pool (i.e., the number of processes) If this is the root process Call initializeCalculation to start timer and set default values Call readInput to read program input and\n  QE Export output Call readPWsSet to read g vectors from mgrid file Initialize all values in Ufi matrix to complex double zero Figure out how many g vectors/plane waves to give each process Initialize the number of initial and final plane waves to zero for each process For each process, calculate the initial (before this process) and final (after this process)\n  number of plane waves Todo Figure out if need to allocate space for arrays so soon Todo Figure out if SD and PC numOfGvecs should be the same Broadcast variables from root process to all other processes, allocating space as needed For each k point If I'm root, check if the matrix elements have already \n  been calculated and send the result to all other processes If the matrix elements haven't already been \n  calculated Allocate space for the projections cProj If I'm root Start a timer and output that starting to\n    calculate overlap Allocate space for the wavefunctions Read wavefunctions and calculate U_fi = \\langle\\Phi_f|\\Psi_i\\rangle Stop timer and output how long calculating overlap \n    took Output that starting projector augmented wave \n    portion Start a timer and report that doing PAW for \n    perfect crystal Read \\langle\\beta_{\\Psi}|\\Psi\\rangle from pw_export_for_TME Allocate space for cross projection \\langle\\beta_{\\Psi}|\\Phi\\rangle Calculate cross projection of |\\Phi\\rangle Deallocate space for solid defect wavefunction Calculate the 2nd and 3rd terms in C3 from paper Deallocate space for the cross projection of |\\Phi\\rangle Stop timer and output that finished PAW for perfect\n    crystal Start timer and output that started PAW for solid \n    defect Read \\langle\\beta_{\\Phi}|\\Phi\\rangle from pw_export_for_TME Allocate space for cross projection \\langle\\beta_{\\Phi}|\\Psi\\rangle Calculate cross projection of |\\Psi\\rangle Deallocate space for the perfect crystal wavefunction Calculate the 4th and 5th terms in C3 from paper Deallocate space for the cross projection of |\\Psi\\rangle Stop timer and output that finished PAW for solid \n    defect Start a timer and output that started k projections \n    for perfect crystal Send projectors to all other processes Allocate space for k projections for perfect crystal Calculate k projections for perfect crystal If I'm root Stop timer and output that done with k projection for \n    perfect crystal Start timer and output that started k projection for \n    solid defect Allocate space for k projections for solid defect Calculate k projections for solid defect If I'm root Stop timer and output that done with k projection for \n    solid defect Start timer and output that combining k projections For each initial and final band, sum the product of the \n     k projections of the solid defect and perfect crystal \n     to get the last term in equation C3 in the paper Allocate space for paw_SDKKPC if root and sum \n     individual sums from processes into a single total If I'm root Stop timer and output that done with summing k\n    projections Add PAW corrections to initially calculated overlap Output transition matrix elements for a given k point Deallocate space for the projections If the transition matrix elements for this k point have \n  already been calculated and I'm root, read in the existing\n  output file Deallocate space for the PAW corrections If my ID is root, calculate VfiElements if needed and finalize\n   calculation Contents Variables t1 t2 Source Code transitionMatrixElements Variables Type Attributes Name Initial real(kind=dp) :: t1 Start time used in various timers real(kind=dp) :: t2 End time used in various timers Source Code program transitionMatrixElements !! @todo Add detailed math derivation and summary for main program @endtodo !! !! <h2>Walkthrough</h2> !! use mpi use TMEModule !! * Use pre-built mpi library and declarations module that !! is defined in TME_Module_v28.f90 ! implicit none ! real ( kind = dp ) :: t1 !! Start time used in various timers real ( kind = dp ) :: t2 !! End time used in various timers ! call MPI_INIT ( ierr ) !! * Initialize MPI environment call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) !! * Determine the rank or ID of the calling process call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) !! * Determine the size of the MPI pool (i.e., the number of processes) ! allocate ( nPWsI ( 0 : numprocs - 1 ), nPWsF ( 0 : numprocs - 1 ) ) ! if ( myid == root ) then !! * If this is the root process !!    * Call [[TMEModule(module):initializeCalculation(subroutine)]] !!      to start timer and set default values !!    * Call [[TMEModule(module):readInput(subroutine)]] to read program input and !!      QE Export output !!    * Call [[TMEModule(module):readPWsSet(subroutine)]] to read g vectors from `mgrid` file !!    * Initialize all values in `Ufi` matrix to complex double zero !!    * Figure out how many g vectors/plane waves to give each process !!    * Initialize the number of initial and final plane waves to zero for each process !!    * For each process, calculate the initial (before this process) and final (after this process) !!      number of plane waves ! call initializeCalculation ( solidDefect , perfectCrystal , elementsPath , VFisOutput , ki , kf , eBin , & iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , calculateVFis , t0 ) ! call readInput ( perfectCrystal , solidDefect , elementsPath , iBandIinit , iBandIfinal , iBandFinit , iBandFfinal , & ki , kf , calculateVfis , VfisOutput ) ! call readPWsSet () ! !> @todo Figure out if need to allocate space for arrays so soon @endtodo allocate ( counts ( 0 : numprocs - 1 ) ) !, displmnt(0:numprocs-1) ) allocate ( Ufi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , perfectCrystal % nKpts ) ) allocate ( paw_SDKKPC ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( perfectCrystal % paw_Wfc ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( solidDefect % paw_Wfc ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( paw_fi ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) allocate ( eigvI ( iBandIinit : iBandIfinal ), eigvF ( iBandFinit : iBandFfinal ) ) ! Ufi (:,:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! call distributePWsToProcs ( solidDefect % numOfGvecs , numprocs ) !! @todo Figure out if SD and PC `numOfGvecs` should be the same @endtodo ! nPWsI (:) = 0 nPWsF (:) = 0 ! do i = 0 , numprocs - 1 nPWsI ( i ) = 1 + sum ( counts (: i - 1 )) nPWsF ( i ) = sum ( counts (: i )) enddo ! endif ! !-------------------------------------------------------------------------------------------------------- !> * Broadcast variables from root process to all other processes, allocating space as needed ! call MPI_BCAST ( iBandIinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandIfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFinit , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iBandFfinal , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % nKpts , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % nProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nBands , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % nSpins , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % numOfPWs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % numOfGvecs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( nPWsI , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nPWsF , numprocs , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( perfectCrystal % numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( JMAX , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( gvecs ( 3 , solidDefect % numOfGvecs ) ) call MPI_BCAST ( gvecs , size ( gvecs ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( perfectCrystal % atoms ( perfectCrystal % numOfTypes ) ) ! do i = 1 , perfectCrystal % numOfTypes ! call MPI_BCAST ( perfectCrystal % atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% numProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% iRAugMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( perfectCrystal % atoms ( i )% projAngMom ( perfectCrystal % atoms ( i )% numProjs ) ) allocate ( perfectCrystal % atoms ( i )% r ( perfectCrystal % atoms ( i )% nMax ) ) allocate ( perfectCrystal % atoms ( i )% rab ( perfectCrystal % atoms ( i )% nMax ) ) allocate ( perfectCrystal % atoms ( i )% F ( perfectCrystal % atoms ( i )% iRAugMax , perfectCrystal % atoms ( i )% numProjs ) ) allocate ( perfectCrystal % atoms ( i )% F1 ( perfectCrystal % atoms ( i )% iRAugMax , perfectCrystal % atoms ( i )% numProjs , & perfectCrystal % atoms ( i )% numProjs )) allocate ( perfectCrystal % atoms ( i )% bes_J_qr ( 0 : JMAX , perfectCrystal % atoms ( i )% iRAugMax ) ) endif ! call MPI_BCAST ( perfectCrystal % atoms ( i )% projAngMom , size ( perfectCrystal % atoms ( i )% projAngMom ), & MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% r , size ( perfectCrystal % atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% rab , size ( perfectCrystal % atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% F , size ( perfectCrystal % atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% F1 , size ( perfectCrystal % atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % atoms ( i )% bes_J_qr , size ( perfectCrystal % atoms ( i )% bes_J_qr ), & MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( perfectCrystal % nIons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( perfectCrystal % posIon ( 3 , perfectCrystal % nIons ), perfectCrystal % atomTypeIndex ( perfectCrystal % nIons ) ) call MPI_BCAST ( perfectCrystal % atomTypeIndex , size ( perfectCrystal % atomTypeIndex ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( perfectCrystal % posIon , size ( perfectCrystal % posIon ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! call MPI_BCAST ( solidDefect % numOfTypes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( solidDefect % atoms ( solidDefect % numOfTypes ) ) ! do i = 1 , solidDefect % numOfTypes ! call MPI_BCAST ( solidDefect % atoms ( i )% numOfAtoms , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% numProjs , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% lmMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% nMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% iRAugMax , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( solidDefect % atoms ( i )% projAngMom ( solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% r ( solidDefect % atoms ( i )% nMax ) ) allocate ( solidDefect % atoms ( i )% rab ( solidDefect % atoms ( i )% nMax ) ) allocate ( solidDefect % atoms ( i )% F ( solidDefect % atoms ( i )% iRAugMax , solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% F1 ( solidDefect % atoms ( i )% iRAugMax , & solidDefect % atoms ( i )% numProjs , solidDefect % atoms ( i )% numProjs ) ) allocate ( solidDefect % atoms ( i )% bes_J_qr ( 0 : JMAX , solidDefect % atoms ( i )% iRAugMax ) ) endif ! call MPI_BCAST ( solidDefect % atoms ( i )% projAngMom , size ( solidDefect % atoms ( i )% projAngMom ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% r , size ( solidDefect % atoms ( i )% r ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% rab , size ( solidDefect % atoms ( i )% rab ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% F , size ( solidDefect % atoms ( i )% F ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% F1 , size ( solidDefect % atoms ( i )% F1 ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % atoms ( i )% bes_J_qr , size ( solidDefect % atoms ( i )% bes_J_qr ), MPI_DOUBLE_PRECISION , & root , MPI_COMM_WORLD , ierr ) enddo ! call MPI_BCAST ( solidDefect % nIons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) allocate ( solidDefect % posIon ( 3 , solidDefect % nIons ), solidDefect % atomTypeIndex ( solidDefect % nIons ) ) call MPI_BCAST ( solidDefect % atomTypeIndex , size ( solidDefect % atomTypeIndex ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % posIon , size ( solidDefect % posIon ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! allocate ( paw_id ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal ) ) ! !-------------------------------------------------------------------------------------------------------- ! do ik = 1 , perfectCrystal % nKpts !! * For each k point !!    * If I'm root, check if the matrix elements have already !!      been calculated and send the result to all other processes !!    * If the matrix elements haven't already been !!      calculated !!       * Allocate space for the projections `cProj` !!       * If I'm root !!          * Start a timer and output that starting to !!            calculate overlap !!          * Allocate space for the wavefunctions !!          * Read wavefunctions and calculate !!            `U_fi`= \\langle\\Phi_f|\\Psi_i\\rangle !!          * Stop timer and output how long calculating overlap !!            took !!          * Output that starting projector augmented wave !!            portion !!          * Start a timer and report that doing PAW for !!            perfect crystal !!          * Read \\langle\\beta_{\\Psi}|\\Psi\\rangle !!            from [[pw_export_for_tme(program)]] !!          * Allocate space for cross projection !!            \\langle\\beta_{\\Psi}|\\Phi\\rangle !!          * Calculate cross projection of |\\Phi\\rangle !!          * Deallocate space for solid defect wavefunction !!          * Calculate the 2nd and 3rd terms in C3 from paper !!          * Deallocate space for the cross projection of !!            |\\Phi\\rangle !!          * Stop timer and output that finished PAW for perfect !!            crystal !!          * Start timer and output that started PAW for solid !!            defect !!          * Read \\langle\\beta_{\\Phi}|\\Phi\\rangle from !!            [[pw_export_for_tme(program)]] !!          * Allocate space for cross projection !!            \\langle\\beta_{\\Phi}|\\Psi\\rangle !!          * Calculate cross projection of |\\Psi\\rangle !!          * Deallocate space for the perfect crystal wavefunction !!          * Calculate the 4th and 5th terms in C3 from paper !!          * Deallocate space for the cross projection of !!            |\\Psi\\rangle !!          * Stop timer and output that finished PAW for solid !!            defect !!          * Start a timer and output that started k projections !!            for perfect crystal !!       * Send projectors to all other processes !!       * Allocate space for k projections for perfect crystal !!       * Calculate k projections for perfect crystal !!       * If I'm root !!          * Stop timer and output that done with k projection for !!            perfect crystal !!          * Start timer and output that started k projection for !!            solid defect !!       * Allocate space for k projections for solid defect !!       * Calculate k projections for solid defect !!       * If I'm root !!          * Stop timer and output that done with k projection for !!            solid defect !!          * Start timer and output that combining k projections !!       * For each initial and final band, sum the product of the !!         k projections of the solid defect and perfect crystal !!         to get the last term in equation C3 in the paper !!       * Allocate space for `paw_SDKKPC` if root and sum !!         individual sums from processes into a single total !!       * If I'm root !!          * Stop timer and output that done with summing k !!            projections !!          * Add PAW corrections to initially calculated overlap !!          * Output transition matrix elements for a given k point !!       * Deallocate space for the projections !!    * If the transition matrix elements for this k point have !!      already been calculated and I'm root, read in the existing !!      output file ! if ( myid == root ) then ! If I'm root, check if the matrix elements have ! already been calculated ! tmes_file_exists = . false . call checkIfCalculated ( ik , tmes_file_exists ) ! endif ! call MPI_BCAST ( tmes_file_exists , 1 , MPI_LOGICAL , root , MPI_COMM_WORLD , ierr ) ! Send the result to all other processes ! if ( . not . tmes_file_exists ) then ! If the matrix elements haven't already been calculated ! allocate ( perfectCrystal % cProj ( perfectCrystal % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) allocate ( solidDefect % cProj ( solidDefect % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) ! Allocate space for the projections `cProj` ! if ( myid == root ) then ! If I'm root ! write ( iostd , '(\" Starting Ufi(:,:) calculation for k-point\", i4, \" of\", i4)' ) ik , perfectCrystal % nKpts flush ( iostd ) ! write ( iostd , * ) write ( iostd , '(\"    Plane waves part begun.\")' ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> begun.\")' ) call cpu_time ( t1 ) ! Start a timer and output that starting to calculate overlap ! allocate ( perfectCrystal % wfc ( solidDefect % numOfPWs , iBandIinit : iBandIfinal ), & solidDefect % wfc ( solidDefect % numOfPWs , iBandFinit : iBandFfinal ) ) ! Allocate space for the wavefunctions ! call calculatePWsOverlap ( ik ) ! Read wavefunctions and calculate `U_fi`= \\langle\\Phi_f|\\Psi_i\\rangle ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 write ( iostd , '(\"    Plane waves part done in\", f10.2, \" secs.\")' ) t2 - t1 ! Stop timer and output how long calculating overlap took ! flush ( iostd ) write ( iostd , * ) write ( iostd , '(\"    PAW part begun.\")' ) ! Output that starting projector augmented wave portion ! write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start a timer and report that doing PAW for perfect crystal ! call readProjections ( ik , perfectCrystal ) ! Read \\langle\\beta_{\\Psi}|\\Psi\\rangle from [[pw_export_for_tme(program)]] ! allocate ( perfectCrystal % cCrossProj ( perfectCrystal % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) ! Allocate space for cross projection \\langle\\beta_{\\Psi}|\\Phi\\rangle ! call projectBeta ( ik , perfectCrystal , solidDefect ) ! Calculate cross projection of |\\Phi\\rangle ! deallocate ( solidDefect % wfc ) ! Deallocate space for solid defect wavefunction ! call pawCorrectionWfc ( perfectCrystal ) ! Calculate the 2nd and 3rd terms in C3 from paper ! deallocate ( perfectCrystal % cCrossProj ) ! Deallocate space for the cross projection of |\\Phi\\rangle ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\tilde{Psi}_f|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 ! Stop timer and output that finished PAW for perfect crystal ! write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start timer and output that started PAW for solid defect ! call readProjections ( ik , solidDefect ) ! Read \\langle\\beta_{\\Phi}|\\Phi\\rangle from [[pw_export_for_tme(program)]] ! allocate ( solidDefect % cCrossProj ( solidDefect % nProjs , solidDefect % nBands , solidDefect % nSpins ) ) ! Allocate space for cross projection \\langle\\beta_{\\Phi}|\\Psi\\rangle ! call projectBeta ( ik , solidDefect , perfectCrystal ) ! Calculate cross projection of |\\Psi\\rangle ! deallocate ( perfectCrystal % wfc ) ! Deallocate space for the perfect crystal wavefunction ! call pawCorrectionWfc ( solidDefect ) ! Calculate the 4th and 5th terms in C3 from paper ! deallocate ( solidDefect % cCrossProj ) ! Deallocate space for the cross projection of |\\Psi\\rangle ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\tilde{Phi}_i> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! Stop timer and output that finished PAW for solid defect ! write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start a timer and output that started k projections for perfect crystal ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6ES14.5E3)') ibi, ibf, solidDefect%paw_Wfc(ibf,ibi), perfectCrystal%paw_Wfc(ibf,ibi), paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! !call pawCorrection() !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = ibi, ibi !    paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) + paw_fi(ibf,ibi) !    write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf,ibi,ik), paw, Ufi(ibf,ibi,ik) + paw !  enddo !  ! !  flush(iostd) !  ! !enddo ! endif ! call MPI_BCAST ( perfectCrystal % cProj , size ( perfectCrystal % cProj ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( solidDefect % cProj , size ( solidDefect % cProj ), MPI_DOUBLE_COMPLEX , root , MPI_COMM_WORLD , ierr ) ! Send projectors to all other processes ! allocate ( perfectCrystal % pawK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid )) ) ! Allocate space for k projections for perfect crystal ! call pawCorrectionK ( perfectCrystal ) ! Calculate k projections for perfect crystal ! if ( myid == root ) then ! If I'm root ! call cpu_time ( t2 ) write ( iostd , '(\"      <\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 ! Stop timer and output that done with k projection for perfect crystal ! write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start timer and output that started k projection for solid defect ! endif ! allocate ( solidDefect % pawK ( iBandFinit : iBandFfinal , iBandIinit : iBandIfinal , nPWsI ( myid ): nPWsF ( myid ) ) ) ! Allocate space for k projections for solid defect ! call pawCorrectionK ( solidDefect ) ! Calculate k projections for solid defect ! if ( myid == root ) then ! If I'm root ! call cpu_time ( t2 ) write ( iostd , '(\"      <PAW_SD|\\\\vec{k}> done in\", f10.2, \" secs.\")' ) t2 - t1 ! Stop timer and output that done with k projection for solid defect ! write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> begun.\")' ) flush ( iostd ) call cpu_time ( t1 ) ! Start timer and output that combining k projections ! endif ! paw_id (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) ! do ibi = iBandIinit , iBandIfinal ! do ibf = iBandFinit , iBandFfinal ! For each initial and final band, sum the product of the k projections ! of the solid defect and perfect crystal to get the last term in ! equation C3 in the paper ! paw_id ( ibf , ibi ) = sum ( solidDefect % pawK ( ibf , ibi ,:) * perfectCrystal % pawK ( ibf , ibi ,:)) ! enddo ! enddo ! if ( myid == root ) paw_SDKKPC (:,:) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) CALL MPI_REDUCE ( paw_id , paw_SDKKPC , size ( paw_id ), MPI_DOUBLE_COMPLEX , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! Allocate space for `paw_SDKKPC` if root and sum individual sums from ! processes into a single total ! if ( myid == root ) then ! If I'm root ! call cpu_time ( t2 ) write ( iostd , '(\"      \\\\sum_k <PAW_SD|\\\\vec{k}><\\\\vec{k}|PAW_PC> done in\", f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! Stop timer and output that done with summing k projections ! Ufi (:,:, ik ) = Ufi (:,:, ik ) + solidDefect % paw_Wfc (:,:) + perfectCrystal % paw_Wfc (:,:) + & paw_SDKKPC (:,:) * 1 6.0_dp * pi * pi / solidDefect % omega ! Add PAW corrections to initially calculated overlap ! call writeResults ( ik ) ! Output transition matrix elements for a given k point ! !write(iostd,*)'--------------------------------------------------------------------------------------------' ! !do ibi = iBandIinit, iBandIfinal !  ! !  do ibf = iBandFinit, iBandFfinal !    !paw = solidDefect%paw_Wfc(ibf,ibi) + perfectCrystal%paw_Wfc(ibf,ibi) + paw_SDKKPC(ibf,ibi)*16.0_dp*pi*pi/solidDefect%omega !    !write(iostd,'(\" paw \", 2i4, 6f15.10)') ibi, ibf, Ufi(ibf, ibi, ik), paw, Ufi(ibf, ibi, ik) + paw !    !Ufi(ibf, ibi, ik) = Ufi(ibf, ibi, ik) + paw !    write(iostd,'(\" Ufi \", 2i4, 2ES24.15E3)') ibi, ibf, Ufi(ibf, ibi, ik) !  enddo !  ! !  flush(iostd) !  ! !enddo ! !write(iostd,*)'--------------------------------------------------------------------------------------------' !flush(iostd) ! endif ! deallocate ( perfectCrystal % cProj , perfectCrystal % pawK ) deallocate ( solidDefect % cProj , solidDefect % pawK ) ! Deallocate space for the projections ! else ! If the transition matrix elements for this k point have already been ! calculated and I'm root, read in the existing output file ! if ( myid == root ) call readUfis ( ik ) ! endif ! enddo ! if ( allocated ( paw_id ) ) deallocate ( paw_id ) if ( myid == root ) then if ( allocated ( perfectCrystal % paw_Wfc ) ) deallocate ( perfectCrystal % paw_Wfc ) if ( allocated ( solidDefect % paw_Wfc ) ) deallocate ( solidDefect % paw_Wfc ) endif !! * Deallocate space for the PAW corrections ! ! if ( myid == root ) then !! * If my ID is root, calculate `VfiElements` if needed and finalize !!   calculation ! if ( calculateVfis ) call calculateVfiElements () ! call finalizeCalculation () ! endif ! call MPI_FINALIZE ( ierr ) ! end program transitionMatrixElements","tags":"","loc":"program/transitionmatrixelements.html","title":"transitionMatrixElements – Carrier Cross Sections"},{"text":"Uses MjModule generalComputations Calculate some of the main variables in equations \n 42 and 43, calculate new displacements of atoms,\n and generate new QE input based on the new positions Walkthrough Include the generalComputations module for call to computeGeneralizedDisplacements and computeVariables Todo Make sure that there is an end timer Initialize variables, read input, and check that \n   all required variables were read and have values \n   that make sense Calculate \\delta q_j Compute main parts of equations 42 and 43 in paper\n   to make whole formula more manageable Calculate new positions of atoms for each mode \n   based on maxDisplacement and phonD If a base QE input was read, then export the new QE \n   input files with the new postions Otherwise, just write out the positions Contents Source Code MjME Source Code program MjME !! Calculate some of the main variables in equations !! 42 and 43, calculate new displacements of atoms, !! and generate new QE input based on the new positions !! !! <h2>Walkthrough</h2> !! use MjModule use generalComputations !! Include the `generalComputations` module !! for call to `computeGeneralizedDisplacements` !! and `computeVariables` ! implicit none ! call cpu_time ( ti ) !! @todo Make sure that there is an end timer @endtodo ! call readInputs () !! * Initialize variables, read input, and check that !!   all required variables were read and have values !!   that make sense ! allocate ( genCoord ( nModes ) ) ! call computeGeneralizedDisplacements ( nOfqPoints , nModes , genCoord , nAtoms , atomM , phonD , atomD ) !! * Calculate \\delta q_j ! deallocate ( atomM , atomD ) ! allocate ( x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : modeF + 1 , nModes ) ) ! call computeVariables ( x , Sj , coth , wby2kT , phonF , genCoord , kT , s2L , nModes , modeF , & besOrderNofModeM ) !! * Compute main parts of equations 42 and 43 in paper !!   to make whole formula more manageable ! deallocate ( genCoord ) ! call displaceAtoms () !! * Calculate new positions of atoms for each mode !!   based on `maxDisplacement` and `phonD` ! !> * If a base QE input was read, then export the new QE !>   input files with the new postions !> * Otherwise, just write out the positions if ( readQEInput ) then ! call exportQEInput () ! else ! call writeNewAtomicPositions () ! endif ! end program MjME","tags":"","loc":"program/mjme.html","title":"MjME – Carrier Cross Sections"},{"text":"Uses mpi lsf generalComputations Include the generalComputations module\n for call to computeGeneralizedDisplacements and computeVariables Initialize mpi and set up processes If root process Start a timer Read input, check all variables needed and initialize the calculation Calculate \\delta q_j Compute main parts of equations 42 and 43 in paper\n  to make whole formula more manageable Initialize or read LSF from file Allocate space for variables and broadcast to all processes so can move forward\n   with calculation For each possible phonon number less than 5 Calculate the line shape function explicitly by \n  summing contributions from using different numbers of bands For more than 2 phonons, split up the possible configurations \n  among the processes for speed then sum Calculate minimum energy bin size such that no bin is empty Output resulting line shape function","tags":"","loc":"program/lineshapefunction.html","title":"lineShapeFunction – Carrier Cross Sections"},{"text":"Uses mpi lsf Contents Source Code lineShapeFunction Source Code program lineShapeFunction ! use mpi use lsf ! implicit none ! call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) ! if ( myid == root ) then ! call cpu_time ( ti ) ! ! Reading input, initializing and checking all variables of the calculation. ! call readInputs () ! call readPhonons () ! call computeGeneralizedDisplacements () ! call computeVariables () ! call readMjs () ! call initializeLSF () ! endif ! call MPI_BCAST ( nModes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( modes , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( maximumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( minimumNumberOfPhonons , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( nEnergies , 1 , MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( deltaE , 1 , MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) ! if ( myid /= root ) then allocate ( phonF ( nModes ), x ( nModes ), Sj ( nModes ), coth ( nModes ), wby2kT ( nModes ), s2L ( nModes ) ) allocate ( besOrderNofModeM ( 0 : maximumNumberOfPhonons + 1 , nModes ) ) !    allocate( Vfis(-nEnergies:nEnergies) ) endif ! call MPI_BCAST ( phonF , size ( phonF ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( x , size ( x ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Sj , size ( Sj ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( coth , size ( coth ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( wby2kT , size ( wby2kT ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( besOrderNofModeM , size ( besOrderNofModeM ), MPI_DOUBLE_PRECISION , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( s2L , size ( s2L ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) !  call MPI_BCAST( Vfis, size(Vfis), MPI_DOUBLE_PRECISION,root,MPI_COMM_WORLD,ierr) ! allocate ( lsfVsEbyBands ( - nEnergies : nEnergies ) ) allocate ( iEbinsByBands ( - nEnergies : nEnergies ) ) ! allocate ( pj ( nModes ) ) ! if ( myid == root ) then ! !if ( maximumNumberOfPhonons > 0 ) then if ( ( minimumNumberOfPhonons < 2 ) . and . ( maximumNumberOfPhonons > 0 ) . and . ( modes > 0 ) ) then ! ! One phonon ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call lsfMbyOneBand ( 1 ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 1 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 1 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 1 , file = 'lsfVsEwithUpTo1phonons' , status = 'unknown' ) ! write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 1 ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 1 ) ! endif ! if ( ( minimumNumberOfPhonons < 3 ) . and . ( maximumNumberOfPhonons > 1 ) . and . ( modes > 1 ) ) then ! ! Two phonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! call cpu_time ( t1 ) ! call lsfMbyOneBand ( 2 ) call lsfMbyTwoBands ( 2 ) ! call cpu_time ( t2 ) ! write ( iostd , '(\" 2 modes, time needed :,\" , f10.2, \" secs.\")' ) t2 - t1 flush ( iostd ) ! ! calculate the DOS and update the total lsfVsE ! call calculateDE ( 2 , iEbinsByBands , de ) ! write ( iostd , * ) 'DE' , 2 , de flush ( iostd ) ! lsfVsE (:) = lsfVsE (:) + lsfVsEbyBands (:) / de ! open ( 2 , file = 'lsfVsEwithUpTo2phonons' , status = 'unknown' ) ! !      write(2,'(\"# \", i5, \" phonons\")') 2 write ( 2 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 2 do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 2 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyBands ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo ! close ( 2 ) ! endif ! !   call lsfDeterministicOneAndTwoBands() ! !deallocate ( lsfVsEbyPhonons ) ! endif ! allocate ( iModeIs ( 0 : numprocs - 1 ) ) allocate ( iModeFs ( 0 : numprocs - 1 ) ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! !if ( maximumNumberOfPhonons > 2 ) then if ( ( minimumNumberOfPhonons < 4 ) . and . ( maximumNumberOfPhonons > 2 ) . and . ( modes > 2 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! if ( myid == root ) then ! call lsfMbyOneBand ( 3 ) call lsfMbyTwoBands ( 3 ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 3 ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 3 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 3 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo3phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 3 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 3 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! !if ( maximumNumberOfPhonons > 3 ) then if ( ( minimumNumberOfPhonons < 5 ) . and . ( maximumNumberOfPhonons > 3 ) . and . ( modes > 3 ) ) then ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( 4 ) call lsfMbyTwoBands ( 4 ) ! call parallelIsFsBy3 () ! !write(6,*) '3' !do i = 0, nProcMax - 1 !  write(6,*) i, iModeIs(i), iModeFs(i) !enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( 4 ) ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) call parallelIsFsBy4 () ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !if ( myid == root ) then !  write(6,*) '4' !  do i = 0, nProcMax - 1 !    write(6,*) i, iModeIs(i), iModeFs(i) !  enddo !endif ! call lsfDeterministicFourPhononsByFourBands () ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) ! iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( 4 , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , 4 , de flush ( iostd ) ! open ( 1 , file = 'lsfVsEwithUpTo4phonons' , status = 'unknown' ) ! !      write(1,'(\"# \", i5, \" phonons\")') 4 write ( 1 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , 4 ! do iE = - nEnergies , nEnergies ! E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 1 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg enddo close ( 1 ) ! endif ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! endif ! if ( ( maximumNumberOfPhonons > 4 ) . and . ( modes > 4 ) ) then !if ( ( minimumNumberOfPhonons < 6 ) .and. ( maximumNumberOfPhonons > 4 ) ) then ! open ( unit = un , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) ! if ( myid == root ) then if ( istat /= 0 ) then write ( iostd , * ) 'File \"/dev/urandom\" not found! A pseudo random generator will be used!' else write ( iostd , * ) 'File \"/dev/urandom\" will be used to generate real random numbers!' endif flush ( iostd ) endif ! if ( istat /= 0 ) close ( un ) ! allocate ( iEbinsByPhonons ( - nEnergies : nEnergies ), lsfVsEbyPhonons ( - nEnergies : nEnergies ) ) allocate ( lsfbyPhononsPerProc ( - nEnergies : nEnergies ) ) ! if ( minimumNumberOfPhonons < 6 ) minimumNumberOfPhonons = 5 do m = minimumNumberOfPhonons , maximumNumberOfPhonons ! lsfVsEbyBands (:) = 0.0_dp iEbinsByBands (:) = 0 ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! call lsfMbyOneBand ( m ) call lsfMbyTwoBands ( m ) ! call parallelIsFsBy3 () ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! call lsfMbyThreeBands ( m ) ! !iEbinsByPhonons = 0 lsfVsEbyPhonons = 0.0_dp ! !CALL MPI_REDUCE(iEbinsByBands, iEbinsByPhonons, size(iEbinsByBands), MPI_INTEGER, MPI_SUM, root, MPI_COMM_WORLD, ierr) CALL MPI_REDUCE ( lsfVsEbyBands , lsfVsEbyPhonons , size ( lsfVsEbyPhonons ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( istat /= 0 ) CALL init_random_seed () ! iModeIs (:) = 0 iModeFs (:) = - 1 ! if ( myid == root ) then ! iMint = int ( nMC / numprocs ) iMmod = mod ( nMC , numprocs ) ! iModeIs ( 0 ) = 1 iModeFs ( numprocs - 1 ) = nMC do i = numprocs - 1 , 1 , - 1 iModeIs ( i ) = i * iMint + 1 if ( iMmod > 0 ) then iModeIs ( i ) = iModeIs ( i ) + iMmod iMmod = iMmod - 1 endif iModeFs ( i - 1 ) = iModeIs ( i ) - 1 enddo ! endif ! call MPI_BCAST ( iModeIs , size ( iModeIs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( iModeFs , size ( iModeFs ), MPI_INTEGER , root , MPI_COMM_WORLD , ierr ) ! !write(6,*) myid, iModeIs(myid), iModeFs(myid) ! do l = 4 , m ! !write(iostd,*) \"---------------------------------\" !write(iostd,*) m, \" by \", l !flush(iostd) ! times = 1.0_dp mi = l - 1 do ni = m - 1 , m - l + 1 , - 1 times = times * dble ( ni ) / dble ( mi ) mi = mi - 1 enddo ! allocate ( pj0s ( int ( times + 1.e-3_dp ), l ) ) ! pj0s (:,:) = 0 ! !write(6,*) 'distrubutePhononsInBands', m, l, times, int(times + 1.e-3_dp) call distrubutePhononsInBands ( m , l ) ! allocate ( pms ( 0 : 2 ** l - 1 , 0 : l - 1 ) ) ! pms (:,:) = 0 ! call calculatePlusMinusStates ( l ) ! lsfVsEbyBands (:) = 0.0_dp ! call lsfWithMphonons ( m , l , int ( times + 1.e-3_dp )) ! lsfbyPhononsPerProc (:) = 0.0_dp CALL MPI_REDUCE ( lsfVsEbyBands , lsfbyPhononsPerProc , size ( lsfbyPhononsPerProc ), & MPI_DOUBLE_PRECISION , MPI_SUM , root , MPI_COMM_WORLD , ierr ) if ( myid == root ) then ! weight = modes ! do iMode = 2 , l weight = weight * ( modes - iMode + 1 ) / iMode enddo ! write ( iostd , 101 ) m , l , times * weight write ( iostd , 102 ) m , l , real ( nMC , dp ) write ( iostd , 103 ) m , l , times * real ( nMC , dp ) write ( iostd , 104 ) weight / real ( nMC , dp ) flush ( iostd ) ! lsfVsEbyPhonons (:) = lsfVsEbyPhonons (:) + lsfbyPhononsPerProc (:) * weight / real ( nMC , dp ) ! !do iE = -nEnergies, nEnergies !  write(1000 + 10*m + l, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsEbyBands(iE)*(weight/real(nMC, dp)) !enddo !close(1000 + 10*m + l) ! endif ! deallocate ( pj0s , pms ) ! enddo ! iEbinsByPhonons = 0 CALL MPI_REDUCE ( iEbinsByBands , iEbinsByPhonons , size ( iEbinsByBands ), MPI_INTEGER , MPI_SUM , root , MPI_COMM_WORLD , ierr ) ! if ( myid == root ) then ! call calculateDE ( m , iEbinsByPhonons , de ) lsfVsE (:) = lsfVsE (:) + lsfVsEbyPhonons (:) / de ! write ( iostd , * ) 'DE' , m , de flush ( iostd ) ! if ( m < 10 ) then write ( fn , '(\"lsfVsEwithUpTo\", i1, \"phonons\")' ) m elseif ( m < 100 ) then write ( fn , '(\"lsfVsEwithUpTo\", i2, \"phonons\")' ) m elseif ( m < 1000 ) then write ( fn , '(\"lsfVsEwithUpTo\", i3, \"phonons\")' ) m else write ( fn , '(\"lsfVsEwithUpTo\", i4, \"phonons\")' ) m endif ! open ( unit = 5000 , file = trim ( fn ), status = 'unknown' ) ! !        write(5000,'(\"# \", i5, \" phonons\")') m write ( 5000 , '(\"#\", i10, \" energies\", i5, \" phonons\")' ) nEnergies , m ! do iE = - nEnergies , nEnergies E = real ( iE , dp ) * deltaE ! !vg = 1.0_dp !if (E > 0.0_dp) vg = sqrt(2.0_dp*E) write ( 5000 , '(F16.8,2E18.6e3)' ) E * HartreeToEv , lsfVsE ( iE ), lsfVsEbyPhonons ( iE ) / de !twoPi*abCM**2*volume*Vfis(iE)*lsfVsE(iE)/vg ! !write(5000, *) real(iE, dp)*deltaE*HartreeToEv, lsfVsE(iE), lsfVsEbyPhonons(iE)/de enddo close ( 5000 ) ! endif ! enddo ! deallocate ( iEbinsByPhonons , lsfVsEbyPhonons ) ! if ( istat == 0 ) close ( un ) ! endif ! if ( myid == root ) then ! call writeLSFandCrossSection () ! call cpu_time ( tf ) ! write ( iostd , '(\" Time needed: \", f10.2, \" secs.\")' ) tf - ti ! endif ! 101 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands : \" , E20 . 1 0E3 ) 102 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands sampled : \" , E20 . 1 0E3 ) 103 format ( \"   Total number of configurations of \" , i4 , \" phonons by \" , i4 , \" bands calculated : \" , E20 . 1 0E3 ) 104 format ( \"   Each sampled configuration will be weighted by : \" , E20 . 1 0E3 ) ! call MPI_FINALIZE ( ierr ) ! end program lineShapeFunction","tags":"","loc":"program/lineshapefunction~2.html","title":"lineShapeFunction – Carrier Cross Sections"},{"text":"Uses sigma_module Combine the results of TME and LSF\n into the cross section Read input, initializing and checking all variables of the calculation Calculate \\sigma(E) Output \\sigma(E) Contents Source Code crossSection Source Code program crossSection !! Combine the results of TME and LSF !! into the cross section ! use sigma_module ! implicit none ! call readInputs () !! * Read input, initializing and checking all variables of the calculation ! call calculateSigma () !! * Calculate \\sigma(E) ! call writeSigma () !! * Output \\sigma(E) ! end program crossSection","tags":"","loc":"program/crosssection.html","title":"crossSection – Carrier Cross Sections"},{"text":"Welcome to the README for the Carrier Cross Sections project! This tab contains more information\non the theory behind the code, the input and output files used by the code, and how to install/run\nthe code as well as a Todo list for cleaning up and developing the code.","tags":"","loc":"page//index.html","title":"README – Carrier Cross Sections"},{"text":"There are several input and output files used by this program. The goal of this\npage is to make it clear where these files come from, how they are used by the code\nand the physical meaning of the data in the files.","tags":"","loc":"page/inputOutput/index.html","title":"Input and Output Files – Carrier Cross Sections"},{"text":"This file is exported from pw_export_for_TME . It has the following format: # Cell volume ( a . u . ) &#94; 3 . Format : ' (ES24.15E3) ' 2 . 653020000000000 E + 002 # Number of K - points . Format : ' (i10) ' 2 # ik , groundState , ngk_g ( ik ) , wk ( ik ) , xk ( 1 : 3 , ik ) . Format : ' (3i10,4ES24.15E3) ' 1 0 180 5 . 000000000000000 E - 001 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 2 0 186 1 . 500000000000000 E + 000 2 . 500000000000000 E - 001 2 . 500000000000000 E - 001 7 . 500000000000000 E - 001 # Number of G - vectors . Format : ' (i10) ' 1459 # Number of PW - vectors . Format : ' (i10) ' 266 # Number of min - max values of fft grid in x , y and z axis . Format : ' (6i10) ' - 7 7 - 7 7 - 7 7 # Cell ( a . u . ) . Format : ' (a5, 3ES24.15E3) ' # a1 - 5 . 100000000000000 E + 000 0 . 000000000000000 E + 000 5 . 100000000000000 E + 000 # a2 0 . 000000000000000 E + 000 5 . 100000000000000 E + 000 5 . 100000000000000 E + 000 # a3 - 5 . 100000000000000 E + 000 5 . 100000000000000 E + 000 0 . 000000000000000 E + 000 # Reciprocal cell ( a . u . ) . Format : ' (a5, 3ES24.15E3) ' # b1 - 6 . 159985595274104 E - 001 - 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 # b2 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 # b3 - 6 . 159985595274104 E - 001 6 . 159985595274104 E - 001 - 6 . 159985595274104 E - 001 # Number of Atoms . Format : ' (i10) ' 2 # Number of Types . Format : ' (i10) ' 1 # Atoms type , position ( 1 : 3 ) ( a . u . ) . Format : ' (i10,3ES24.15E3) ' 1 0 . 000000000000000 E + 000 0 . 000000000000000 E + 000 0 . 000000000000000 E + 000 1 2 . 550000000000000 E + 000 2 . 550000000000000 E + 000 2 . 550000000000000 E + 000 # Number of Bands . Format : ' (i10) ' 4 # Spin . Format : ' (i10) ' 1 # Element Si # Number of Atoms of this type . Format : ' (i10) ' 2 # Number of projectors . Format : ' (i10) ' 6 # Angular momentum , index of the projectors . Format : ' (2i10) ' 0 1 0 2 1 3 1 4 2 5 2 6 # Number of channels . Format : ' (i10) ' 18 # Number of radial mesh points . Format : ' (2i10) ' 1141 837 # Radial grid , Integratable grid . Format : ' (2ES24.15E3) ' 6 . 513442611103688 E - 005 8 . 141803263879609 E - 007 6 . 595371633350159 E - 005 8 . 244214541687697 E - 007 6 . 678331195832729 E - 005 8 . 347913994790911 E - 007 6 . 762334261151813 E - 005 8 . 452917826439768 E - 007 6 . 847393954957285 E - 005 8 . 559242443696606 E - 007 ...\n# AE , PS radial wfc for each beta function . Format : ' (2ES24.15E3) ' 5 . 130578464215461 E - 004 3 . 370121859129863 E - 005 5 . 194773426646861 E - 004 3 . 412512773645108 E - 005 5 . 259771611021033 E - 004 3 . 455436900225269 E - 005 5 . 325583067433258 E - 004 3 . 498900945852498 E - 005 5 . 392217087420185 E - 004 3 . 542911701872407 E - 005 ...\n# Fermi Energy ( Hartree ) . Format : ' (ES24.15E3) ' 2 . 090654946391985 E - 001 Currently, the program does not read in cell volume, groundState , number of G vectors, the fft grid min and max values, real space or reciprocal space lattice vectors, number of bands, or spin format.","tags":"","loc":"page/inputOutput/exportedInput.html","title":"input – Carrier Cross Sections"},{"text":"Can use xcrysden to visualize QE input and output Can convert from QE output to xsf (VASP format) using PW/tools/pwo2xsf.sh There are four different types of extraction from the PWscf output: initial structure: the one reported from the input at the beginning of the output file (for the SCF calculation one should select this option) latest structure: the latest structure in the output file; if the latest structure is the optimized structure, then this one is extracted. For an SCF calculation only initial structure is reported and the \"latest structure\" extraction extracts noting in this case optimized structure: extracts the optimized structure, if it is not present it extracts nothing all structures as animation What is the purpose of the QE calculation? --> Explore the TME program PC stands for perfect crystal and SD stands for solid defect","tags":"","loc":"page/./notes.html","title":"Notes – Carrier Cross Sections"},{"text":"../LSF/src/zerothOrder/LSF_zeroth_Main.f90:107: Redo the loop for less than 5 phonons to be more clear and streamlined ../LSF/src/zerothOrder/LSF_zeroth_Main.f90:166: Change this to have size(iEbinsByBands) ../LSF/src/zerothOrder/LSF_zeroth_Main.f90:171: Add else iEbinsByPhonons = iEbinsByBands to remove if below ../LSF/src/zerothOrder/LSF_zeroth_Main.f90:172: Maybe change variable names to be clearer ../LSF/src/zerothOrder/LSF_zeroth_Main.f90:185: Figure out how getting de is \"calculating DOS\" and if not where DOS is ../LSF/src/zerothOrder/LSF_zeroth_Main.f90:186: Figure out why DOS isn't in sum as in formula ../LSF/src/zerothOrder/LSF_zeroth_Main.f90:302: Move the behavior of splitting up Monte Carlo steps to a subroutine ../LSF/src/zerothOrder/LSF_zeroth_Main.f90:333: Move this to a subroutine ../LSF/src/zerothOrder/LSF_zeroth_Main.f90:339: Replace this with binomialCoefficient(kPhonons-1, kPhonons-nBands) ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:183: Figure out why increase minimumNumberOfPhonons by 1 ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:376: Remove all of these comments ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:440: Figure out if iModeFs(myid) has a max of nModes-3 or nModes-nBands+1 ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:465: Figure out what the purpose of ic is ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:529: Change this to merge if statements ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:543: Figure out why don't just exit here because will be multiplying by 0 ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:563: Redo besRatio if statement to be more clear that it is if/else ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:609: Send slice instead of using other ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:622: Figure out if there is a better way in general to do this ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:623: Write a recursive function to replace explicit loops ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:624: Fix typo in distrubute ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:625: Change l to nBands and m to kPhonons or something similar ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:666: Add a condition to exit inner loop if i1 + i2 + i3 > m ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:675: Add a condition to exit inner loop if i > size of pj0s ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1031: Make sure that Monte Carlo makes sense here ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1032: Figure out if there are any methods that would be better/faster ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1068: Figure out a better way to do this as it is crazy inefficient ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1073: Remove as not needed ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1094: Fix the possible bug here ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1105: Move some of this to another subroutine ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1187: Figure out why array is reversed ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1227: Figure out if there is a clearer or faster way to do this ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1228: Maybe move this to a subroutine ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1253: Switch the .true. and .false. assignments to make more sense ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1404: Replace this with binomialCoefficient(kPhonons-1, kPhonons-nBands) ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1471: Change the name of this subroutine to just writeLSF ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1472: Remove all of the extra stuff from this subroutine ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1571: Merge this with parallelIsFsBy4 ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1581: Write a binomialCoefficient function ../LSF/src/zerothOrder/LSF_zeroth_Module_v35.f90:1608: Change this to use available states instead of totalStates ../Mj/src/Mj_Main.f90:17: Make sure that there is an end timer ../Mj/src/Mj_Module_v1.f90:25: Make sure default value is set for qPoint ../Mj/src/Mj_Module_v1.f90:269: Figure out if expect modeI and modeF to represent index of magnitude of argument x ../Mj/src/Mj_Module_v1.f90:381: Make this loop more clear ../Sigma/src/Sigma_Module_v4.f90:176: Merge these dummy characters ../Sigma/src/Sigma_Module_v4.f90:224: Merge dummy variables ../Sigma/src/Sigma_Module_v4.f90:288: Figure out where this file is opened ../Sigma/src/Sigma_Module_v4.f90:299: Figure out where this file is opened ../Sigma/src/Sigma_Module_v4.f90:325: Figure out where this file is opened ../Sigma/src/Sigma_Module_v4.f90:329: Figure out what abCM is ../TME/src/TME_Main_v9.f90:2: Add detailed math derivation and summary for main program ../TME/src/TME_Main_v9.f90:48: Figure out if need to allocate space for arrays so soon ../TME/src/TME_Main_v9.f90:60: Figure out if SD and PC numOfGvecs should be the same ../TME/src/TME_Module_v28.f90:34: Change I/O from file to console so that usage matches that of QE ../TME/src/TME_Module_v28.f90:156: Consider changing atom type to element since it holds more than one atom ../TME/src/TME_Module_v28.f90:402: Change checkInitialization() to have arguments to make clear that these variables are getting changed ../TME/src/TME_Module_v28.f90:544: Remove everything with ki and kf because never used ../TME/src/TME_Module_v28.f90:831: Look more into how AE and PS wavefunctions are combined to further understand this ../TME/src/TME_Module_v28.f90:832: Move this behavior to another subroutine for clarity ../TME/src/TME_Module_v28.f90:841: Figure out if differences in PC and SD F1 calculations are intentional ../TME/src/TME_Module_v28.f90:842: Figure out if should be (wae_i wae_j - wps_i wps_j)r_{ab} ../TME/src/TME_Module_v28.f90:843: Figure out if first term in each should be conjugated for inner product form ../TME/src/TME_Module_v28.f90:844: Figure out if rab plays role of dr within augmentation sphere ../TME/src/TME_Module_v28.f90:883: Figure out if intentional to only use JMAX from SD input ../TME/src/TME_Module_v28.f90:1213: Get actual perfect crystal and solid defect output to test ../TME/src/TME_Module_v28.f90:1214: Figure out if loop should be over solidDefect or perfectCrystal ../TME/src/TME_Module_v28.f90:1215: Look into nSpins to figure out if it is needed ../TME/src/TME_Module_v28.f90:1233: Figure out what this subroutine really does ../TME/src/TME_Module_v28.f90:1355: Figure out what this subroutine really does ../TME/src/TME_Module_v28.f90:1407: Figure out the significance of l = l&#94;{\\prime} and m = m&#94;{\\prime} ../TME/src/TME_Module_v28.f90:1439: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:1452: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:1489: Figure out what this subroutine really does ../TME/src/TME_Module_v28.f90:1561: Figure out if this output slows things down significantly ../TME/src/TME_Module_v28.f90:1562: Figure out if formula gives accurate representation of time left ../TME/src/TME_Module_v28.f90:1606: Figure out if this should be system ../TME/src/TME_Module_v28.f90:1607: Figure out significance of \"qr\" point ../TME/src/TME_Module_v28.f90:1610: Test if can just directly store in each atom type's bes_J_qr ../TME/src/TME_Module_v28.f90:1630: Figure out if this should be gDotR ../TME/src/TME_Module_v28.f90:1632: Figure out why this is called ATOMIC_CENTER ../TME/src/TME_Module_v28.f90:1633: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:1662: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:1677: Figure out why the difference between SD and PC ../TME/src/TME_Module_v28.f90:2172: Figure out what the purpose of this function is. For plotting? ../TME/src/TME_Module_v28.f90:2259: Figure out why DHifMin is needed ../TME/src/TME_Module_v28.f90:2260: Figure out why used difference rather than `== ../TME/src/TME_Module_v28.f90:2265: Figure out why this test is here. All of these should be positive, right? ../TME/src/TME_Module_v28.f90:2319: Figure out where unit 12 file is opened and what it is ../TME/src/TME_Module_v28.f90:2354: Figure out why use eMin + iE*eBin rather than DE","tags":"","loc":"page/./todo.html","title":"Todo – Carrier Cross Sections"}]}